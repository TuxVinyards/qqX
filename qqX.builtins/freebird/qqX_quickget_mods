#!/usr/bin/env bash

##  qqX - quickemu quickget X terminal project

#  ADDS IN NEW DISTRO LISTINGS and ALLOWS FUNCTION OVERWRITES
#  qqX component to be located in builtins folder

##  Copyright (c)  Alex Genovese   https://github.com/qqxproject
#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.
# 	Otherwise:
#   Licence  GPL3   https://www.gnu.org/licenses

##  May contain MIT licensed snippets or functions from the Quickemu project that have been modified.

## ShellCheck global disables:
# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC1091,SC2024, SC2154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242,SC1090,SC1091,SC2034,SC2154

## CODING STYLE

#  A more MODERN BASH style of coding is used for qqX than that used for QuickEmu.

#  However, NOT TO WORRY if you are only familiar the older more POSIX styles, there are still plenty of options
#  for contributions to the quickemu built-ins, particularly with this file:
#  Use 4 space tabs with this file, as with QuickGet, so that code can be directly pasted into here and tweaked.
#  QuickGet and qqX house styles may be mixed, WHICHEVER IS EASIEST. See notes at end for qqX coding style.

#  This script is sourced when running a Quickget builtin. It remains variable isolated from running instances of qqX.
#  Take care to maintain QuickGet variable name continuity where needed.

#  To test code, run './quickget --check distroname' etc from a terminal opened in the relevant builtin folder.

##########################################

## 1:  LISTS & FILTERS (alphabetical, space separated and space isolated at each end)

# osAddList for new qqX listed distros
osAddList=" anduinos bluestar "
#osAddList+=" another "

# osRemoveList for distros that are problematic or no longer maintained, but still listed by Quickget
osRemoveList=" arcolinux holoiso truenas-core vxlinux "
#osRemoveList+=" another and-one-more "

osSupported="$(os_support)"
osSupported+=" $osAddList "
osSupported="${osSupported//'  '/' '}"
osSupported="$(tr ' ' '\n' <<< "$osSupported" | sort -bd)"
osSupported="$(paste -s -d ' ' <<< "$osSupported")"
osSupported="${osSupported//'  '/' '}"
osSupported_All="$osSupported"

osRemoveList="${osRemoveList//'  '/' '}"
osRemoveList="${osRemoveList//'  '/' '}"
mapfile -t -d ' ' osRemoveArr <<< "$osRemoveList"

## For FILTER CALLS, see/add at start of quick_REROUTE_get
# The call will cause a defined list to be shown by triggering a controlled error state in Quickget ...

osServersList=" alpine centos-stream freedos proxmox-ve "
osServersList+=" truenas-scale ubuntu-server windows-server "
osServersList="${osServersList//'  '/' '}"
osServersList="${osServersList//'  '/' '}"

osGamingList=" batocera bazzite cachyos garuda nobara "
osGamingList+=" popos sparkylinux "
osGamingList="${osGamingList//'  '/' '}"
osGamingList="${osGamingList//'  '/' '}"

osUsbList=" alpine freedos kolibrios "
osUsbList+=" slax slitaz tinycore "
osUsbList="${osUsbList//'  '/' '}"
osUsbList="${osUsbList//'  '/' '}"

osSecList=" athenaos kali "
osSecList+=" parrotsec tails "
osSecList="${osSecList//'  '/' '}"
osSecList="${osSecList//'  '/' '}"

# A qqlist- prefix is used to make sure any calls to Quickget don't confuse list names with distro names
# See function 'load_QGW_OS_Array' in the 'reroute_get' script
if [[ $1 == "qqlist-desktop"  ]] ; then mapfile -t -O "${#osRemoveArr[@]}" -d ' ' osRemoveArr <<< "$osServersList"
elif [[ $1 == "qqlist-server-cl" ]] ; then osSupported="$osServersList"
elif [[ $1 == "qqlist-gaming" ]] ; then osSupported="$osGamingList"
elif [[ $1 == "qqlist-ultra-light" ]] ; then osSupported="$osUsbList"
elif [[ $1 == "qqlist-security" ]] ; then osSupported="$osSecList"
else osSupported="$osSupported_All"
fi

for Rem in "${osRemoveArr[@]}"; do
	osSupported="${osSupported//" $Rem "/' '}"
done

osSupported="${osSupported//'   '/' '}"
osSupported="${osSupported//'  '/' '}"
osSupported="${osSupported//'  '/' '}"

# replace old function, but only after old one has been read
function os_support { echo " $osSupported " ; }

##########################################

## 2: INFO
# Needed for new qqX listed distros or use for INFO overwrites

function os_info {
    local INFO=
    case "$1" in
        #name)            INFO="PrettyName|Credentials|Homepage|Info";;
        anduinos)         INFO="Anduin OS|-|https://www.anduinos.com/|Ubuntu-based Linux distribution that aims to facilitate developers transitioning from Windows.";;
        archcraft)        INFO="Archcraft|-|https://archcraft.io/|Collection of minimal Linux distributions, based on Arch Linux.";;
        bluestar)         INFO="Blue Star|-|https://sourceforge.net/projects/bluestarlinux/|Arch based, MacOS-like take on KDE Plasma that's easy to use.";;
        garuda)           INFO="Garuda Linux|-|https://garudalinux.org/|Arch based Linux distribution. Minimal or Full styling with option packs.";;
        kolibrios)        INFO="KolibriOS|-|https://git.kolibrios.org/|Tiny yet incredibly powerful and fast operating system.";;
        slint)            INFO="Slint|-|https://slint.fr/|BLIND-FRIENDLY, easy-to-use, versatile Linux distribution for 64-bit computers. Slint is based on Slackware and borrows tools from Salix. Maintainer: Didier Spaier.";;
        tinycore)         INFO="Tiny Core Linux|-|http://www.tinycorelinux.net/|Nomadic ultra small graphical desktop operating system capable of booting from cdrom, pendrive, or frugally from a hard drive.";;
        void)             INFO="Void Linux|anon:voidlinux|https://voidlinux.org/|Non-Systemd desktop operating system based on Runit. Software is provided in binary packages or can be built directly from sources.";;
    esac
	[[ ! $INFO ]] && INFO="$(os_info_QG "$1")"
    echo "$INFO"
}

# Add release/installation notes where needed, omit if not.

function distro_release_notes {
    local RelNotes=
    case "$1" in
        #name)            RelNotes="mm/yyyy (as needed)  Notes on installation or problems to watch out for";;
        artixlinux)       RelNotes="06/2025 The new online install option is still work-in-progress, users are advised to select 'Offline' when prompted.";;
        macos)            RelNotes="06/2025 Sequoia is currently having issues with slow running. See qqX issue #9";;
        mxlinux)          RelNotes="Community Spins and 32 bit versions are also available in various flavors. See website for direct download";;
        sparkylinux)      RelNotes="07/2025 Older specialist versions: 'gameover' 'multimedia' and 'rescue' are available via manual download";;
        void)             RelNotes="To install the packages for the desktop environment, DON'T choose 'install from network' choose the 'local install' option.";;
    esac
    echo "$RelNotes"
}

##########################################

## 3: RELEASES, EDITIONS and DOWNLOAD URL
# Needed for new qqX listed distros or use for "releases_${OS} ()" and "editions_${OS} ()" overwrites.

# Quickget's behaviour is to continually exit on error until the correct input combination is made.
# This means that Quickget probes normally have to be carried out via repeated and discontiguous command line args requests
# and that the use of global variables is either limited or not possible:

# IF CHECKING editions, the var $RELEASE becomes available in the function editions_$OS
# When running complete distro checks, via './quickget --check distroname', this uses function 'test-all' and
# both vars $RELEASE & $EDITION become available in the 'get' function.

# The first two FUNCTIONS feed STDOUT to the look-up function 'validate_release' followed by
# the last lines of Quickget where distro editions are handled.

# Transfer files may also be implemented:
# See 'editions_anduinos' for a more complex example script and 'get_parrotsec' for simpler cases
# Some distros single release with no editions eg. bluestar

# Quickget's legacy behaviour is to return a 'STOCK LIST' of editions when no release is supplied ...
# Probably has room for improvement but a list should be given.
# See 'editions_gnomeos' for a per edition check routine, where some may be absent.

# Note that Quickget's 'web_pipe()' is an alias for Curl and will generate STDOUT by itself, without needing 'echo'.
# Also that further echoes can be avoided via Bash's <<< 'herestring' feature.

# THE 'GET' FUNCTION should generate the download target and a checksum.
# Quickget often employs local variables $URL and $HASH but any format may be used.
# The last line should supply the DOWNLOAD TARGET TO STDOUT to $1, to be read by create_vm() or test-all() etc.
# If available, the checksum should be downloaded, cleaned and supplied to $2.

# Where possible, try to keep web greps dynamic. This is made easier with 'floatversion' and may include 'fv' pipes.
# See https://github.com/TuxVinyards/floatversion

# Place standard sized 'get' functions here, next to releases and editions, and any oversized ones in section 7.
# Downloads may occasionally need a special tidy-up and finalization. See sections 4 to 6.

# For testing code, run './quickget --check distroname' from a terminal opened in the relevant builtin folder.

## ADD
function releases_anduinos {
    echo "LTS Standard"
}
function editions_anduinos {
    if [[ ! $RELEASE ]]; then
        echo "ar_SA de_DE en_GB en_US es_ES fr_FR it_IT ja_JP ko_KR nl_NL pl_PL pt_BR pt_PT ru_RU sv_SE th_TH tr_TR vi_VN zh_CN zh_HK zh_TW"
        return 0  # Stock List @ June 2025
    fi
    # Otherwise check for editions per release
    while true ; do
        if ! { grep -qs "$OS" "/tmp/qGet.Mods.REL.data.txt" && grep -s 'ReleaseName=' "/tmp/qGet.Mods.REL.data.txt" | grep -qs "$RELEASE"; } ; then
            printf "qGetDistro=\"%s\"\nReleaseName=\"%s\"" "$OS" "$RELEASE" > "/tmp/qGet.Mods.REL.data.txt"
            if [[ $RELEASE == "LTS" ]]; then ReleaseNumber="$(web_pipe "https://docs.anduinos.com/VERSIONS.html" |tr '>' '\n' | grep '</td' | grep LTS | fv -M -Q)"
            else ReleaseNumber="$(web_pipe "https://docs.anduinos.com/VERSIONS.html" |tr '>' '\n' | grep '</td' | grep -v LTS | fv -M -Q)"
            fi
            ReleasePoint="$(web_pipe "https://download.anduinos.com/${ReleaseNumber}/" | grep href | fv -M -Q )"
            ReleaseEditions="$(web_pipe "https://download.anduinos.com/${ReleaseNumber}/${ReleasePoint}" \
            | grep -v sha256 | grep -v torrent | tr '>' '\n' | grep iso | grep -v '<a' | cut -d'<' -f1 | cut -d'-' -f3 | cut -d'.' -f1 | paste -s -d' ')"
            printf "\nReleaseName=\"%s\"\nReleaseNumber=\"%s\"\nReleasePoint=\"%s\"\nReleaseEditions=\"%s\"" "$RELEASE" "$ReleaseNumber" "$ReleasePoint" "$ReleaseEditions" > "/tmp/qGet.Mods.REL.data.txt"
            sleep 1
        fi
        ReleaseName= ; ReleaseNumber= ; ReleasePoint= ; ReleaseEditions=
        source "/tmp/qGet.Mods.REL.data.txt"
        if [[ $ReleaseName && $ReleaseNumber && $ReleasePoint && $ReleaseEditions ]] ; then break
        else printf "" > "/tmp/qGet.Mods.REL.data.txt"
        fi
    done
    printf "%s" "$RELEASE" > "/tmp/qGet.Mods.ED.data.txt"
    printf "" > "/tmp/qGet.Mods.GET.data.txt"
    [[ ! $ReleaseEditions ]] && source "/tmp/qGet.Mods.REL.data.txt"
    echo "$ReleaseEditions"
}
function get_anduinos {
    source "/tmp/qGet.Mods.REL.data.txt"
    # for looping through test-all
    sleep 0.5
    AnduinIso="https://download.anduinos.com/${ReleaseNumber}/${ReleasePoint}/AnduinOS-${ReleasePoint}-${EDITION}.iso"
    AnduinHash="$(web_pipe "https://download.anduinos.com/${ReleaseNumber}/${ReleasePoint}/AnduinOS-${ReleasePoint}-${EDITION}.sha256" \
    | cut -d':' -f2 | tr -cd '[:graph:]')"
    echo "$AnduinIso $AnduinHash"
    printf "%s" "$EDITION" > "/tmp/qGet.Mods.GET.data.txt"
}

## FIX artix community editions and hash grep
function get_artixlinux() {
    local HASH="" ; local ISO=""
    local URL="https://download.artixlinux.org/iso"
    if [[ $EDITION == "community-gtk" ]]; then ISO="artix-community-gtk-openrc-${RELEASE}-x86_64.iso"
    elif [[ $EDITION == "community-qt" ]]; then ISO="artix-community-qt-openrc-${RELEASE}-x86_64.iso"
    else ISO="artix-${EDITION}-${RELEASE}-x86_64.iso"
    fi
    HASH=$(web_pipe "${URL}/sha256sums" | grep -s "${ISO}" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## UPDATE new repo
function releases_athenaos() {
    echo latest
}
function get_athenaos() {
    local HASH=""
    local URL="https://github.com/Athena-OS/athena/releases/latest/download/athenaos-rolling-x86_64.iso"
    HASH=$(web_pipe "${URL}.sha256" | cut -d' ' -f1)
    echo "${URL} ${HASH}"
}

## UPDATE url
function get_blendos() {
    local HASH=""
    local URL="https://at.blendos.niranjan.co/blendOS.iso"
    echo "${URL} ${HASH}"
}

## ADD
function releases_bluestar {
    echo "latest"
}
function get_bluestar {
    BlueStarRelease="$(web_pipe https://sourceforge.net/projects/bluestarlinux/ | tr ' ' '\n' | grep -s -e '\.iso')"
    BlueStarIso="https://sourceforge.net/projects/bluestarlinux/files/distro/${BlueStarRelease}"
    BlueStarHash="https://sourceforge.net/projects/bluestarlinux/files/distro/${BlueStarRelease/iso/md5}"
    BlueStarHash="$(web_pipe "$BlueStarHash" | cut -d' ' -f1)"
    echo "$BlueStarIso $BlueStarHash"
}

## FIX bodhi editions
function editions_bodhi() {
    if [[ ! $RELEASE ]]; then echo "standard hwe s76"
    elif  fv -Q --gt "$RELEASE 6.9" ; then echo "standard hwe s76"
    else echo "standard hwe"
    fi
}

## FIX Easy OS release list
function releases_easyos() {
    local ALL_RELEASES="" ; local YEAR=""
    # get the latest 2 years of releases so that when we hit next year we still have the latest 2 years
    TWO_YEARS=$(web_pipe https://distro.ibiblio.org/easyos/amd64/releases/kirkstone/ | grep -o -E '[[:digit:]]{4}/' | sort -nr | tr -d /  | head -n 2 )
    for YEAR in ${TWO_YEARS} ; do
        ALL_RELEASES="${ALL_RELEASES} $(web_pipe https://distro.ibiblio.org/easyos/amd64/releases/kirkstone/"${YEAR}"/ | grep -o -E '[[:digit:]]+(\.[[:digit:]])+/' | tr -d / )"
    done
    ALL_RELEASES="$(floatversion -qs -r "$ALL_RELEASES")"
    echo "${ALL_RELEASES}"
}

## FIX Cosmic Atomic
function get_fedora() {
    local HASH="" ; local ISO="" ; local JSON="" ; local URL="" ; local VARIANT=""
    case ${EDITION} in
        KDE) if [[ $RELEASE -ge 42 ]]; then VARIANT="${EDITION}"; else VARIANT="Spins"; fi ;;
        Server|Kinoite|Onyx|Silverblue|Sericea|Workstation|COSMIC-Atomic) VARIANT="${EDITION}";;
        *) VARIANT="Spins";;
    esac
    # The naming of 41 Beta with a space is problematic so we replaced it with an underscore but we need to convert it back to a space
    # for the URL search in the JSON if RELEASE contains an underscore, replace it with a space
    [[ "${RELEASE}" == *"_"* ]] && RELEASE="${RELEASE/_/ }"
    # shellcheck disable=SC2086
    JSON=$(web_pipe_json "https://getfedora.org/releases.json" | jq '.[] | select(.variant=="'${VARIANT}'" and .subvariant=="'"${EDITION}"'" and .arch=="x86_64" and .version=="'"${RELEASE}"'" and (.link | endswith(".iso")))')
    URL=$(echo "${JSON}" | jq -r '.link' | head -n1)
    HASH=$(echo "${JSON}" | jq -r '.sha256' | head -n1)
    echo "${URL} ${HASH}"
}

## FIX & UPDATE to current format
function releases_gnomeos() {
    web_pipe "https://download.gnome.org/gnomeos/" | grep -s href | grep link | fv -M 3 -Q
}
function editions_gnomeos() {
    if [[ ! $RELEASE ]]; then  echo "release rc beta alpha"
    else
        local GnomeBase= ; GnomeBase="${RELEASE/%.*}"
        local GnomeFolder= ; local BaseUrl= ; local ISO= ; local GnomeChk= ; local GnomeEditions=
        for GnomeChk in release rc beta alpha ; do
            case $GnomeChk in
                release)    GnomeFolder="${GnomeBase}.0" ;;
                rc)         GnomeFolder="${GnomeBase}.rc" ;;
                beta)       GnomeFolder="${GnomeBase}.beta" ;;
                alpha)      GnomeFolder="${GnomeBase}.alpha" ;;
            esac
            BaseUrl="https://download.gnome.org/gnomeos/${GnomeFolder}"
            # each folder has the latest only, but alpha may exist without beta and rc etc
            ISO="$(web_pipe "$BaseUrl" | grep -s href | tr ' ' '\n' | grep title | head -n 1 | cut -d'"' -f2 )"
            [[ "$ISO" == *'.iso' ]] && GnomeEditions+="$GnomeChk "
        done
        echo "$GnomeEditions"
    fi
}
function get_gnomeos() {
    local GnomeBase= ; GnomeBase="${RELEASE/%.*}" ; local GnomeFolder= ; local BaseUrl= ; local ISO=
    case $EDITION in
        release)    GnomeFolder="${GnomeBase}.0" ;;
        rc)         GnomeFolder="${GnomeBase}.rc" ;;
        beta)       GnomeFolder="${GnomeBase}.beta" ;;
        alpha)      GnomeFolder="${GnomeBase}.alpha" ;;
    esac
    BaseUrl="https://download.gnome.org/gnomeos/${GnomeFolder}"
    # each folder has the latest only, plus NO checksum eg. alpha.8.iso  Pick the list top just in case of changes. (REVIEW)
    ISO="$(web_pipe "$BaseUrl" | grep -s href | tr ' ' '\n' | grep title | head -n 1 | cut -d'"' -f2 )"
    echo "$BaseUrl/$ISO"
}

## FIX url and make dynamic (no hash available)
function releases_guix() {
    web_pipe "https://ftpmirror.gnu.org/gnu/guix" | grep -s -e 'system-install' | tr '<' '\n' | grep href | fv -M 2 -Q
}
function get_guix() {
    local ISO="guix-system-install-${RELEASE}.x86_64-linux.iso"
    local URL="https://ftpmirror.gnu.org/gnu/guix"
    echo "${URL}/${ISO}"
}

## FIX iso url
function get_kdeneon() {
    local HASH= ; local ISO= ; local URL= ; local NeonVer=
    URL="https://files.kde.org/neon/images/${RELEASE}/current"
    if [[ $RELEASE == "developer" ]]; then NeonVer="unstable-developer"; else NeonVer="$RELEASE"
    fi
    ISO="neon-${NeonVer}-current.iso"
    HASH=$(web_pipe "${URL}/neon-${NeonVer}-current.sha256sum" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## TWEAK  only 9 now ... REVIEW make dynamic?
function releases_mageia() {
    echo 9
}

## FIX sway
function get_manjaro() {
    local HASH="" ; local ISO="" ; local MANIFEST="" ; local URL="" ; local TYPE="official"
    MANIFEST="$(web_pipe https://gitlab.manjaro.org/web/iso-info/-/raw/master/file-info.json)"
    case "${RELEASE}" in
        sway) MANIFEST="$(web_pipe https://mirror.manjaro-sway.download/manjaro-sway/release.json)" ; TYPE="sway" ;;
        cinnamon|i3) TYPE="community";;
    esac
    if [ "${EDITION}" == "minimal" ] && [ "${TYPE}" != "sway" ]; then EDITION=".minimal"
    else EDITION=""
    fi
    if [ "${RELEASE}" == "sway" ]; then
        URL=$(echo "${MANIFEST}" | jq -r '.[] | select(.name|test("^manjaro-sway-.*[.]iso$")) | .url' | grep -v 'unstable')
    else
        URL="$(echo "${MANIFEST}" | jq -r ."${TYPE}.${RELEASE}${EDITION}".image)"
    fi
    HASH=$(web_pipe "${URL}.sha512" | cut -d' ' -f1)
    echo "${URL} ${HASH}"
}

## UPDATE to FIX release numbers varying with flavor
function releases_mxlinux() {
    echo latest
}
function editions_mxlinux() {
    echo Xfce KDE Fluxbox
}
function get_mxlinux() {
    local HASH= ; local URL= ; local ISO= ; local RELEASE=
    URL="https://sourceforge.net/projects/mx-linux/files/Final/${EDITION}"
    RELEASE="$(web_pipe "$URL" | tr '<' '\n' | grep -s href | grep "$RELEASE" | cut -d'=' -f2 | fv -Q -M)"
    # eg https://sourceforge.net/projects/mx-linux/files/Final/KDE/MX-23.6.1_KDE_x64.iso.sha256/download
    case ${EDITION} in
        Xfce) ISO="MX-${RELEASE}_x64.iso";;
        KDE) ISO="MX-${RELEASE}_KDE_x64.iso";;
        Fluxbox) ISO="MX-${RELEASE}_fluxbox_x64.iso";;
    esac
    HASH=$(web_pipe "${URL}/${ISO}.sha256" | cut -d' ' -f1)
    echo "${URL}/${ISO} ${HASH}"
}

## FIX and UPDATE to new folder styles and names
function releases_opensuse() {
    echo "leap leap-micro slowroll tumbleweed"
}
function editions_opensuse() {
    if [[ ! $RELEASE ]]; then echo "DVD Gnome KDE XFCE Rescue"
    elif [[ $RELEASE == "leap" ]]; then echo "Gnome KDE XFCE Rescue"
    elif [[ $RELEASE == "leap-micro" ]]; then echo current
    elif [[ $RELEASE == "slowroll" ]]; then echo DVD
    elif [[ $RELEASE == "tumbleweed" ]]; then echo "DVD Gnome KDE XFCE Rescue"
    fi
}
function get_opensuse() {
    local HASH="" ; local ISO="" ; local URL="" ; local SuseEdition=  ; local SuseRollPoint=
    case $EDITION in
        DVD)        SuseEdition="DVD" ;;
        Gnome)      SuseEdition="GNOME-Live" ;;
        KDE)        SuseEdition="KDE-Live" ;;
        XFCE)       SuseEdition="XFCE-Live" ;;
        Rescue)     SuseEdition="Rescue-CD" ;;
    esac
    if [ "${RELEASE}" == "tumbleweed" ]; then
        URL="https://download.opensuse.org/tumbleweed/iso"
        ISO="openSUSE-Tumbleweed-${SuseEdition}-x86_64-Current.iso"
    elif [ "${RELEASE}" == "leap" ]; then
        URL="https://download.opensuse.org/distribution/openSUSE-current/live"
        ISO="$(web_pipe "$URL" | tr '>' '\n' |  grep x86 | grep -e 'iso\"' | cut -d '"' -f 2 | cut -d '/' -f 2 | grep -v Build | grep -e "$SuseEdition"  )"
    elif [ "${RELEASE}" == "leap-micro" ]; then
        URL="https://download.opensuse.org/distribution/leap-micro-current/product/iso"
        ISO="$(web_pipe "$URL" | tr '>' '\n' | grep -i -s -e 'current\.iso' | grep x86 | grep -v mirror | grep href | cut -d '"' -f 2 | cut -d '/' -f 2 | grep -v sha256)"
    elif [ "${RELEASE}" == "slowroll" ]; then
        URL="https://download.opensuse.org/slowroll/iso"
        SuseRollPoint="$(web_pipe "$URL" | tr '<' '\n' | grep href | grep -s DVD | cut -d '"' -f 2 | cut -d '-' -f 5 | fv -M -Q)"
        ISO="$(web_pipe "$URL" | tr '<' '\n'| grep href | grep DVD | cut -d '"' -f 2 | grep -s -v -e 'iso\.' | grep -v -e 'x\.' | grep "$SuseRollPoint" | cut -d '/' -f 2)"
    fi
    HASH="$(web_pipe "$URL/${ISO}.sha256" | cut -d ' ' -f 1)"
    echo "$URL/${ISO} $HASH"
}

## FIX hashes and folders
function releases_parrotsec() {
  # July 2025 > only latest folder now has iso's
  Parrot_Latest="$(web_pipe "https://deb.parrot.sh/parrot/iso/" | grep -s href | fv -Q -M)"
  echo latest
}
function editions_parrotsec() {
    echo home htb security
}
function get_parrotsec() {
    local HASH="" ; local ISO="" ; local URL="" ; local LATEST="$Parrot_Latest"
    [[ ! $LATEST ]] && LATEST="$(web_pipe "https://deb.parrot.sh/parrot/iso/" | grep -s href | fv -Q -M)"
    ISO="Parrot-${EDITION}-${LATEST}_amd64.iso"
    URL="https://deb.parrot.sh/parrot/iso/${LATEST}"
    HASH="$(web_pipe "${URL}/signed-hashes.txt" | grep -s -A 30 'sha256' | grep -B 30 'sha384' | grep "${ISO}" | cut -d' ' -f1)"
    echo "${URL}/${ISO} ${HASH}"
}

## FIX  SLINT (only 15.0, and hopefully higher, has downloadable iso's)
function releases_slint() {
    web_pipe "https://slackware.uk/slint/x86_64/" | grep -e '<a href=' | fv -M -Q
}
function get_slint() {
    local HASH="" ; local MIN_VER= ; local URL=
    MIN_VER="$(web_pipe "https://slackware.uk/slint/x86_64/slint-$RELEASE/iso" | grep -e '<a href=' | grep -s -e 'iso\.sha' | fv -f -M -Q | tr -cd '[:graph:]')"
    local ISO="slint64-${MIN_VER}.iso"
    local URL="https://slackware.uk/slint/x86_64/slint-${RELEASE}/iso"
    HASH=$(web_pipe "${URL}/${ISO}.sha256" | cut -d' ' -f1)
    echo "${URL}/${ISO}" "${HASH}"
}

## UPDATE
function releases_sparkylinux() {
    printf "" > "/tmp/qGet.Mods.REL.data.txt" ; echo "Rolling Stable"
}
function editions_sparkylinux() {
    # May 2025 > listing task tends to exceed quickget's capabilities but July 2025 now allows Mods installer notes
    # Website subject to change, plus older specialist versions still being listed in addition to the newer ones
    if [[ ! $RELEASE ]]; then  echo "LXQt MATE Xfce KDE MinimalGUI MinimalCLI  MinimalGUI_32bit MinimalCLI_32bit"
    elif [[ $RELEASE == "Rolling" ]] ; then echo "LXQt MATE Xfce KDE MinimalGUI MinimalCLI"
    elif [[ $RELEASE == "Stable" ]] ; then echo "LXQt MATE Xfce KDE MinimalGUI MinimalCLI MinimalGUI_32bit MinimalCLI_32bit"
    fi
}
function get_sparkylinux() {
    local HASH="" ; local ISO="" ; local URL="" ; SparkyFolder= ; ReleaseNumber=
    # Stable    https://sourceforge.net/projects/sparkylinux/files/lxqt/sparkylinux-7.7-x86_64-lxqt.iso/download
    # Stable    https://sourceforge.net/projects/sparkylinux/files/base/sparkylinux-7.7-x86_64-minimalgui.iso/download
    # Rolling   https://sourceforge.net/projects/sparkylinux/files/lxqt/sparkylinux-2025.03-x86_64-lxqt.iso/download
    # Rolling   https://sourceforge.net/projects/sparkylinux/files/base/sparkylinux-2025.03-x86_64-minimalgui.iso/download
    # But not all roll at the same speed:
    # eg.       https://sourceforge.net/projects/sparkylinux/files/kde/sparkylinux-2024.12-x86_64-kde.iso/download
    EDITION="${EDITION,,}"
    case "$EDITION" in
        minimalcli*)    SparkyFolder="cli" ;;
        minimalgui*)    SparkyFolder="base" ;;
                  *)    SparkyFolder="$EDITION" ;;
    esac
    URL="https://sourceforge.net/projects/sparkylinux/files/${SparkyFolder}"
    if [[ $RELEASE == "Rolling" ]]; then ReleaseNumber="$(web_pipe "$URL" | tr '=' '\n' | grep source | cut -d'"' -f2 | grep -v "iso\." | tr -d '-' | fv -c -Q | grep 2'[[:digit:]]')"
    else ReleaseNumber="$(web_pipe "$URL" | tr '=' '\n' | grep source | cut -d'"' -f2 | grep -v "iso\." | tr -d '-' | fv -c -Q | grep -v 2'[[:digit:]]' | fv -Q -M)"
    fi
    if [[ "$EDITION" == *'32bit'* ]]; then EDITION="${EDITION/_32bit/}" ; ISO="sparkylinux-${ReleaseNumber}-i686-${EDITION}.iso"
    else ISO="sparkylinux-${ReleaseNumber}-x86_64-${EDITION}.iso"
    fi
    HASH="$(web_pipe "${URL}/${ISO}.allsums.txt" | head -n 2 | grep 'iso' | cut -d' ' -f1)"
    echo "${URL}/${ISO}" "${HASH}"
}

## TWEAK to avoid spamming on test_all
function releases_spirallinux() {
    Spiral_Latest="$(web_pipe "https://sourceforge.net/projects/spirallinux/files/" | grep -s 'class="name' | fv -M -Q)"
    echo latest
}
function editions_spirallinux() {
    echo Plasma XFCE Mate LXQt Gnome Budgie Cinnamon Builder
}
function get_spirallinux() {
    local HASH="" ; local LATEST="$Spiral_Latest"
    [[ ! $LATEST ]] &&  LATEST="$(web_pipe "https://sourceforge.net/projects/spirallinux/files/" | grep -s 'class="name' | fv -M -Q)"
    local ISO="SpiralLinux_${EDITION}_${LATEST}_x86-64.iso"
    local URL="https://sourceforge.net/projects/spirallinux/files/${LATEST}"
    HASH=$(web_pipe 'https://sourceforge.net/projects/spirallinux/rss?path=/' | grep "${ISO}" | grep 'md5' | cut -d'<' -f3 | cut -d'>' -f2)
    echo "${URL}/${ISO}" "${HASH}"
}

## IMPROVE make dynamic
function releases_truenas-scale() {
    web_pipe "https://www.truenas.com/download-truenas-community-edition/" | tr '<' '\n' | grep -s href | grep releasenotes |  grep wplink | cut -d'>' -f2 | fv -M -Q
}

## FIX invalid VOID folders (use 'current' only as some folders have variants)
function releases_void() {
    web_pipe "https://repo-default.voidlinux.org/live/current" | grep -e '<a href=' | grep x86 | grep 'base\.iso' | grep -v musl | cut -d'-' -f4 | tr -cd '[:graph:]'
 }
function get_void() {
    local HASH="" ; local ISO="" ; local URL="https://repo-default.voidlinux.org/live/$RELEASE"
    case ${EDITION} in
        glibc) ISO="void-live-x86_64-${RELEASE}-base.iso";;
        musl) ISO="void-live-x86_64-musl-${RELEASE}-base.iso";;
        xfce-glibc) ISO="void-live-x86_64-${RELEASE}-xfce.iso";;
        xfce-musl) ISO="void-live-x86_64-musl-${RELEASE}-xfce.iso";;
    esac
    HASH="$(web_pipe "${URL}/sha256sum.txt" | grep "${ISO}" | cut -d' ' -f4)"
    echo "${URL}/${ISO} ${HASH}"
}

##########################################

## 4: GUEST TYPE

# Needed only for special case instructions, such as non-iso
# Use for new qqX listed distros or for case overwrites
# Add in the format of "guest_type_${OS} ()"

##########################################

## 5: CONFIGURATION

# Needed only for special case instructions, such as needs legacy boot etc
# Use for new qqX listed distros or for case overwrites
# Add in the format of "config_${OS} ()"

##########################################

## 6: FINALIZING

# Needed only for special case instructions, such as decompression routines
# Use for new qqX listed distros or for case overwrites
# Add in the format of "finalize_${OS} ()"

##########################################

## 7: DOWNLOAD XL
# For special and oversized 'get' functions or "get_${OS} ()" overwrites, eg Windows or Mac
# Normally place 'get' functions next to releases and editions

##########################################

## OTHER FUNCTIONS
# The 'Mods' script gets read towards the end of the standard Quickget script via
# some lines added to the FreeSpirit branch. Any functions of the same name as in the original,
# here or above, will overwrite any of that name that have been previously declared.

# This particular section is more for qqX runtimes than Quickget itself. But you never know ...?
# A lot of these have already modded in the FreeSpirit branch but move here as they're NOW MUCH EASIER TO ADJUST

## TWEAK to make sure we wait for the check functions to return, as they might have to check the web.
function error_specify_release {
    show_os_info "${OS}"
    case ${OS} in
        *ubuntu-server*)
            echo -en " - Releases:\t"
            releases_ubuntu-server &
            wait "$!" ;;
        *ubuntu*)
            echo -en " - Releases:\t"
            releases_ubuntu &
            wait "$!" ;;
        *windows*)
            echo -en " - Releases:\t"
            "releases_${OS}" &
            wait "$!"
            echo -en " - Languages:\t"
            "languages_${OS}" &
            wait "$!"
            # shellcheck disable=SC2153
            echo "${I18NS[@]}" ;;
        *)
            echo -en " - Releases:\t"
            "releases_${OS}" | fmt -w 80 &
            wait "$!"
            if [[ $(type -t "editions_${OS}") == function ]]; then
                echo -en " - Editions:\t"
                "editions_${OS}" | fmt -w 80 &
                wait "$!"
            fi ;;
    esac
    echo -e "\nERROR! You must specify a release." ; exit 1
}

## TWEAK
# A lot of these have already modded in the FreeSpirit branch but move here as they're NOW MUCH EASIER TO ADJUST

# Download a SMALL file page, checksum etc from the web and pipe it to stdout  (not to confuse with 'web_get')
function web_pipe {
    local Args=("${@}") ; [[ ! "${Args[*]}" ]] && return 1
    if ! curl --disable -sLf --retry 8 --retry-max-time 4 --connect-timeout 4 --no-keepalive --max-time 30 "${Args[@]}"; then
        curl --disable -sLf --retry 6 --retry-max-time 6 --connect-timeout 6 --no-keepalive --max-time 30 "${Args[@]}"
    fi
}

# Download a JSON file from the web and pipe it to stdout
function web_pipe_json {
    local Args=("${@}") ; [[ ! "${Args[*]}" ]] && return 1
    if ! curl --disable -sLf --retry 8 --retry-max-time 4 --connect-timeout 4 --no-keepalive --max-time 30 --header "Accept: application/json" "${Args[@]}"; then
        curl --disable -sLf --retry 6 --retry-max-time 6 --connect-timeout 6 --no-keepalive --max-time 30 --header "Accept: application/json" "${Args[@]}"
    fi
}

## ADD
# Check the file headers. To be used for returns of 0 or 1 with pipe to log file,
function check_pipe {
    local Args=("${@}") ; [[ ! "${Args[*]}" ]] && return 1
    printf "" > "/tmp/qGet_check_pipe.txt"
    curl --disable -sLf --head --retry 16 --retry-max-time 2 --connect-timeout 2 --no-keepalive --location-trusted --max-time 30 "${Args[@]}" > "/tmp/qGet_check_pipe.txt"
    if ! grep -si 'HTTP/' "/tmp/qGet_check_pipe.txt" | tail -n 1 | grep -q 200; then
        printf "" > "/tmp/qGet_check_pipe.txt"
        curl --disable -sLf --head --retry 8 --retry-max-time 4 --connect-timeout 4 --no-keepalive --location-trusted --max-time 30 "${Args[@]}" > "/tmp/qGet_check_pipe.txt"
    fi
    if grep -si 'HTTP/' "/tmp/qGet_check_pipe.txt" | tail -n 1 | grep -q 200; then return 0 ; else return 1 ; fi
}
# where HTTP/ 200 = success (with size data etc as readable) and 404 = not found = fail
# --location-trusted means extend secure connection to the mirror or to the CDN otherwise 302 redirects will lose https.
# --no-keepalive/--keepalive-time as we don't need much, and so we then move on cleanly and can drop any cookies, if possible

## TWEAK
# Check if a URL needs to be redirected and returns the final URL mirror or CDN
function web_redirect() {
    local REDIRECT_URL="" ; local URL="${1}"
    REDIRECT_URL=$(curl --disable -sLf --connect-timeout 4 --no-keepalive --location-trusted --max-time 6 --write-out '%{url_effective}' -o "/dev/null" "${URL}" | tr -cd '[:print:]')
    [[ ! $REDIRECT_URL ]] && REDIRECT_URL=$(curl --disable -sLf --connect-timeout 4 --keepalive-time 1 --location-trusted --max-time 8 --write-out '%{url_effective}' -o "/dev/null" "${URL}" | tr -cd '[:print:]')
    if [[ $REDIRECT_URL ]] && [[ $REDIRECT_URL != "${URL}" ]]; then echo "${REDIRECT_URL}"
    else echo "${URL}"
    fi
}

## TWEAK
# Download a file from the web, to storage
function web_get() {
    local CHECK="" ; local HEADERS=() ; local URL="${1}" ; local DIR="${2}" ; local FILE=""
    local USER_AGENT="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"
    if [ -n "${3}" ]; then FILE="${3}"
    else FILE="${URL##*/}"
    fi
    # Process any URL redirections after the file name has been extracted
    URL=$(web_redirect "${URL}")
    # Process any headers
    while (( "$#" )); do
        if [ "${1}" == "--header" ]; then HEADERS+=("${1}" "${2}") ; shift 2
        else shift
        fi
    done
    # Test mode for ISO
    if [ "${OPERATION}" == "show" ]; then
        test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}"
        exit 0
    elif [ "${OPERATION}" == "test" ]; then
        # CAUTION with current QuickGet, $RELEASE and $EDITION may be generated already.
        # Current behaviour is that QuickGet will route distros with editions through web_GET.
        # Others, such as Macos, have their own special routines.
        # Those without, go through web_CHECK.
        # CARE is also needed so that distro checks don't trigger background downloads.
        # The QuickGet VARIANT CONVOLUTIONS can have lots of twists and turns ....
        if [[ "$OS" != *ubuntu* ]]; then
            local HASH= ; local GetLine= ; GetLine=$(get_"${OS}" "$RELEASE" "$EDITION")
            # 'get_$OS' should output two args; a filepath URL, followed a checksum number
            #  but additionally add mirror URL, if available or possible, to check the state of the mirror service,
            #  noting that mirrors can block in the time gap between the location of a mirror URL and testing it.
            printf "%s" "$GetLine" > "/tmp/qGet-test-all-GetLine.txt"
            # Leave as mirror URL, if available from above, if Check Mirrors requested. Otherwise reset.
            [[ ! $CheckMirrors ]] && URL=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $1}')
            HASH=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $2}')
            [[ "$HASH" == *'://'* ]] && HASH=
        fi
        CHECK=$(web_check "${URL}" && echo "PASS" || echo "FAIL")
        printf "Using webget > %s %s" "$CHECK" "$URL" > "/tmp/qGet_webget_report.txt"
        test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}" "${CHECK}" "$HASH"
        exit 0
    elif [ "${OPERATION}" == "download" ]; then
        DIR="$(pwd)"
    fi

    if [ "${DIR}" != "$(pwd)" ] && ! mkdir -p "${DIR}" 2>/dev/null; then
        echo "ERROR! Unable to create directory ${DIR}"
        exit 1
    fi
    #  Allow qqX or any external process to pick up the FINALIZED NAME
    # - avoids overwrites eg windows 'unattended'
    # - external proc should clear this file before starting so the grep test will function
    if ! grep -sq 'New_VM_InstanceName' "/tmp/qe_new_vm_name.txt" ; then
        printf "New_VM_InstanceName=\"%s\" \n" "$(basename "$DIR")" > "/tmp/qe_new_vm_name.txt"
    fi
    if [[ ${OS} != windows && ${OS} != macos && ${OS} != windows-server ]]; then
        echo "Downloading $(pretty_name "${OS}") ${RELEASE} ${EDITION}"
        echo "- URL: ${URL}"
    fi
    # Add retries to the standard Quickemu 4.9.x method:
    # --continue-at -  will continue/resume a previous file transfer but we need to make sure we actually have a connection to start with ...
    if ! curl --disable -Lf --retry 6 --retry-max-time 3 --retry-delay 1 --progress-bar --continue-at - --output "${DIR}/${FILE}" \
    --user-agent "${USER_AGENT}" "${HEADERS[@]}" -- "${URL}"; then
        # qqX needs to take control here, use exit instead
        if pgrep qqX >/dev/null ; then echo ; exit
        else
            echo "ERROR! Failed to download ${URL} with curl." ; rm -f "${DIR}/${FILE}"
        fi
    fi
}


## TWEAK
function web_check {
    local HEADERS=() ; local URL="${1}"
    # Normally just a URL. Mac OS has URL as $1 then followed by repeated headers requests.
    while (( "$#" )); do
        if [ "${1}" == "--header" ]; then HEADERS+=("${1}" "${2}") ; shift 2
        else shift
        fi
    done
    # check is standard *.* filename or Ubuntu SUMS file, not an html web page or such ...
    printf "%s" "$URL" > "/tmp/qmod-dl-url"
    if [[ ! $URL ]]; then return 1
    else [[ "$(basename "$URL")" != *.* ]] && [[ "$(basename "$URL")" != *SUMS* ]] && return 1
    fi
    # returns 0 or 1, plus check_pipe outputs header to log file "/tmp/qGet_check_pipe.txt"
    if check_pipe "${HEADERS[@]}" "${URL}" ; then return 0 ; else return 1 ; fi
}

## ADD HASH CHECK
# Checks if 'get_$OS' is outputting a checksum and, if so, that it is correctly formatted
function test_result {
    local OS="${1}" ; local RELEASE="${2}"
    if [[ "$3" == *'://'* ]]; then
        local URL="${3}" ; local RESULT="${4}" ; local HASH="${5}" ; local HashTest= ; local HashLength="0"
    else
        local EDITION="${3}" ; local URL="${4}" ; local RESULT="${5}" ; local HASH="${6}" ; local HashTest= ; local HashLength="0"
    fi
    if [[ $EDITION ]]; then OS="${OS}-${RELEASE}-${EDITION}"
    else OS="${OS}-${RELEASE}"
    fi
    HASH="$(tr -cd '[:graph:]' <<< "$HASH")" ; [[ $HASH ]] && HashLength="${#HASH}"
    case $HashLength in
        32|40|64|128) HashTest="PASS" ;;
        0) HashTest="n/a" ;;
        *) HashTest="FAIL" ;;
    esac
    local OsShort="${OS:0:30}"
    if [[ $QuietOps ]]; then {
        if [[ "${RESULT}" ]]; then printf "Checksum: %-4s   Iso: %s   %-30s  %s  %s \n" "$HashTest" "${RESULT}" "${OsShort}" "${URL}" "$HASH"
        else printf "%-30s %s\n" "${OsShort}" "${URL}"
        fi } >> "/tmp/qGet_QuietResult.txt"
    elif [[ $CompactOps ]]; then {
        if [[ "${RESULT}" ]]; then printf "Checksum: %-4s   Iso: %s   %-40s\n" "$HashTest" "${RESULT}" "${OS}"
        else printf "%-40s %s\n" "${OS}" "${URL}"
        fi } | tee -a "/tmp/qGet_CompactResult.txt"
    else {
        if [[ "${RESULT}" ]]; then printf "Checksum: %-4s   Iso: %s   %-30s  %s  %s \n" "$HashTest" "${RESULT}" "${OsShort}" "${URL}" "$HASH"
        else printf "%-30s %s\n" "${OsShort}" "${URL}"
        fi } | tee -a "/tmp/qGet_FullResult.txt"
    fi
}

function test_all {
    OS="${1}"
    os_supported
    local CHECK="" ; local FUNC="${OS}" ; local GetLine="" ; local URL="" ; local HASH="" ; local EDITION= ; local RELEASE=
    [[ "${OS}" == *ubuntu* ]] && [[ "${OS}" != "ubuntu-server" ]] &&  FUNC="ubuntu"
    for RELEASE in $("releases_${FUNC}"); do
        if [[ $(type -t "editions_${OS}") == function ]]; then
            for EDITION in $(editions_"${OS}"); do
                GetLine=$(get_"${OS}" "$RELEASE")
                # 'get_$OS' should output two args; a filepath URL, followed a checksum number
                #  but additionally add mirror URL, if available or possible, to check the state of the mirror service,
                #  noting that mirrors can block in the time gap between the location of a mirror URL and testing it.
                printf "%s" "$GetLine" > "/tmp/qGet-test-all-GetLine.txt"
                URL=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $1}')
                [[ $CheckMirrors ]] &&  URL=$(web_redirect "${URL}")
                HASH=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $2}')
                if [ "${OPERATION}" == "show" ]; then
                    test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}"
                elif [ "${OPERATION}" == "test" ]; then
                    CHECK=$(web_check "${URL}" && echo "PASS" || echo "FAIL")
                    test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}" "${CHECK}" "$HASH"
                fi
            done
        elif [[ "${OS}" == "windows"* ]]; then
            # Caution with current Quickemu, --check windows with $2 (or/and $3) will trigger a windows download
            "languages_${OS}"
            for I18N in "${I18NS[@]}"; do
                if [ "${OPERATION}" == "show" ]; then
                    test_result "${OS}" "${RELEASE}" "${I18N}" ""
                elif [ "${OPERATION}" == "test" ]; then
                    test_result "${OS}" "${RELEASE}" "${I18N}" "${URL}" "SKIP"
                fi
            done
            # Caution here, the get_$OS routines must run in subshells in order to loop properly
        elif [[ "${OS}" == "macos" ]]; then
            (get_macos)
        elif [ "${OS}" == "ubuntu-server" ]; then
            (get_ubuntu-server)
        elif [[ "${OS}" == *ubuntu* ]]; then
            (get_ubuntu)
        else
            URL=$(get_"${OS}" | cut -d' ' -f1 | head -n 1)
            if [ "${OPERATION}" == "show" ]; then
                test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}"
            elif [ "${OPERATION}" == "test" ]; then
                GetLine=$(get_"${OS}" "$RELEASE")
                printf "%s" "$GetLine" > "/tmp/qGet-test-all-GetLine.txt"
                URL=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $1}')
                [[ $CheckMirrors ]] &&  URL=$(web_redirect "${URL}")
                HASH=$(tr -cd '[:print:]' <<< "$GetLine" | awk '{print $2}')
                CHECK=$(web_check "${URL}" && echo "PASS" || echo "FAIL")
                test_result "${OS}" "${RELEASE}" "${EDITION}" "${URL}" "${CHECK}" "$HASH"
            fi
        fi
    done
    [[ $QuietOps ]] && printf "Log file: \"/tmp/qGet_QuietResult.txt\" \n"
    [[ $CompactOps ]] && printf "Log file: \"/tmp/qGet_CompactResult.txt\" \n"
    [[ $FullCheckOps ]] && printf "Log file: \"/tmp/qGet_FullResult.txt\" \n"
}

##########################################

## QUICKGET COMMANDS
# The 'Mods' script gets read towards the end of the standard Quickget script via lines added to the FreeSpirit branch.
# Case mods will either clear any listed args and set flags early, or will run something and exit here,
# effectively being able to bypass selected original Quickget case statements, or add new ones ...

QuietOps= ; CompactOps= ; FullCheckOps= ; CheckMirrors=
printf "Webget NOT used\n" > "/tmp/qGet_webget_report.txt"

case "${1}" in
    --mirrors)
        CheckMirrors=1 ; shift
    ;;
    --full-check|--check|-check)
        OPERATION="test" ; shift
        [[ $1 == "--mirrors" ]] && CheckMirrors=1 && shift
        FullCheckOps=1 && printf "" > "/tmp/qGet_FullResult.txt"
        if [[ ! $1 ]]; then
            for OS in $(os_support); do test_all "${OS}"
            done
            exit 0
        elif [[ ! $2 ]]; then
            test_all "${1}"
            exit 0
        fi ;;
    --quiet-check|--compact-check)
        [[ $1 == "--quiet-check" ]] &&  QuietOps=1 && printf "" > "/tmp/qGet_QuietResult.txt"
        [[ $1 == "--compact-check" ]] &&  CompactOps=1  && printf "" > "/tmp/qGet_CompactResult.txt"
        OPERATION="test" ; shift
        [[ $1 == "--mirrors" ]] && CheckMirrors=1 && shift
        if [[ ! $1 ]]; then
            for OS in $(os_support); do test_all "${OS}"
            done
            exit 0
        elif [[ ! $2 ]]; then
            test_all "${1}"
            exit 0
        fi ;;
    --help|-help|--h|-h)
        help_message
        printf "\n\nExtra qqX commands: \n\nfrom a terminal opened in a qqX 'built-in' folder"
        printf "\n\n----------------------------- ./quickget -------------------------------"
        printf "\n\n  --full-check      [os] [release] [edition] : Full Hash/Iso to StdOut, plus log to file \"/tmp/qGet_FullResult.txt\""
        printf "\n\n  --compact-check   [os] [release] [edition] : Short line StdOut, plus log to file \"/tmp/qGet_CompactResult.txt\""
        printf "\n\n  --quiet-check     [os] [release] [edition] : Only log check image URL(s) to file \"/tmp/qGet_QuietResult.txt\""
        printf "\n\n  --mirrors         Add-on for the above tests, to show info on possible mirror services. Omit for more generalized testing."
        printf "\n\n  Without a specified 'OS' will run a complete 'test_all' whilst with 'OS' will test all releases and editions of that specified."
        printf "\n\n  Lastly, 2 or 3 part final descriptor checks will route through 'web_get' and will output plain results, without a log filename reminder."
        printf "\n\n----------------------------------------------------------------------------------\n\n"
        exit 0 ;;
esac

##########################################

## CODING STYLE  (as listed at the end of the main 'qqX' script)

#  A more MODERN BASH style of coding is used for qqX than that used for QuickEmu.

#  NOT TO WORRY if you are only familiar the older more POSIX styles, there are still plenty of options
#  for contributions to the quickemu built-ins, particularly with QuickGet which needs frequent updating.

#  VARIABLES should normally tend towards 'CamelCase' & FUNCTIONS should tend towards 'snake_case'.
#  Aim for clarity and contextual identity. Emphasis or separation underscoring & caps should be added where needed.

#  Modern editors, such as VS Code or Sublime have auto-suggesting which enables LongerMoreHelpfulVariableNames.

#  Also SHELLCHECK will NOT continuity follow all-caps variables either, even if SC2154 is enabled ...
#  https://en.wikipedia.org/wiki/Camel_case   https://en.wikipedia.org/wiki/Snake_case

#  Variables {don't} need to be braced unless using string manipulations or needing to stop vars from merging with other text.
#  Some of QuickEmu's variables can be very ambiguous eg. '$VERSION' but in some places have to be used.
#  Except for the .conf file, where they are lowercase, they are generally CAPS and very brief ...

#  BRACKETS:  if [[ $Foo ]] && [[ ! $Bar ]] ...   Posix Style is not needed:  if [ -n ${FOO} ] && [ -z ${bar} ] ....

#  The [[ double bracket ]] system is NOW the STANDARD METHOD in the Bash Manual.
#  See  https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-_005b_005b
#  Plus https://ss64.com/bash/test.html  And (older article) http://mywiki.wooledge.org/BashFAQ/031

#  Double bracket one-liners may be new to some people.
#  These statements are all the same:

FooVar=

if [ -n "${FooVar}" ]; then
    echo
    echo "  Hello "
    echo
fi

if [[ $FooVar ]]; then
    printf "\n\n  Hello \n\n"
fi

[[ $FooVar ]] && printf "\n\n  Hello \n\n"

#  COMMENTS: Add clarification or explanation to code, especially if the origin or meaning could be difficult to follow.

#  Add links to any how-to's that you used.  If you needed to check, then others may do also.
#  Let others follow what you are/were thinking at the time & give Bash beginners a chance too.
#  It makes it easier for everyone, especially later on.

#  SPACE:  Give your code some room to breathe. But also keep your code tight enough to view on smaller screens.
#  Place it into clear logic blocks. Make it easy to follow & easy to see what is happening.

#  SED, AWK and REGEX:  Commands can very easily finish up as lines of indecipherable hieroglyphics.
#  If you must use them, keep things very simple & explain the sections.
#  Where possible use Bash's string manipulations instead.   See: http://mywiki.wooledge.org/BashFAQ/100

#  ECHO: Beyond basic one-liners, the use of printf should generally be preferred.  See https://ss64.com/bash/printf.html
#  However & specifically, echo within the vm boot control section of the qqX script *must* be avoided
#  as an echo trap is used to tee quickemu screen output to the qqX boot log.

#  All code should be SHELLCHECK linted & disables avoided where possible.
#  The VS Code shellcheck extension works well if set to 'check-on-save'.


# https://code.visualstudio.com/  (recommended)
# vim:tabstop=4:shiftwidth=4:expandtab