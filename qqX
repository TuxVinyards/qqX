#!/bin/bash 

# NB Avoid use of "#!/usr/bin/env bash" in this script as it will mask process names & inhibit process controls.

# See notes in the Setup & Install script 


##  Copyright (c)  Alex Genovese   https://github.com/TuxVinyards

#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED  
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.

# 	Otherwise:  

# Licence  GPL3   https://www.gnu.org/licenses 

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# https://www.gnu.org/licenses 


# IF CODE IN GENERAL BECOMES USED IN ANY OTHER PROJECT,

# THE GPL3 LICENCE APPLIES & YOU SHOULD SHOW CLEAR ATTRIBUTIONS. 


##  A text menu interface for the 'quickemu' project  https://github.com/quickemu-project/quickemu  

#   Users should install 'quickemu' and may set up Virtual Machines as normal.

#  Originally part of quickemu-mod suite of scripts. 
#  @2023/10  qmod/qwrap probably to be phased out & focus only on qqX

#  @2023/08 this script forms the base for qqX - quickemu quickget X terminal project  
#  qqX may be installed alongside quickemu in /usr/bin  & run by typing either qqX or qqx. Or by mouse

#  @2023/08  Work on quickemu-wrap is now being frozen but this script attempts to maintain backward compatibility
#  during the initial qqX release.  In theory it may second install as qwrap. YMMV

#  Concurrent qwrap & qqX will have different settings files which may or may not be advantageous.  
#  See:  https://github.com/TuxVinyards/qqX  &  https://github.com/TuxVinyards/quickemu-mod

#  Also see https://gitlab.com/qemu-project/qemu


## ShellCheck global disables:

# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC2024, SC154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242
#  shellcheck disable=SC1090 
#  shellcheck disable=SC2034
#  shellcheck disable=SC2154 


##  Expect Bash 5.0+   (2023: we are now at ver 5 for quite a few years)  
if [ -z "$(type -p bash)" ] || ((BASH_VERSINFO[0] < 5)); then
  echo; echo "  Sorry, you need bash 5.0 or newer to run this script."; echo
  echo "  Your version: "; echo
  bash --version
  echo; sleep 10; exit 1
fi

#  This may upset some input/output filters ....    CAUTION   (see notes in the main settings) 

AllowMoreLocale=


##  Dev: set =1 to stop screen clears (and pause 1 sec), for easier fault tracing
#   Set =integer for add longer pauses, "0.2" etc for less.

NoClear=


# This script:

ModVersion="1.6.01"

# major.minor.point[.dev-point]  x.x.2dp[.2dp]  where x = any whole number and the last register always being 2dp.

# The 2nd register becomes printf'ed to 2dp for upgrade valuation
# while a single 0 in the third register indicates beta  [with fourth register at 2dp]


ModName="$(basename "$0")"

if [[ $ModName == "qqx" || $ModName == "qqX" ]]; then ModName_qqX=1 ; else  ModName_qqX=  ; fi


 
##  CODING STYLE 

#  Although qqX wraps quickemu, the quickemu-project's 'style' should not be followed.

#  All code should be SHELLCHECK linted & disables avoided where possible.  
#  The VS Code shellcheck extension is recommended.  It works well if set to 'check-on-save'.


#  VARIABLES & FUNCTIONS should aim for clarity and contextual identity.  Variables should normally tend towards 'CamelCase'  
#  & functions should tend towards 'snake_case'.  Emphasis or separation underscoring & caps should be added where needed.

#  https://en.wikipedia.org/wiki/Camel_case   https://en.wikipedia.org/wiki/Snake_case

#  Variables {don't} need to be braced unless using string manipulations or needing to stop vars from merging with other text. 
#  Modern editors, such as VS Code or Sublime have auto-suggesting which enables longer & more helpful VariableNames.

#  In some places ** quickemu's given variable names ** have to be used. These are generally CAPS and very brief, eg '$QEMU'.
#  Except when working with the .conf file, where quickemu chooses to use lowercase.
#  Care should be taken not to confuse them with Bash's BUILT_IN vars, or to confuse their scope, 
#  eg. the ambiguous quickemu var '$VERSION'

#  Likewise care must be taken not to confuse lowercase vars with standard application commands, 
#  especially in non-highlighting editors. 

#  Note that Shellcheck will not continuity follow all caps variables. https://www.shellcheck.net/wiki/SC2154


#  BRACKETS: The more powerful [[ double bracket ]] system that was introduced in Bash 3.2 
#  is now the standard method recommended in the Bash Manual.
#  See https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-_005b_005b  
#  See https://github.com/bminor/bash/blob/master/COMPAT item 32

#  Use: if [[ $Foo ]] && [[ ! $Bar ]] ...    Avoid:   if [ -n ${FOO} ] && [ -z ${bar} ] ....

#  Further notes:  https://ss64.com/bash/test.html  And (older article) http://mywiki.wooledge.org/BashFAQ/031 


#  COMMENTS: Add clarification or explanation to code, especially if the origin or meaning could be difficult to follow.
#  Also add links to any how-to's that you used.  If you needed to check, then others may do also. 
#  Let others follow what you are/were thinking at the time & give Bash beginners a chance too.
#  It makes it easier for everyone, especially later on.

#  SPACE:  Give your code some room to breathe.  Break it up into logic blocks.  
#  Make it easy to follow & easy to see what is happening.  

#  SED & AWK:  Commands can very easily finish up as lines of indecipherable hieroglyphics.
#  If you must use them, keep things very simple & explain the sections.  
#  Where possible use Bash's string manipulations instead.   See: http://mywiki.wooledge.org/BashFAQ/100

#  ECHO: Beyond basic one-liners, the use of printf should generally be preferred.  See https://ss64.com/bash/printf.html
#  However & specifically, echo within the main section of the actual qqX script *must* be avoided
#  as an echo trap is used to tee quickemu screen output to the qqX boot log.   



## MAIN CODE  

# Find where the main code is. Use local for Dev or Custom installs. Otherwise use FHS standard locations.

qqX_MainFolder="/usr/share/qqX/qqX.main"

[[ -d "./qqX.main" ]] &&  qqX_MainFolder="$(realpath "./qqX.main")"

if [[ ! -d "$qqX_MainFolder" ]]; then 

  echo; echo "  ERROR: qqX main files not found.  Please re-check your installation."; echo; sleep 10; exit 1

fi


## INITIALIZE

# Declare global associative VM ARRAY & other initializing global vars. Make ready to read settings.
declare -gA VM_Array=()
declare -ga Extra_VM_Folder=()
declare -ga QemuError_VM_Filter=()

# Clear or set any default variables, if needed.
VM_ExecBoot=
Extra_QE_Params=
VM_Select_ItemsPerLine="4"

# Set .conf settings record from any previous session but not normally clear it until multi-instance issues have been approved
ConfClearanceLog="/tmp/qqX_ConfClearance_Log.txt"
[[ ! -e "$ConfClearanceLog" ]] && printf "" > "$ConfClearanceLog"


# LOAD qqX main  

source "$qqX_MainFolder/qqX_Initialize"

source "$qqX_MainFolder/qqX_read_main_settings"

source "$qqX_MainFolder/qqX_UI_chrome_up"

source "$qqX_MainFolder/qqX_MSR_functions"

source "$qqX_MainFolder/qqX_wrap_quickemu"

source "$qqX_MainFolder/qqX_quick_reroute_emu"

source "$qqX_MainFolder/qqX_quick_reroute_get"

source "$qqX_MainFolder/qqX_configuration_items"

source "$qqX_MainFolder/qqX_VM_array_and_Select"

source "$qqX_MainFolder/qqX_disk_maintenance"




function_KillPID_Menu() {

  tput civis

	# WAIT for background load & QEMU messages to appear before showing menu (unless reloading)

	if [[ $KillPID_Menu_Exited ]]; then  KillPID_Menu_Exited=

  elif [[ $BreakAtVerboseArgs ]]; then BreakAtVerboseArgs= ; return

  else  sleep 2 
  
  fi
  
  # Qemu SHOULD write a .pid file while it is running & remove it when not  (Uses quickemu Var Names)

  InstancePID="$(cat "${VMDIR}/${VMNAME}.pid" 2> /dev/null)"


  if [[ $InstancePID ]]; then 

    SpicyPID=

    sleep  "$P_Kill_WaitSecs"   

    printColor "\n  Quickemu instance %s on PID:  %s  %s"  "$VM_InstanceName"  "$InstancePID"  "$BootAlert"

    printColor  "   [k] force close the Quickemu instance   "
    
    SpicyPID="$(pgrep spicy)"

    if [[ $SpicyPID ]]; then 

      #  REVIEW   if possible, add SDL reconnect 

      SpicyReStartCmd="$(ps --no-headers -o cmd "$SpicyPID")"
    
      printColor " [r] reload Spicy window (if closed)"

    fi

    printf "\n\n"
    tput cnorm

  fi

  # return to menu requires VM to be shutdown first

  while true ; do 

    read -rp  "  >  " -t 1  KillPID_Menu

    if [[ $KillPID_Menu == "k" ]]; then 

      printf "\n\n"
      if [[ $( ps -p "$InstancePID" --no-headers ) ]]; then
        [[ $SpicyPID ]] && kill "$SpicyPID" 2>/dev/null &
        kill "$InstancePID" 2>/dev/null &
      fi

      sleep 3
      printf "\n\n"

      tput cnorm
      break

    elif [[ $KillPID_Menu == "r" ]]; then 

      if [[ ! $(pgrep spicy) ]]; then 
        eval "$SpicyReStartCmd"
        sleep 2
        SpicyPID="$(pgrep spicy)"
      fi

    else

      if [[ ! $( ps -p "$InstancePID" --no-headers ) ]]; then 
      
        tput cnorm 
        break 

      else

        #  Erase text and adjust cursor:   "\e[1A\r"  "\e[2K\r"  etc    See https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797
       
        printf "\r"

      fi

    fi

  done

  KillPID_Menu=

  KillPID_Menu_Exited=1

  P_Kill_WaitSecs="$P_Kill_WaitSecs_PreSet"

  refresh_and_load_quickemu_vars
  refresh_conf_vars_and_values

}	



function_delete_Selected_VM () {

  if [[ ! $1 && ! $2 ]]; then

    # Normally: VM_InstanceName="${VM_Conf_File/.conf}"

    printColor "\n\n  Internal Params: VM Name & VM config file (NO PATH) must be given \n\n " 

    sleep 2 ;  return

  else

    if [[ ! -d "$1" ]] || [[ ! -e "$2" ]]; then

      printColor "\n\n  Internal Params: VM Name & VM config file (NO PATH) must be given \n\n " 

      printColor "\n\n  Internal Params: VM Name / VM config file  NOT FOUND  \n\n " 

      sleep 2 ;  return

    fi

    if [[ $(type -p gio 2>/dev/null) ]]; then TrashingAvailable=1 ; else TrashingAvailable= ; fi

    printColor "\n\n  Folder: %s " "$1"
  
    printColor "  & file: %s  to be deleted?"  "$2"
  
    printf  "\n\n  To delete a VM, removal of the above folder/file is sufficient."

    printf "\n\n  Select [n] to manually delete, & to possibly retain individual files, using a file manager."

    printf "\n\n  Folder content: \n\n"

    ls "$1"

    if [[ $TrashingAvailable ]]; then 

      printColor "\n\n  [enter] safely move the folder & file to the recoverable trash bin"  
      
      printf "\n\n  [n] keep   [y] yes, PERMANENTLY, I have back-ups ..."

    else

      printColor "\n\n  [enter] use the file manager to move things the trash bin "
      
      printf "\n\n  [y] yes, PERMANENTLY, I have back-ups ..."

    fi

    printf "\n\n"

    read -rp "  >  "   Delete_VM_Option

    if [[ $Delete_VM_Option == "y" ]]; then 

      printf "\n\n  Folder & .conf file being deleted ... \n\n"
      
      rm -f -r "$1"  
      echo

      rm -f "$2"
      echo

    else

      # https://specifications.freedesktop.org/trash-spec/trashspec-latest.html

      if [[ $TrashingAvailable ]] && [[ $Delete_VM_Option != "n" ]]; then

        printf "\n\n  Moving files to the bin ... \n\n"
        gio trash "$1"
        gio trash "$2"

      else  printf "\n\n  NOT deleted ... \n\n"

      fi

    fi

    sleep 1.4

    printColor "\n\n  [enter] to return or continue \n\n" 
    read -rp "  > "

    VM_InstanceName="$VM_InstanceName"" - Deleted >> ReSelect"

    SettingsFileAdjusted=1

    refresh_sources_and_reload_VM_arrays

  fi

}




# As check_for_qqX_updates runs in the background, the variables need transfering to the foreground

qqX_LatestRelease=

qqX_LatestTarBall=

qqX_UpdateAvail=

qqX_Upd_VarsTmpFile="/tmp/qqX.upd.chk.txt"

echo > "$qqX_Upd_VarsTmpFile"


check_for_qqX_updates() {

  # Quietly do a check for new releases 

  wget -q -T2 -t2 -O "/tmp/latest-qqX"  "https://api.github.com/repos/TuxVinyards/qqX/releases/latest" 

  qqX_LatestRelease="$(grep -s tag_name "/tmp/latest-qqX" )"

  
  if [[ $qqX_LatestRelease ]]; then

    # should normally be the case, if internet connection is up
    qqX_LatestRelease="${qqX_LatestRelease/'"tag_name": "'/}"
    qqX_LatestRelease="${qqX_LatestRelease//'",'/}"
    qqX_LatestRelease="$(tr -cd '[:graph:]' <<< "$qqX_LatestRelease")"

    # std downloads: 
    # eg "tarball_url": "https://api.github.com/repos/TuxVinyards/qqX/tarball/0.09.00.016",
    qqX_LatestTarBall="$(grep -s tarball "/tmp/latest-qqX" )"
    qqX_LatestTarBall="${qqX_LatestTarBall/'"tarball_url": "'/}"
    qqX_LatestTarBall="${qqX_LatestTarBall//'",'/}"
    qqX_LatestTarBall="$(tr -cd '[:graph:]' <<< "$qqX_LatestTarBall")"

    # assets: 
    # eg "browser_download_url": "https://github.com/TuxVinyards/qqX/releases/download/0.09.00.016/qqX-0.09.00.016.tar.gz"
    # &  "browser_download_url": "https://github.com/TuxVinyards/qqX/releases/download/0.09.00.016/qqX-0.09.00.016.tar.gz.sha256"

    qqX_Latest_Secure_TarTest="https://github.com/TuxVinyards/qqX/releases/download/$qqX_LatestRelease/qqX-$qqX_LatestRelease.tar.gz"

    if [[ "$(grep -s -c "$qqX_Latest_Secure_TarTest" "/tmp/latest-qqX")" == "2" ]] ; then

      qqX_Latest_Secure_TarBall="$qqX_Latest_Secure_TarTest"
      qqX_Latest_Secure_TarSha="https://github.com/TuxVinyards/qqX/releases/download/$qqX_LatestRelease/qqX-$qqX_LatestRelease.tar.gz.sha256"
           
    fi


    IFS='.' read -ra qqX_LatestVer_Arr <<< "$qqX_LatestRelease"

    # Current Version is carried out at the start, in similar way

    # qqX_LatestVer_Arr[0] remains unpadded  (& to the left of the decimal point)

    [[ ${#qqX_LatestVer_Arr[1]} -lt 2 ]] && printf -v qqX_LatestVer_Arr[1] "%.2d" "${qqX_LatestVer_Arr[1]}"
    [[ ${#qqX_LatestVer_Arr[2]} -lt 2 ]] && printf -v qqX_LatestVer_Arr[2] "%.2d" "${qqX_LatestVer_Arr[2]}"

    #legacy 3dp pre "0.09.00.017"

    [[ ${#qqX_LatestVer_Arr[3]} -gt 2 ]] && qqX_LatestVer_Arr[3]="${qqX_LatestVer_Arr[3]:(-2)}"
    [[ ${#qqX_LatestVer_Arr[3]} -lt 2 ]] && printf -v qqX_LatestVer_Arr[3] "%.2d" "${qqX_LatestVer_Arr[3]}"

    qqX_LatestVer_Float="${qqX_LatestVer_Arr[0]}.${qqX_LatestVer_Arr[1]}${qqX_LatestVer_Arr[2]}${qqX_LatestVer_Arr[3]}"

    #  Flag up release type.  Also used in qqX general title to show if using beta or release.

    if [[ "${qqX_LatestVer_Arr[3]}" ]] && [[ "${qqX_LatestVer_Arr[2]}" == "00" ]]; then  qqX_LatestReleaseType="beta"

    else qqX_LatestReleaseType="release"
    
    fi

    #  If current ver is beta OR if beta notifications are requested in the general settings:
    [[ $qqX_CurrentReleaseType == "beta" ]] && Hide_qqX_BetaUpdates=

    #  Also flag up about beta notifications if transitioning from beta to release:
    [[ $qqX_CurrentReleaseType == "beta" ]] && [[ $qqX_LatestReleaseType == "release" ]] && BetaTxReleasePoint=1

    # Set up TRANSFER FILE for all needed variables,  as check runs in background ...  NB 

    if [[ ! $Hide_qqX_BetaUpdates && $qqX_LatestReleaseType == "beta" ]] || [[ $qqX_LatestReleaseType == "release" ]]; then
   
      if [[ $(bc <<< "$qqX_LatestVer_Float > $qqX_CurrentVer_Float" 2>/dev/null) == "1" ]]; then 

        { printf "\n\n qqX_UpdateAvail=\"1\""   
        
          printf "\n\n qqX_LatestRelease=\"%s\""  "$qqX_LatestRelease" 

          printf "\n\n qqX_LatestTarBall=\"%s\""  "$qqX_LatestTarBall" 
        
          printf "\n\n qqX_Latest_Secure_TarBall=\"%s\""  "$qqX_Latest_Secure_TarBall" 
        
          printf "\n\n qqX_Latest_Secure_TarSha=\"%s\""  "$qqX_Latest_Secure_TarSha" 

          printf "\n\n qqX_LatestReleaseType=\"%s\""  "$qqX_LatestReleaseType" 

          printf "\n\n qqX_LatestVer_Float=\"%s\""  "$qqX_LatestVer_Float" 
        
        } >> "$qqX_Upd_VarsTmpFile"

      else 
      
        printf "\n\n qqX_UpdateAvail="   > "$qqX_Upd_VarsTmpFile"

      fi

    fi

  fi 

}





function_show_main_menu_header () {

  if [[ ! $VM_InstanceName ]]; then

    Select_VM=1

  else

    [[ $InstancePID ]] && [[ ! $(cat "${VMDIR}/${VMNAME}.pid" 2>/dev/null) ]] && InstancePID=

    [[ ! $InstancePID ]] && printf "\033c"  && show_qmod_title
 
    printf "\n"
    printColor "    %s " "$VM_InstanceName" 

    #  Default_VM_Folder, as defined in settings.  Highlight if using non-default or current (pwd).

    #  See if using a Live ISO boot  (as in function_print_conf_array) or if is a new install without .qcow disk
    
    if [[ $Select_VM ]]; then  BootAlert=

    elif  [[  ! -e "$MainDrive" && ! -e "$IsoImg" ]]; then  BootAlert="(ERROR)" 

    elif  [[  ! -e "$MainDrive" ]]; then  BootAlert="(New: Bootable Main Drive yet to be created)" 
    
    elif  [[  ! $(du -b -t 1000000 "$MainDrive" 2>/dev/null) ]]; then  BootAlert="(ISO/IMG Boot: Distro Non-installed)" 
    
    else  BootAlert= 
    
    fi

    [[ $VM_Conf_Dir ]] && printf "  @   %s"  "$VM_Conf_Dir"
    printf "   %s" "$BootAlert"  
    printf "\n"

    [[ $KVM_MSR_Error ||  $Show_MSR_Warnings  || $MSR_Warnings || $Verbose_MSR_dialog ]] && print_kvm_status_warnings

    # Note .conf won't exist at first load, at VM selector menu

    [[ -e $VM_Conf_File ]] && [[ ! -e "$MainDrive" && ! -e "$IsoImg" ]] && printColor "\n    ERROR  Check .conf Drive & Iso Img settings \n"

  fi

}

# If settings need reloading, following a settings edit or a VM deletion:

refresh_sources_and_reload_VM_arrays() {

  # clear any previously declared settings based arrays 
  Extra_VM_Folder=()
  VM_Array=()
  QemuErrorFilter=()

  # shellcheck disable=SC1090

  if [[ $ModName_qqX ]]; then source "$Q_Mod_SettingsFile" ; else source "$Q_Mod_SettingsFile"  QWRAP ; fi

  refresh_and_load_main_sources
  quickget filepath

  [[ $XDG_GeneralDesktopStart ]] &&  function_xdg_start_folder && find_xdgopen_settings

  function_create_VM_folderList  
  function_scan_VM_folderList  
  find_main_drive_and_img_iso
  set_drive_paths

  # reload screen 
  ByPass_VM_Array_Selector=1
  KVM_MSR_Error=
  ShowUtilsMenu=
  printf "\033c"
  show_qmod_title

}


##  START:  QUICKEMU-WRAP  menu interface  &  API DIVIDER  ###

#   NB   Also see initial $1 flag setting traps at script start

if [[ $1 ]]; then

  # simple API for command line or .conf starts  ie.  --vm  "path/folder/file.conf"   

  if [[ $XDG_QcowRightClick ]]; then

    # should haved changed to the parent directory at this point

    if grep -q -s "disk_img="'"'"$XDG_QcowRightClick_VM_Dir_Name/$XDG_QcowRightClick_DiskName" "$XDG_QcowRightClick_VM_Dir_Name.conf" ; then

      VM_Conf_Dir="$(pwd)"
      VM_Conf_File="$XDG_QcowRightClick_VM_Dir_Name.conf"
      VM_InstanceName="$XDG_QcowRightClick_VM_Dir_Name"
      shift

    else  XDG_QcowRightClick_NO_qqX=1 ; shift

    fi

  elif [[ $XDG_StartVariant ]]; then

    echo
    function_qqX_logo
    printColor "\n\n  %s  not understood \n\n  Or non valid file type %s \n\n"  "$1 "  "$XDG_MimeType"
    sleep 5 

  elif [[ "$1" == *'vm' ]] && [[ "$2" == *'.conf' ]]; then

    # conforms to  -vm | --vm  file.conf
    VM_Conf_Dir="$(dirname "$2")"
    VM_Conf_File="$(basename "$2")"
    shift $#

  else 
  
    show_wrap_CLI_usage 
    printf "\n\n"
    exit directly

  fi


  if [[ ! $VM_Conf_Dir ]]; then  VM_Conf_Dir="$CurrentFolder"

  else

    if [[ ! -e  "$VM_Conf_Dir"  ]]; then 

      printColor "\n\n  %s  not found "  "$VM_Conf_Dir "
    
      function_conf_error  "Q-wrap COMMAND LINE Path Instruction,"

    else  cd "$VM_Conf_Dir"  || function_conf_error  "Q-wrap COMMAND LINE Path Instruction,"

    fi

  fi

  if [[ ! -e "$VM_Conf_Dir/$VM_Conf_File" ]]; then 

    printColor "\n\n  %s  not found "  "$VM_Conf_File"
  
    function_conf_error  "Q-wrap COMMAND LINE .Conf Instruction,"

  fi

   # Selection now made, but array must still be loaded as may be needed for reselecting later ...
   ByPass_VM_Array_Selector=1

fi


##  Start Q-wrap menu :   

tput civis

printf "\033c"

show_qmod_title

MultiInstanceCount="$(pgrep -c "$ModName")"

if [[ $MultiInstanceCount -gt 1 ]]; then 

  tput sc

  printColor "\n\n  WARNING: more than one instance of %s appears to be running "  "$ModName"

  printf "\n\n  To prevent cross-linking, this instance or the other instance(s) should be closed \n\n"

  read -rp "  [q] to quit    [enter] to continue  > "   MultiQuit

  [[ $MultiQuit == "q" ]] && exit directly

  tput rc ; tput ed  #  clear back the last lines to sc (set cursor)
  
fi


# clear .conf settings record from any previous/other session
printf "" > "$ConfClearanceLog"


if [[ "$(pgrep quickgui)" ]] ; then

  printColor "\n\n  WARNING: an instance of QUICKGUI appears to be running " 

  printf "\n\n  Both this program and qqX do have an amount of cross-link protection, however note that:"
  
  printf "\n\n  Stopping an instance shown as running in QuickGUI may stop an instance started in qqX. \n\n"

  read -rp "  [q] to quit    [enter] to continue  > "   MultiQuit

  [[ $MultiQuit == "q" ]] && exit directly

fi

# quietly check for qqX updates, in the background. Once only, at the start.

if [[ ! $Disable_qqX_upd_Checks ]]; then

  check_for_qqX_updates &   
  qqX_UpdaterPID="$!"

fi

# After the VM_InstanceName exists, check the VM disk is not corrupt  (quickemu default name only)
# https://qemu.readthedocs.io/en/v7.2.2/tools/qemu-img.html#cmdoption-qemu-img-commands-arg-check

function check_disk_is_okay {

  local PrintErrors=

  for CheckArg in "$@" ; do 
    if [[ $CheckArg == "PrintErrors" ]]; then PrintErrors=1 ; shift ; fi
  done

  if [[ $1 && ! $2 ]]; then

    DiskCheckFolderName="$(dirname "$1")"
    DiskCheck_Disk="$(basename "$1")"

  else

    if [[ $1 ]]; then DiskCheckFolderName="$1" ; else DiskCheckFolderName="$VM_InstanceName"; fi
    if [[ $2 ]]; then DiskCheck_Disk="$2" ; else DiskCheck_Disk="disk.qcow2"; fi

  fi

  DiskChkExitCode=
  DiskChkStatus=

  if [[ -e "$DiskCheckFolderName/$DiskCheck_Disk" ]]; then

    # Disk won't exist if new (or named differently REVIEW )
    # Qemu-img with '-q' only outputs if error & on outputs on stderr   The exit status remains separately recorded.

    if [[ $PrintErrors ]]; then  "$QEMU_IMG" check -q "$DiskCheckFolderName/$DiskCheck_Disk"

    else "$QEMU_IMG" check -q "$DiskCheckFolderName/$DiskCheck_Disk"  2>/dev/null ; fi

    # Note "Okay"  is also used as a flag  > caution if changing   # REVIEW  could also be flagged using:
    # DiskChkMsg="$("$QEMU_IMG" check -q "$DiskCheckFolderName/$DiskCheck_Disk" 2>&1)" 

    case "$?" in 

      0) DiskChkStatus="Okay" ;;

      1) DiskChkStatus="Check not completed because of internal errors" ;;

      2) DiskChkStatus="Check completed, image is corrupted" 
      
         DiskChkExitCode=2 ;;

      3) DiskChkStatus="Check completed, image has leaked clusters, but is not corrupted" 
      
         DiskChkExitCode=3  ;;

      63) DiskChkStatus="Checks are not supported by the image format -- not qcow2 ??" ;;

    esac

  fi

}

## filter for 'ERRORS' that changes in QEMU might throw up and that WE WANT TO IGNORE  (see main settings)

filter_and_flag_qemu_errors () {

  if [[ ! -e "$QemuErrorLog" ]]; then  printColor "\n\n  Internal ERROR:  QemuErrorLog not found.  A %s re-start may be needed."  "$ModName"
  
  elif [[ $(cat "$QemuErrorLog" 2>/dev/null) ]]; then 

    QemuErrorExists=1

    if [[ "${QemuErrorFilter[*]}" ]]; then
      for ErrChk in "${QemuErrorFilter[@]}"; do
        if grep -q -s "$ErrChk" "$QemuErrorLog" ; then QemuErrorExists= ; return ; fi
      done
    fi

    if [[ "${QemuError_VM_Filter[*]}" ]]; then
      for ErrChk in "${QemuError_VM_Filter[@]}"; do
        if grep -q -s "$ErrChk" "$QemuErrorLog" ; then QemuErrorExists= ; return ; fi
      done
    fi

  else  QemuErrorExists=
    
  fi

}


## MAIN MENU  (select VM then choose actions to do)

while true ; do

  MainMenuChoice=
  SnapTitle=
  SnapNumber=
  SnapName=

  function_show_main_menu_header

  if [[ $XDG_QcowRightClick_NO_qqX ]] || [[ $XDG_QcowRightClick ]]; then

    check_disk_is_okay "$XDG_QcowRightClick_VM_Dir_Name"  "$XDG_QcowRightClick_DiskName"

    if [[ $DiskChkStatus ]] && [[ $DiskChkStatus != "Okay" ]]; then 

      printColor "\n\n DISK.QCOW2 ERROR  %s "  "$DiskChkStatus"

    fi

    if [[ $XDG_QcowRightClick_NO_qqX ]]; then 
      
      [[ $DiskChkStatus == "Okay" ]] && printColor  "\n\n QEMU qcow2 disk found BUT not configured as qqX/quickemu bootable: \n\n"

    else
      
      printColor  "\n\n  qqX/quickemu bootable: \n\n"

      if [[ $DiskChkStatus != "Okay" ]]; then  

        printColor "  BUT has errors: Try qqX [disk] utils " 
      
        printf "\n\n Also see  https://qemu.readthedocs.io  "
      
        printf  "> QEMU disk image utility notes\n\n"

      fi

    fi

    "$QEMU_IMG" info "$XDG_QcowRightClick_VM_Dir_Name/$XDG_QcowRightClick_DiskName"
        

    if [[ $XDG_QcowRightClick_NO_qqX ]]; then  

      printColor "\n\n See  https://qemu.readthedocs.io  "
      
      printf  "> QEMU disk image utility may be useful"
    
      printf "\n\n  [enter] to quit  "
      
    else  printColor "\n\n  [enter] to continue  "
      
    fi

    read -rp  "  >  "
    
    

    if [[ ! $XDG_QcowRightClick_NO_qqX ]]; then

      XDG_QcowRightClick=
      function_show_main_menu_header

    else

      # XDG_QcowRightClick_NO_qqX=
      exit directly 

      # REVIEW  add disk conversion utility ??  Or something?

      #refresh_sources_and_reload_VM_arrays
      #MainMenuChoice="vm"
      #function_show_main_menu_header
      #continue
   
    fi

  elif [[ $SettingsFileAdjusted ]]; then 

    function_Select_VM
    MainMenuChoice="vm" 

  elif [[ $KillPID_Menu_Exited ]] || [[ $Select_VM ]] ; then

    if [[ $InstancePID ]] && [[ $( ps -p "$InstancePID" --no-headers ) ]] && [[ $(cat "${VMDIR}/${VMNAME}.pid" 2> /dev/null) ]]; then 

      #  REVIEW  add use of PID file
      printf "\n\n  %s is still running ..." "$VM_InstanceName"
      function_KillPID_Menu
      continue

    else 

      InstancePID=
    
      if [[ $Select_VM ]]; then  

        #declare -p VM_Array
        #echo    "  main menu loop - after Select_VM call:"
        #read -p "  VM_InstanceName is $VM_InstanceName  ByPass_VM_Array_Loader is $ByPass_VM_Array_Loader  ByPass_VM_Array_Selector is $ByPass_VM_Array_Selector"
        #echo

        function_Select_VM
        MainMenuChoice="refresh" 

        #declare -p VM_Array
        #echo    "  main menu loop - after Select_VM run:"
        #read -p "  VM_InstanceName is $VM_InstanceName  ByPass_VM_Array_Loader is $ByPass_VM_Array_Loader  ByPass_VM_Array_Selector is $ByPass_VM_Array_Selector"
        #echo

      else

        printf "\n    %s   >   is now shut down \n" "$VM_InstanceName" 

      fi
    
    fi

    [[ $KillPID_Menu_Exited ]] && KillPID_Menu_Exited=

  fi


  ## Print menu:

  if [[ ! $MainMenuChoice ]]; then

    printf  "\n"

    if [[ ! $VM_InstanceName ]]; then printColor  "  [vm]  reselect " ; else   printf  "  [vm]  SELECT " ; fi

    [[ $KVM_MSR_Error || $KVM_MSR_Warn ]] && [[ ! $ShowUtilsMenu ]] && printf  "  [m]  msrs help "

    
    if [[ ! $ShowUtilsMenu ]]; then

      printf  "  [u]  show utils & technical"

    else

      printf "   [del] delete selected VM"

      printColor  "    [u]   hide utils & technical"

      printf "\n"

      printf "\n\n  [tune] config tune-up wizard    [disk]  resize or repair existing drives" 

      printf "\n\n  [2] create a second  [3] a shared  > virtual hard-drive \n"


      if [[ $VerboseArgs ]]; then printf  "\n\n  [v]   hide verbose qemu args"	

      else  printf  "\n\n  [v]   show verbose qemu args & check before booting"	; fi

      printf  "   [xa]  edit extra qemu args  "

    
      printf "\n\n  [hdw]  add current config to this VM's Virtual Hardware Record    [m] msrs help "
    
      [[ $ExtraArgs ]] && printf  "\n\n  Extra Args:  %s"  "$ExtraArgs"

      printf "\n"

    fi

    printf  "\n\n  [sc]  create   [sd]  delete   [sa]  apply   [sl]  list   >  SNAPSHOTS "

    printf "\n"

    if [[ $XDG_QcowRightClick_NO_qqX ]]; then

      printColor  "\n\n  ?? "

    else

      printColor  "\n\n  [d]   start with SDL display"
      
      if [[ "$VM_InstanceName" =~ 'windows' ]]; then  printColor " (sizes to Windows > display, useful for Windows updates)" 

      elif [[ "$VM_InstanceName" =~ 'macos' ]]; then  printColor " (size determined by MacOS)" 

      elif [[ $SDL_ScrnPcnt_Cmd ]]; then 
      
        printColor " (%s%%)    [df]  99%% "  "$SDL_ScreenPercent" 
        
        [[ $qqX_GL_Mode == "off" ]] && printColor "  (scaleable)"    

      elif [[ $SDL_ScrnPcnt_Error ]]; then printf " (%s%% %s > see settings)"  "$SDL_ScreenPercent"  "$SDL_ScrnPcnt_Error"

      fi

      if [[ $HeadlessDisplay ]]; then printColor 	"\n\n  [s]   start with Spice display (HEADLESS) " 

      else  printColor 	"\n\n  [s]   start with Spice display (scaleable)   [sf]  spice full screen (shift F12 to exit)"  ; fi

      printColor "\n\n  [g]   start with GTK display          "

      if [[ $qqX_GL_Mode == "off" ]] ; then printColor "[gl] OFF > toggle-on"  

      else printColor "[gl] ON > toggle-off" ; fi   

    fi

    printf "\n"

    printf  "\n\n  [gt]  quickget a new distro   [i]  show VM drives info "

    filter_and_flag_qemu_errors

    if [[ $QemuErrorExists ]] ; then printColor "  [ql]  show qemu error log"

    elif [[ $FileManager ]]; then 

      if [[ $(type -p "$FileManager") ]]; then printf "   [f]  open VM folder in file manager"
    
      else  printColor "   [set]  ERROR file manager not found" ; fi

    fi

    if [[ "$VM_InstanceName" == 'ubuntu'* ]] && [[ "$VM_InstanceName" == *'daily'* || "$VM_InstanceName" == "ubuntustudio-dvd" ]]; then 
    
      if [[ ! $(du -b -t 500000 "$VM_InstanceName/disk.qcow2" 2>/dev/null) ]] && [[ $(ls "$VM_InstanceName/"*devel.iso 2>/dev/null) ]] ; then

        #  Live VMs only, as zsync only updates the iso file.   
        #  Live VM qcow2 disks are normally only 196k. Test ceiling is set at 500k.  REVIEW if problems. eg meta preallocation

        if [[ -e "$VM_InstanceName/zsync.date.txt" ]]; then

          SyncDateNow="$(date +%s)"

          SyncDateOld="$(cat "$VM_InstanceName/zsync.date.txt")"

          LastZsync="$((SyncDateNow - SyncDateOld))"

          #  older than 6hrs (in epoch seconds)

          printf "\n\n"

          if [[ $LastZsync -gt 21600 ]]; then  printColor "  [z]   daily-live zsync check - last run %d hrs ago"  "$((LastZsync/3600))"

          else  printf "  [z]   daily-live zsync check - last run %d hrs ago"  "$((LastZsync/3600))"
          
          fi

        else

          [[ -d "$VM_InstanceName" ]] && date +%s > "$VM_InstanceName/zsync.date.txt"
            
        fi

        ##  ZSYNC   See  functions 'get_ubuntu' & 'list_csv' in quickget  

          # qqX: NB only the iso gets dubbed with 'devel' suffix, otherwise VMs they keep their names 
          # eg  'ubuntu-mate-daily-live' 'ubuntustudio-dvd' 'ubuntu-daily-canary'

          # An actual 'ubuntu-devel' release or folder doesn't seem to ever get created or offered.
          # Presume release=devel (@2023/07) has now been superseded, or was merely intended as an indicative name only ...
          
          # Also note that quickget includes code to remove 'zs.old' files, which may or may not have been needed,
          # but Zsync can now give these files root protection so this removal may not work ...   REVIEW  Add a qqX copying mechanism? 


        # Sort out the quickget / function_quick_get_wrap  call & the var/flags   
        # Expect these to need updating from time to time ...

        Zsync_OS_Name="$VM_InstanceName"

        Zsync_OS_Name="${Zsync_OS_Name/'-daily'/}"
        Zsync_OS_Name="${Zsync_OS_Name/'-live'/}"
        Zsync_OS_Name="${Zsync_OS_Name/'-canary'/}"
        Zsync_OS_Name="${Zsync_OS_Name/'-legacy'/}"
        Zsync_OS_Name="${Zsync_OS_Name/'-jammy'/}"
        Zsync_OS_Name="${Zsync_OS_Name/'-dvd'/}"

        Zsync_Release_Name="$VM_InstanceName"

        Zsync_Release_Name="${Zsync_Release_Name/"${Zsync_OS_Name}-"/}"

        #echo; echo "$Zsync_OS_Name  $Zsync_Release_Name" 

        Zsync_Updatable_ISO=1

        # zero main menu flag that sets only if updater run from main 
        MainMenuZsync=

      fi

    else 

      Zsync_Updatable_ISO=
      Zsync_OS_Name=
      Zsync_Release_Name=

    fi
    
    printf  "\n\n  [h]   show help & info   [set] open settings file in text editor   [conf] open .conf file"

    [[ $DriveLocationError ]] &&  printColor "\n\n  %s"  "$DriveLocationError"

    if [[ $ConfSettingsAdjusted ]]; then 

      ConfSettingsAdjusted=
      printf "\n\n  done - general refresh not normally needed for .conf edits (use [vm] if req'd)"

    fi

    printf  "\n\n"

    if [[ $qqX_UpdaterPID ]]; then

      while true ; do

        if [[ $( ps -p "$qqX_UpdaterPID" --no-headers 2>/dev/null) ]]; then   sleep 1

        else 
        
          # shellcheck source=/dev/null
          source "$qqX_Upd_VarsTmpFile"
          qqX_UpdaterPID= 
          break
          
        fi

      done

    fi

    if [[ $DiskChkStatus ]] && [[ $DiskChkStatus != "Okay" ]]; then 

      printColor "  DISK.QCOW2 ERROR  %s  \n\n  [disk] repair utils "  "$DiskChkStatus"

    else  [[ $qqX_UpdateAvail ]] &&  printColor "  [dl]  download new qqX update: %s %s " "$qqX_LatestReleaseType" "$qqX_LatestRelease"

    fi

    printf  "  [q]   quit \n\n"
    read -rp "  >  "  MainMenuChoice

  fi


  # ACTIONS: 

  if [[ $MainMenuChoice == "h" ]] ; then

    show_quickemu_WRAP_help

   elif [[ $MainMenuChoice == "del" ]]; then 

    function_delete_Selected_VM  "$VM_InstanceName"  "$VM_Conf_File"

  elif [[ $MainMenuChoice == "hdw" ]] ; then

    AddHW_Record=

    if [[ -e "$QemuArgsFile" ]]; then 

      printf "\033c"

      if [[ -e "$QemuVirtHardwareRecord" ]]; then printf "\n\n  Existing Record: \n\n"; cat "$QemuVirtHardwareRecord"; fi

      printf "\n\n  Current Args / Qemu Virtual Hardware \n\n"
    
      cat "$QemuArgsFile"
      
      if [[ -e "$QemuVirtHardwareRecord" ]]; then printColor "  Copy Current Args onto the end of existing record list?\n\n"

      else printColor "  Create new Virtual Hardware Record using Current Args?\n\n"

      fi

      read -rp "  [enter] to continue  [b] to go back"  AddHW_Record

      if [[ $AddHW_Record != "b" ]]; then 
             
        cat "$QemuArgsFile" >> "$QemuVirtHardwareRecord"

      fi

    else

      printf "\n\n  No Args log found. The virtual machine launch process must be run first. \n\n"

      printf "\n\n  The 'VerboseArgs' option may be used, which will allow checking.  \n\n"

    fi 

  elif [[ $MainMenuChoice == "u" ]] ; then

    if [[ ! $ShowUtilsMenu ]]; then ShowUtilsMenu=1 ; else ShowUtilsMenu= ; fi

  elif [[ $MainMenuChoice == "set" ]] ; then

    qqX_edit_settings

  elif [[ $MainMenuChoice == "ql" ]] ; then

    QL_LogView=
    
    printf "\n\n"

    if [[ $(cat "$QemuErrorLog" 2>/dev/null) ]] ; then  
    
      cat "$QemuErrorLog"

      printf "\n\n  This log gets cleared when you run the VM, or it can be cleared now.  For permanent adjustments, see notes in the main settings."

    else  printf "  No qemu errors were present on the last VM load ...  ?? " ; fi

    printColor "\n\n  [enter] to return  [c] clear & return  [w] hide non-critical warnings, for this VM session \n\n"

    #  Avoid any "[W] permanent" type option because it could overwrite something manually placed in the .conf file

    read -rp "  >  "  QL_LogView

    [[ $QL_LogView  == "w" ]] && QemuError_VM_Filter+=("warning" "deprecated") 

    [[ $QL_LogView  == "c" ]] && printf "" > "$QemuErrorLog" 


  elif [[ $MainMenuChoice == "f" ]] ; then

    nohup > "/tmp/qqX_nohup.txt" 2> "/tmp/qqX_nohup.txt" "$FileManager"  "$VM_Conf_Dir/$VM_InstanceName"  &

    # > "/tmp/qqX_nohup.txt" handles the output that tells us about handling of mixed gtk2 and gtk3 etc ....  
    #  As from 'WebBrowser' section and handling of firefox etc

  elif [[ $MainMenuChoice == "dl" ]] ; then

    printf "\033c \n\n"

    function_qqX_printf_logo_title  "qqX updater"

    printf "\n\n\n  https://github.com/TuxVinyards/qqX/releases/latest" 

    if [[ ! $qqX_LatestTarBall ]] ; then

      printColor "\n\n  ERROR  No latest release found.  Reload & retry ..."

    else 

      if [[ $qqX_Latest_Secure_TarBall ]]; then printf "\n\n  %s"  "$qqX_Latest_Secure_TarBall"

      else  printf "\n\n  %s"  "$qqX_LatestTarBall"
      
      fi

      printf "\n"

      AboutRelease="$(grep -s 'body' "/tmp/latest-qqX")"
      AboutRelease="$(tr -cd '[:print:]' <<< "$AboutRelease")"
      AboutRelease="$(cut -d ':' -f2 <<< "$AboutRelease")"
      AboutRelease="${AboutRelease//\"/}"
      AboutRelease="${AboutRelease//'### '/}"
      AboutRelease="${AboutRelease//'## '/}"
      AboutRelease="${AboutRelease//'\n'/}"
      AboutRelease="${AboutRelease//'\r'/}"

      IFS='-' read -ra AboutReleaseArray <<< "$AboutRelease"

      for Line in "${AboutReleaseArray[@]}" ; do  printColor "\n\n  %s"  "$Line"  ; done

    fi

    printf "\n\n\n"

    while true ; do

      printf "  Neatly download the release into its own sub-folder at: "

      [[ $Specified_Updates_Location ]] && printf "\n\n  [s] Specified folder  %s"  "$Specified_Updates_Location"

      [[ -d "$HOME/Downloads" ]] && printf "\n\n  [d] Downloads folder  %s"  "$HOME/Downloads"

      if [[ $(pwd) == "$Default_VM_Folder" ]]; then 
      
        printColor "\n\n  [enter] Current/Default folder  %s "  "$Default_VM_Folder" 

      else  

        printf "\n\n  [c] Current folder    %s "  "$(pwd)"  
        
        printColor "\n\n  [enter] Default VM folder  %s"  "$Default_VM_Folder"

      fi 

      printf "\n\n"

      [[ $WebBrowser ]] && printColor "  [w] popup qqX web pages with %s"  "$WebBrowser"

      printf "   or [b] to go back \n\n"

      read -rp "  >  "  qqX_LatestTarBall_Folder

      printf "\n\n"


      if [[ $qqX_LatestTarBall_Folder == "s" ]]; then  qqX_LatestTarBall_Folder="$Specified_Updates_Location" ; break

      elif [[ $qqX_LatestTarBall_Folder == "d" ]]; then  qqX_LatestTarBall_Folder="$HOME/Downloads" ; break

      elif [[ $qqX_LatestTarBall_Folder == "c" ]]; then  qqX_LatestTarBall_Folder="$(pwd)" ; break

      elif [[ $qqX_LatestTarBall_Folder == "w" ]]; then  
     
        nohup > "/tmp/qqX_nohup.txt" 2> "/tmp/qqX_nohup.txt" "$WebBrowser"  "https://github.com/TuxVinyards/qqX"  & 

        # https://unix.stackexchange.com/questions/103483/opening-firefox-from-terminal#103486
        # > "/tmp/qqX_nohup.txt" handles the output that tells us how firefox etc has handled mixing of gtk2 and gtk3 etc ....

      elif [[ $qqX_LatestTarBall_Folder == "b" ]]; then  qqX_LatestTarBall_Folder= ; qqX_NoReleaseDL=1 ; break

      else qqX_LatestTarBall_Folder="$Default_VM_Folder" ; break

      fi

    done

    if [[ $qqX_NoReleaseDL ]]; then 

      qqX_NoReleaseDL=

    else

      # each release to its own folder makes things tidier
      qqX_LatestTarBall_Folder="$qqX_LatestTarBall_Folder/qqX.releases/$qqX_LatestRelease"
      mkdir -p "$qqX_LatestTarBall_Folder"

      # record where to come back to, when done
      ReturnFolder="$(pwd)"

      cd "$qqX_LatestTarBall_Folder"  || printColor "\n\n  ERROR  making or changing to qqX.releases folder"

      if [[ $qqX_Latest_Secure_TarBall ]]; then
        
        wget "$qqX_Latest_Secure_TarBall" -O "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}.tar.gz"
        wget "$qqX_Latest_Secure_TarSha" -O "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}.tar.gz.sha256"
        SHA_Check="$(sha256sum -c "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}.tar.gz.sha256")"

        printColor "\n  SHA256 Check: %s "  "$SHA_Check"

        [[ "$SHA_Check" != *'OK' ]] &&  printf "\n\n  ERROR  - RETRY  DOWNLOAD \n\n"
      
      else  wget "$qqX_LatestTarBall" -O "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}.tar.gz"

      fi

      printColor "\n\n  Files downloaded to %s"  "$qqX_LatestTarBall_Folder"

      if [[ $BetaTxReleasePoint ]]; then 
      
        printf "\n\n\n  Transitioning from beta to release ...  If required,"
        printf "\n\n  Beta Notifications can be turned off in the general settings file \n"

      fi

      printColor "\n\n  Use the installer script to quickly refresh and add new features to your settings file."

      printf "\n\n  All option settings, locations and preferences will be kept."

      printf "\n\n\n  [enter] to run the installer script   [r] to return to main menu \n\n"

      read -rp "  >  "  qqX_UpdateExit

      if [[ $qqX_UpdateExit != "r" ]]; then 

        # https://stackoverflow.com/questions/651018/opening-a-tar-gz-file-with-a-single-command

        tar xvfz "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}.tar.gz" 

        cd "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}" || printColor "\n\n  ERROR  changing to qqX.releases folder"

        # move current execution away from this script and to the installer
        exec  bash -c "./qqX_setup_and_install  Upgrade" 

      fi

      sleep 0.6
      cd "$ReturnFolder"  || printColor "\n\n  ERROR  returning from qqX.releases folder"

    fi

  elif [[ $MainMenuChoice == "conf" ]] ; then qqX_edit_settings  conf

  elif [[ $MainMenuChoice == "tune" ]] ; then function_config_tune_up "$VM_Conf_File" "$VM_InstanceName"

  elif [[ $MainMenuChoice == "gt" ]] ; then function_quick_get_wrap

  elif [[ $MainMenuChoice == "z" ]] ; then

    if [[ $Zsync_Updatable_ISO && $Zsync_OS_Name && $Zsync_Release_Name ]]; then

      MainMenuZsync=1
      function_quick_get_wrap

    else  printColor "\n\n  %s is not being recognised as Zsync updatable Release \n\n"   "$VM_InstanceName"

    fi

  elif [[ $MainMenuChoice == "m" ]] ; then

    KVM_MSR_selector_LoadHelp=1
    select_msr_config

  elif [[ $MainMenuChoice == "gl" ]] ; then

    if [[ $qqX_GL_Mode == "on" ]] ; then qqX_GL_Mode="off"

    elif [[ $qqX_GL_Mode == "off" ]] ; then qqX_GL_Mode="on" 
    
    fi

  elif [[ $MainMenuChoice == "g" ]] ; then 

    printf "\n\n"

    if [[ -e "$VM_InstanceName/${VM_InstanceName}.pid" ]]; then 

      printColor "  ERROR:  QEMU appears to be running this machine elsewhere  (qemu.pid file found)"

      printf "\n\n [enter] to return \n\n"
      read -rp "  >  "

    else

      eval quickemu "-vm $VM_Conf_File --vm_boot --display gtk" 
      function_KillPID_Menu

    fi
        
  elif [[ $MainMenuChoice == "d" ]] || [[ $MainMenuChoice == "df" ]] ; then 

    printf "\n\n"

    if [[ -e "$VM_InstanceName/${VM_InstanceName}.pid" ]]; then 

      printColor "  ERROR:  QEMU appears to be running this machine elsewhere  (qemu.pid file found)"

      printf "\n\n [enter] to return \n\n"

      read -rp "  >  "

    else

      if [[ $MainMenuChoice == "df"  ]]; then  eval quickemu "-vm $VM_Conf_File --vm_boot --screenpct 99  $Extra_QE_Params" 

      else  eval quickemu "-vm $VM_Conf_File --vm_boot  $SDL_ScrnPcnt_Cmd $Extra_QE_Params" 

      fi

      [[ $InstancePID ]] && printf "\n  SDL: Use guest based display resize. Avoid resizing with the host mouse ...\n\n"

      function_KillPID_Menu

    fi
        
  elif  [[ $MainMenuChoice == "s" ]] || [[ $MainMenuChoice == "sf" ]] ; then

    printf "\n\n"

    if [[ -e "$VM_InstanceName/${VM_InstanceName}.pid" ]]; then 

      printColor "  ERROR:  QEMU appears to be running this machine elsewhere  (qemu.pid file found)"

      printf "\n\n [enter] to return \n\n"

      read -rp "  >  "

    else

      if [[ $HeadlessCmd ]]; then 

        # headless only runs in Spice
        eval quickemu "-vm $VM_Conf_File --vm_boot $HeadlessCmd  $Extra_QE_Params"

      elif [[ $MainMenuChoice == "sf" ]]; then  eval quickemu "-vm $VM_Conf_File --vm_boot --display spice --fullscreen  $Extra_QE_Params"

      else  eval quickemu "-vm $VM_Conf_File --vm_boot --display spice  $Extra_QE_Params"

      fi

      #  https://qemu.readthedocs.io/en/latest/system/invocation.html#hxtool-3 

      [[ $P_Kill_WaitSecs  -gt 1 ]] && P_Kill_WaitSecs="$(bc <<< "scale=0; ($P_Kill_WaitSecs+1.5)/2" 2>/dev/null)"

      function_KillPID_Menu

    fi
      
  elif  [[ $MainMenuChoice == "q" ]] ; then

    printf "\n\n"
    MainMenuChoice=
    exit directly	

  elif  [[ $MainMenuChoice == "i" ]] ; then

    drives_and_snapshots  info

      printf "\n\n  Resize using qqX [disk] utility if the disk size exceeds the (theoretical) virtual size"

    [[ $SharedDriveArgs || $SecondDriveArgs ]] && printColor "\n\n  Scroll to View "

    printf "\n\n  [enter] to return to menu \n\n "
    read -rp "  >  "  

  elif  [[ $MainMenuChoice == "disk" ]] ; then

    manange_and_repair_disks

  elif  [[ $MainMenuChoice == "sl" ]] ; then

    drives_and_snapshots

    [[ $SharedDriveArgs && $SecondDriveArgs ]] && printColor "\n\n  Scroll to View "
    printf "\n\n  [enter] to return to menu \n\n "
    read -rp "  >  "  
  

  elif  [[ $MainMenuChoice == "sc" ]] ; then

    drives_and_snapshots  select

    printColor "\n\n  [enter] automatic date.time title  "
    printf "  [text input] descriptor   [b] back to menu " 
    SnapTitle=
    printf "\n\n"
    read -rp "  >  "  SnapTitle
    printf "\n\n"	

    [[ ! $SnapTitle ]] && SnapTitle="$(date +%b%d.%H.%M)"
    
    if [[ $SnapTitle != "b" ]]; then 
    
      # remove spaces, make title dot separated, as easier to IFS
      SnapTitle="${SnapTitle// /.}"

      "$QEMU_IMG" snapshot  -c "$SnapTitle" "$Selected_Drive" 

      "$QEMU_IMG" info "$Selected_Drive"

      printColor "\n\n  Drive Updated ..."

      printf "\n\n  [enter] to return to menu \n\n "
      read -rp "  >  "  

    fi

  elif  [[ $MainMenuChoice == "sd" ]] ; then

    drives_and_snapshots  select 

    printColor "\n\n %s Snapshot Delete function "  "$ModName"

    printf "\n\n %s  (reselection & cancel prompts are given before starting)" "$Selected_DriveName"

    # Create range-selectable array 
    #SnapListString="$(drives_and_snapshots | grep '[0-9][0-9]:')"
    
    SnapListString="$("$QEMU_IMG" info "$Selected_Drive" | grep '[0-9][0-9]:')"

    # turns the multiline string into raw array with one whole line for each entry making each array element

    # then line by line extract the snap number and its title:

    mapfile -t SnapListArrRaw <<< "$SnapListString"

    i=0
    SnapListArrSeparated=()

    printColor "\n\n ID   Array  Name \n\n"
    while [[ "${SnapListArrRaw[i]}" ]]; do
      IFS=' ' read -ra SnapListArrSeparated <<< "${SnapListArrRaw[i]}" 
      # prints the first two elements of each snapshot info line 
      printf "%2d    %2d    %s \n"  "${SnapListArrSeparated[0]}"  "$i"  "${SnapListArrSeparated[1]}"
      ((i+=1))
    done

    SnapListArrTotal=$((i-1))

    printColor "\n Enter ARRAY number [0] to [%s], either for individual snapshot, or for the start of snapshot range"  "$SnapListArrTotal"
    printf "\n\n or [full individual name] for difficult names only showing correctly in the FULL listing"
    printf "\n\n or [enter] to return to main menu "

    SnapName=
    SnapDeleteStart=
    SnapDeleteEnd=
    SnapDeleteConfirm=
    
    printf "\n\n"
    read -rp " >  "  SnapDeleteStart
    
    if [[ $SnapDeleteStart ]]; then

        SpecialSnapName="$SnapDeleteStart"
        SpecialSnapName="$(tr -d "[:digit:]" <<< "$SpecialSnapName")"

      if  [[ $SpecialSnapName ]]; then

        # restore name as valid name if, when all digits removed, there is still something
        SpecialSnapName="$SnapDeleteStart"
        printf "\n  Snap to delete: \"%s\"" "$SpecialSnapName"

      else

        printColor "\n [enter] for an individual snapshot  or give ARRAY [number] for end of range (inclusive) \n\n"
        read -rp " >  "  SnapDeleteEnd

        if [[ $SnapDeleteEnd ]]; then 

          SnapDeleteEnd="$(tr -cd "[:digit:]" <<< "$SnapDeleteEnd")"

          if [[ $SnapDeleteEnd ]]; then  [[ $SnapDeleteEnd -gt "$SnapListArrTotal" ]] && SnapDeleteEnd="$SnapListArrTotal"

          else  SnapDeleteEnd="$SnapListArrTotal"

          fi

          printf "\n Array Range = %s to %s" "$SnapDeleteStart"  "$SnapDeleteEnd"

          i="$SnapDeleteStart"
          SnapListArrSeparated=()

          printColor "\n\n ID   Array  Name \n\n"
          while true; do
            IFS=' ' read -ra SnapListArrSeparated <<< "${SnapListArrRaw[i]}" 
            # prints the first two elements of each snapshot info line 
            printf "%2d    %2d    %s \n"  "${SnapListArrSeparated[0]}"  "$i"  "${SnapListArrSeparated[1]}"
            [[ $i == "$SnapDeleteEnd" ]] && break
            ((i+=1))
          done

        else         
          printf "\n Delete = ARRAY entry %s " "$SnapDeleteStart" 
          printf "\n\n  %s" "${SnapListArrRaw[SnapDeleteStart]}" 
          SnapDeleteEnd="$SnapDeleteStart"
        fi

      fi

      printColor "\n [enter] to delete  [b] back to main menu (or reselect) \n\n"

      read -rp " >  "  SnapDeleteConfirm


      if [[ $SnapDeleteConfirm == "b" ]]; then

        printf "\n\n Deletion schedule has been CANCELLED"

      else

        if [[ $SpecialSnapName ]]; then

          "$QEMU_IMG" snapshot -q -d "$SpecialSnapName" "$Selected_Drive" 

        else
      
          SnapDeleteRangeCounter=$SnapDeleteStart

          while [[ $SnapDeleteRangeCounter -le $SnapDeleteEnd ]]; do
            IFS=' ' read -ra SnapListArrSeparated <<< "${SnapListArrRaw[$SnapDeleteRangeCounter]}"
            SnapName="${SnapListArrSeparated[1]}"

            if [[ ! $SnapName ]]; then
              printColor "\n\n ERROR with SnapShot Array List \n\n"
              sleep 5
              exit 1
            else
              printColor "\n\n Deleting SnapShot %2d   %2d  %s \n\n"  "${SnapListArrSeparated[0]}"  "$SnapDeleteRangeCounter"  "${SnapListArrSeparated[1]}"

              "$QEMU_IMG" snapshot -q -d "$SnapName" "$Selected_Drive" 

            fi
            ((SnapDeleteRangeCounter+=1))
          done

        fi

        "$QEMU_IMG" info "$Selected_Drive"

      fi

      printf "\n\n [enter] to return to menu \n\n "
      read -rp " >  "  

    fi

    #  REVIEW  see if tiano core bios can be set to select 'misc device' instead of 'windows boot manager' 
    #          as this can cause problems when rebooting on updates
    
    #  https://github.com/tianocore/tianocore.github.io/wiki/UEFI-application

    #  https://github.com/theopolis/uefi-firmware-parser
          
  elif  [[ $MainMenuChoice == "sa" ]] ; then

    drives_and_snapshots select

    printColor "\n\n  Give number of snapshot to use  [enter] to return to menu "
    SnapNumber=
    
    printf "\n\n"
    read -rp "  >  "  SnapNumber
    printf "\n\n"	

    if [[ $SnapNumber ]]; then
    
      "$QEMU_IMG" snapshot -q -a "$SnapNumber" "$Selected_Drive" 

      printf "\n\n  May take a moment .... \n\n"
      printColor "\n\n  Snapshot %s has been applied. \n\n"  "$SnapNumber "

    fi
  
  elif [[ $MainMenuChoice == "2" || $MainMenuChoice == "3" ]] ; then

    SecondDriveCreateSize=
    DriveCreated=

    if [[ $MainMenuChoice == "3" ]] && [[ $SharedDriveArgs ]] ; then printColor "\n\n  ERROR:  a shared drive already exists. Make backups ...\n\n"

    elif [[ $MainMenuChoice == "2" ]] && [[ $SecondDriveArgs ]] ; then printColor "\n\n  ERROR:  a second drive already exists. Make backups ...\n\n"

    else

      [[ $MainMenuChoice == "2" ]] && printColor "\n\n  Create a SECOND virtual hard-drive for this VM instance:"
      
      [[ $MainMenuChoice == "3" ]] && printColor "\n\n  Create a SHARED virtual hard-drive for this VM instance:"
      
      printf "\n\n\n  Suggest 32G or higher, especially if expecting to create snapshots. Note that" 

      printf "\n\n  qcow2 disks auto-compress & will normally occupy much less of your hard drive "
      
      printf "\n\n  than that allocated.  An empty disk only takes up 70Mb when formatted."
      
      printf "\n\n  It is easier make them larger now than to resize later ... " 

      printColor "\n\n\n  [enter] create 64G   [integer] create int G   [b] go back \n\n"

      read -rp "  >  "  SecondDriveCreateSize

      [[ ! $SecondDriveCreateSize ]]  && SecondDriveCreateSize="64"

      [[ $SecondDriveCreateSize ]]  &&  SecondDriveCreateSize="$(tr -cd "[:digit:]" <<< "$SecondDriveCreateSize")"

      if [[ $SecondDriveCreateSize ]]; then 

        if [[ $MainMenuChoice == "2" ]] && grep -s -q SecondDrive "$VM_Conf_File" ; then

          printColor "\n\n  ERROR: A SecondDrive entry is already present in your .conf file ??"

          printf "\n\n  Check general settings & notes on drives set up.  Edit the configuration. \n\n"

        elif [[ $MainMenuChoice == "3" ]] && [[ ! -d "$Default_VM_Folder" ]]; then

            printf "\n\n  Default_VM_Folder not present. Edit the main settings file first. \n\n"  

        else
           
          if [[ $MainMenuChoice == "2" ]]; then

            printf "\n\n  A Storage Drive will be created in the VM's folder \n\n  %s"  "$VM_InstanceName"

          elif [[ $MainMenuChoice == "3" ]]; then 

            printf "\n\n  A folder 'SharedDrive will be created in the Default_VM_Folder \n\n  %s"  "$Default_VM_Folder"

            printf "\n\n  It may later be moved. Editing settings file: \n\n  %s" "$Q_Mod_SettingsFile"

          fi

          printColor "\n\n  [enter] to continue  [b] to go back \n\n"

          NewDriveCreate=

          read -rp "  > "  NewDriveCreate

          if [[ $NewDriveCreate != "b" ]]; then

            if [[ $MainMenuChoice == "2" ]]; then 

              printf "SecondDrive=\"%s/%s/storage.qcow2\"" "$VM_Conf_Dir" "$VM_InstanceName"  >> "$VM_Conf_File"

              "$QEMU_IMG"  create -q -f qcow2 "$VM_Conf_Dir/$VM_InstanceName/storage.qcow2" "${SecondDriveCreateSize}G"

              [[ -e "$VM_Conf_Dir/$VM_InstanceName/storage.qcow2" ]] && DriveCreated=2
          
            elif [[ $MainMenuChoice == "3" ]]; then

              "$QEMU_IMG"  create -q -f qcow2 "$Default_VM_Folder/SharedDrive/shared.qcow2" "${SecondDriveCreateSize}G"

              [[ -e "$Default_VM_Folder/SharedDrive//shared.qcow2" ]] && DriveCreated=3

              # 'sed' can get very HIEROGLYPHICAL  https://stackoverflow.com/a/9453461

              # 'awk' ?  https://stackoverflow.com/a/32995760
              #  awk :  https://stackoverflow.com/a/6541653   https://stackoverflow.com/tags/awk/info 
              #  sed awk easy methods: https://www.ubuntumint.com/insert-line-specific-line-number-linux/
              #  date ref awk:  https://unix.stackexchange.com/a/599097

              #  https://www.gnu.org/software/sed/manual/sed.html#Command_002dLine-Options  
              #  Make sure sed command works in --posix  if testing on gnu sed ...
              #  Also note here:
              #  https://stackoverflow.com/questions/6537490/insert-a-line-at-specific-line-number-with-sed-or-awk#6537587
              #  sed -i only works in GNU sed  ... 

              if [[ "$(sed --version | head -1)" == *'GNU'* ]] && [[ $(grep -s 'SharedDrive=' "$Q_Mod_SettingsFile" | grep -v '#' | grep -c 'SharedDrive') == 1 ]]; then

                # do a grep -c (count) & make sure that other than in comments (#) there is only one entry that is possible
                
                SharedDriveSettingsLine="$(grep -s -n 'SharedDrive=' "$Q_Mod_SettingsFile" | grep -v '#' | cut -d ':' -f 1)"

                printf "\n\n  Backing up settings file to /tmp and changing line %s \n\n"  "$SharedDriveSettingsLine"

                eval cp "$Q_Mod_SettingsFile"  "/tmp/qqX_settings.$(date +%s).old"     # REVIEW add awk version?

                eval sed -i \'"$SharedDriveSettingsLine" c\ SharedDrive=\""$Default_VM_Folder"/SharedDrive/shared.qcow2\"\'  "$Q_Mod_SettingsFile"

              else 

                printColor "\n\n  A drive has been created but the settings file will need to be edited manually \n\n"

                grep 'SharedDrive=' "$Q_Mod_SettingsFile"

                printf "\n\n"

              fi

            fi

            if [[ $DriveCreated ]]; then

              set_drive_paths

              printColor "\n  The Created Drive should now be formatted from inside a VM:"

              printf "\n\n  Use Gparted or similar to set a device table and add partition(s)"

              printf "\n\n  Read notes in main settings if older MacOS or if Windows present."

            else

              printColor "\n\n  Something went wrong. Drive not created "

            fi

          fi

        fi

      fi
        
    fi

    printf "\n\n"

    read -rp "  [enter] to return > "

    
  elif [[ $MainMenuChoice == "v" ]] ; then

    if [[ $VerboseArgs ]]; then VerboseArgs= ; else VerboseArgs=1 ; fi

  
  elif [[ $MainMenuChoice == "vm" ]] ; then

    if [[ ! ${VM_Array[0,0]} ]]; then refresh_sources_and_reload_VM_arrays ; fi
    Select_VM=1
    ByPass_VM_Array_Selector=
    ByPass_VM_Array_Loader=


  elif [[ $MainMenuChoice == "xa" ]] ; then

    MenuXA=
    MenuXA_Correct=

    printColor "\n\n  Give extra qemu arguments to use "
    printf     "\n\n  Format = grouped & with space separated elements "
    printf     "\n\n  eg.  -device  tpm-tis,tpmdev=tpm0 "

    [[ $ExtraSetArgs ]] && printf  "\n\n  Extra Set Args:  %s"  "$ExtraSetArgs"

    if [[ $ExtraArgs ]] && [[ "$ExtraArgs" != "$ExtraSetArgs" ]]; then
    
      printf  "\n\n  Extra Args:  %s"  "$ExtraArgs"

      if [[ $ExtraSetArgs ]]; then printf "\n\n  [r] reset back to Set Args only "

      else printf "\n\n  [r] remove the Extra Args " ; fi

    fi

    printf "\n\n"
    read -rp "  > "  MenuXA

    if [[ $MenuXA != "r" ]]; then

      printf "\n\n  %s %s"  "$ExtraArgs" " $MenuXA"
      printf "\n\n  Is this correct y/n ? \n\n"
      read -rp "  >  "  MenuXA_Correct

    fi
    
    if [[ $MenuXA_Correct == "n" ]]; then printColor "\n\n  Ignoring the entered Qemu Args \n\n" ; sleep 1.5 

    elif [[ $MenuXA == "r" ]]; then printColor "\n\n  Resetting \n\n" ; ExtraArgs="$ExtraSetArgs" ; sleep 1 
    
    else  ExtraArgs="$ExtraArgs $MenuXA" ; fi

    printf "\033c\n\n"


  else

    # refresh
    MainMenuChoice=

  fi

done

# https://code.visualstudio.com/

# vim:tabstop=2:shiftwidth=2:expandtab

## 
