#! /bin/bash 

##  Copyright (c)  Alex Genovese   https://github.com/TuxVinyards

# 	licence:  GPL3   https://www.gnu.org/licenses 

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# https://www.gnu.org/licenses 

# IF ANY MODDED CODE BECOMES USED IN THE ORIGINAL QUICKEMU PROJECT,

# OR ANY OTHER PROJECT, YOU SHOULD SHOW BOTH THE LICENCE  

# & CLEAR ATTRIBUTIONS TO THE CODE SECTIONS USED.


##  A text menu interface for the 'quickemu' project

#   https://github.com/quickemu-project/quickemu   https://gitlab.com/qemu-project/qemu

#   Users should install 'quickemu' and may set up Virtual Machines as normal.


## A wrapping script for quickemu/quickget.  Originally part of quickemu-mod suite of scripts. 

#  See:  https://en.wikipedia.org/wiki/Wrapper_library   https://en.wikipedia.org/wiki/Adapter_pattern 


#  @2023/08 this script forms the base for qqX - quickemu quickget X terminal project  

#  qqX may be installed alongside quickemu in /usr/bin  & run by typing either qqX or qqx. Or by mouse


#  @2023/08  Work on quickemu-wrap is now being frozen but this script attempts to maintain backward compatibility

#  during the initial qqX release.  In theory it may second install as qwrap. YMMV

#  Concurrent qwrap & qqX will have different settings files which may or may not be advantageous.  

#  See:  https://github.com/TuxVinyards/qqX  &  https://github.com/TuxVinyards/quickemu-mod


##  Bash 5.0+   (2023: we are now at ver 5 for at least 10 years ...) 

#   details: try 'bash -version at the commandline'   

#   See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell


## ShellCheck global disables:

# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open

#  shellcheck disable=SC2242


# This script:

ModVersion="0.10.00.18"

# "0.10.0.18"  is temporarilly assigned as  "0.10.00.18" to make sure "0.09.00.016" can read it

# major.minor.point[.dev-point]  x.x.2dp[.2dp]


# @ 2023/09 reduce out a few zeros eg "0.09.00.016" becomes "0.9.0.16"

# where x = any whole number and the last register always being 2dp.

# The 2nd register becomes printf'ed to 2dp for upgrade valuation

# while a single 0 in the third register indicates beta  [with fourth register at 2dp]



ModName="$(basename "$0")"

if [[ $ModName == "qqx" || $ModName == "qqX" ]]; then ModName_qqX=1 ; else  ModName_qqX=  ; fi



## Make sure shell is set during session to decimal separator of dot 

#  LC_ALL=C changes too much, just set the numeric.

#  See locale setting discussion:  https://unix.stackexchange.com/a/149129 

#  Also  https://unix.stackexchange.com/questions/62316/why-is-there-no-euro-english-locale?rq=1

#  &   http://www.unicode.org/L2/L2001/01102-POSIX15897.htm   


export "LC_NUMERIC=C"

export "LC_COLLATE=C"


if ! tput -V | grep -q ncurses 2> /dev/null; then
  printf "\n\n  Check for your OS >  \n\n  An 'ncurses' installation should normally be present. Test using 'tput -V' "
  sleep 5
  exit 1
fi

if [[ ! -d "/tmp" ]]; then
  printf "\n\n  Check for your OS >  \n\n  A directory '/tmp' should be present. A symbolic link may be needed. "
  printf "\n\n  See:  https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard"
  sleep 5
  exit 1
fi

 
##  CODING STYLE of Variables & Functions:

#  When coding for qqX, aim for clarity and contextual identity.  Variables should normally tend towards 'CamelCase'  

#  & functions should tend towards 'snake_case'.  Emphasis or separation underscoring & caps should be added where needed. 

#  https://en.wikipedia.org/wiki/Camel_case   https://en.wikipedia.org/wiki/Snake_case


#  In some places ** quickemu's given variable names ** have to be used. These are generally CAPS and very brief, eg '$QEMU'.

#  Except when working with the .conf file, where quickemu chooses to use lowercase.

#  Care should be taken not to confuse them with Bash's BUILT_IN vars, or to confuse their scope, eg. the quickemu var '$VERSION'  

#  Likewise and especially in non-highlighting editors, care must be taken not to confuse lowercase vars with standard application commands.

#  Add clarifying comments to qqX code if origin or meaning could be difficult to folllow.


## Pre-empt some of quickemu's error messages. 

QEMU=$(command -v qemu-system-x86_64)     
QEMU_IMG=$(command -v qemu-img)

QEMU_VER_LONG=$(${QEMU} -version | head -n1 | cut -d' ' -f4 | cut -d'(' -f1)

if [[ ! $QEMU ]] || [[ ! $QEMU_IMG ]]; then
  printf "\n\n QEMU not found. Check installations of qemu-system-x86_64 and qemu-img"
  printf "\n\n If using the quickemu packaging this should normally have been installed."
  sleep 5
  exit 1
fi


if [[ $1 == "XDG" ]]; then 

  # set flags & deal with details after the setting up is done

  if [[ -e "$2" ]]; then

    XDG_MimeType="$(mimetype "$2" 2>/dev/null)"
   
    if [[ "$XDG_MimeType" == *'application/x-qemu-disk' ]]; then XDG_MimeType_Valid=1

    else XDG_MimeType_Valid=  ; fi

  fi

  if [[ $XDG_MimeType_Valid ]]; then

    # is a right-click start on a qcow2 disk (set flag for later) 
    XDG_QcowRightClick=1
    shift
    
  elif [[ $2 ]]; then

    # is right click XDG but at this stage needs flagging for later analysis or other type of handling
    XDG_StartVariant=1
    shift

  else

    shift
    # set to $HOME folder and flag to run the VM selector
    cd "$HOME"  || printf "\n\n XDG .desktop starter  >  HOME Folder not found " 
    CurrentFolder="$HOME"
    XDG_GeneralDesktopStart=1

  fi


elif [[ $ModName_qqX ]] && [[ $1 == "--version" || $1 == "-V" ]] ; then

  echo "$ModVersion" ; exit 


elif [[ ! $ModName_qqX ]] && [[ "$1" == *'vm' ]]; then  

  # quickemu-wrap only  &  where test [[ $Conf_TriggerFolder ]] will also flag up if the script was .conf target started

  Conf_TriggerFolder="$(dirname "$0")"
  
  CurrentFolder="$(dirname "$2")"

else 

  CurrentFolder="$(pwd)"
  
fi


# INDIVIDUAL SETTINGS:

custom_conf_notes () {

  printColor "\n\n  Individual/Custom qqX .conf settings:"

  printf "
  
    #!/usr/bin/qqX --vm   (qqX direct start)

    Custom_SDL_ScreenPercent=\"xx\" (integer from 25 to 100)

    SecondDrive=\"My_Folder/My_VM/disk2.qcow2\"

    MacLegacyDrive=\"true\"

    SharedDrive_Conf=\"no-shared\"

    Other:

    disk_size=\"128G\"  (or other integer)

    cpu_cores=\"x\"  (even integer)

    ram=\"xG\"  (integer)

    shift-ctrl-c  to copy ...

  \n"


  printColor "  [enter] to edit \n\n"

  read -rp "   >   "

}

#  Pick up the SETTINGS file:  If placing the main file in /usr/bin,"

#  then place the settings file as "/$HOME/.qmod_settings, OR if qqX in "/$HOME/.qqX/qqX_settings"

#  For details, see notes at start of the settings file ...

#  Use full quoted path & name if adding in a additional folder to this script or different to these defaults

#  For .conf click starts, the Positional parameters need reading to check the settings file location;

#  this would be expected to be where the specified wrap script is located as a first check


if [[ $ModName_qqX ]]; then SettingsName="qqX_settings"

else SettingsName="qmod_settings" ; fi



if [[ $Conf_TriggerFolder ]] && [[ -e "$Conf_TriggerFolder/${SettingsName}" ]]; then  

  Q_Mod_SettingsFile="$Conf_TriggerFolder/${SettingsName}"

elif [[ -e "$CurrentFolder/${SettingsName}" ]] && [[ "$CurrentFolder" != '/usr'* ]]; then  

  Q_Mod_SettingsFile="$CurrentFolder/${SettingsName}"

elif [[ -e "$CurrentFolder/.${SettingsName}" ]] && [[ "$CurrentFolder" != '/usr'* ]]; then  

  Q_Mod_SettingsFile="$CurrentFolder/.${SettingsName}"

#  

elif [[ $ModName_qqX ]]; then 

  [[ -e "$HOME/.qqX/qqX_settings" ]] && Q_Mod_SettingsFile="$HOME/.qqX/qqX_settings"

elif [[ -e "$HOME/.qmod_settings" ]] && [[ ! $ModName_qqX ]] ; then  

  Q_Mod_SettingsFile="$HOME/.qmod_settings"

elif [[ -e "$HOME/qmod_settings" ]] && [[ ! $ModName_qqX ]] ; then 

  Q_Mod_SettingsFile="$HOME/qmod_settings"

else  

  Q_Mod_SettingsFile=  

  echo; echo "  No settings file found .... " ; echo ; sleep 2
  
fi



# Declare global associative VM ARRAY & other initializing global vars. Make ready to read settings.

declare -gA VM_Array=()

declare -ga Extra_VM_Folder=()


# LOAD SETTINGS & Array PRESETS  

VM_ExecBoot=

Extra_QE_Params=

if [[ -e "$Q_Mod_SettingsFile" ]]; then

  # shellcheck disable=SC1090
    
  if [[ $ModName_qqX ]]; then source "$Q_Mod_SettingsFile" ; else source "$Q_Mod_SettingsFile"  QWRAP ; fi

else

  printf "\n\n  ERROR with settings file detection \n\n  Re-check Installation &/or Installation instructions \n\n" ; sleep 10 
  
fi


# Intepret the settings:

function_xdg_start_folder () {

  # For a .desktop start, to be run after the settings file has been loaded so that a $Default_VM_Folder can be available

  #  Also can be called (belt & braces) at the other command line $1 trap towards end of script ...  REVIEW 

  if [[ ! $(ls "$HOME/"*.conf 2> /dev/null) ]] && [[ -d "$Default_VM_Folder" ]]; then

    cd "$Default_VM_Folder"  || printf "\n\n XDG .desktop starter  >  Default_VM_Folder not found " 

    CurrentFolder="$Default_VM_Folder"

  else

    cd "$HOME"  || printf "\n\n XDG .desktop starter  >  HOME Folder not found " 

    CurrentFolder="$HOME"

  fi

}


[[ $XDG_GeneralDesktopStart ]] &&  function_xdg_start_folder


if [[ $XDG_QcowRightClick ]]; then

  XDG_QcowRightClick_Conf_Dir="$(dirname "$1")"

  XDG_QcowRightClick_DiskName="$(basename "$1")"

  XDG_QcowRightClick_VM_Dir_Name="$(basename "$XDG_QcowRightClick_Conf_Dir")"

  # .desktop starts tend to open in the $HOME folder even if right clicking somewhwere else

  cd "$XDG_QcowRightClick_Conf_Dir" || printf "\n\n XDG .desktop starter  >  Disk's start Folder not found " 

  cd ..  || printf "\n\n XDG .desktop starter  >  Disk's root Folder not found " 

  CurrentFolder="$XDG_QcowRightClick_Conf_Dir"

fi


# Function to create a list of preset VM locations 

function_create_VM_folderList() {

  DefaultFolderError=
  ExtraFolderError=

  # Make sure that 'Default_VM_Folder' has a value and it exists

  [[ ! $Default_VM_Folder ]] && Default_VM_Folder="$CurrentFolder"

  if [[ ! -d "$Default_VM_Folder" ]]; then printf "\n\n  Settings ERROR:  Default Folder NOT found \n\n" ; sleep 2 ; DefaultFolderError=1 ; fi

  
  # set and clear the folder array, current first but don't scan twice

  if [[ "$CurrentFolder" != "$Default_VM_Folder" ]]; then
 
    declare -ga VM_Folder_List=( "$CurrentFolder" "$Default_VM_Folder" )

  else

    declare -ga VM_Folder_List=("$Default_VM_Folder")

  fi


  # shellcheck disable=SC2154

  for xF in "${Extra_VM_Folder[@]}"; do

    [[ $xF ]] && VM_Folder_List+=("$xF")

    if [[ $xF ]] &&  [[ ! -d "$xF" ]] ; then 

      # if .conf targeted start, then no need to print this, 
      # unless re-selecting, in which case the error flag will create a later highlight.
    
      if [[ ! $Conf_TriggerFolder ]]; then 
      
        printf "\n\n  Settings ERROR:\n\n  Extra Folder %s NOT found \n\n"  "$xF" 
        sleep 2 

      fi

      ExtraFolderError=1

    fi

  done

}


# Now populate the list: 

function_create_VM_folderList


# But, if settings need reloading, following a settings edit or a VM deletion:

function_refresh_and_reload_VM_arrays() {

  # NB clear extra folders array

  Extra_VM_Folder=()


  # NB clear pre-set folders array 

  VM_Array=()


  # Re-Read settings file & pre-set folders:

  # shellcheck disable=SC1090

  if [[ $ModName_qqX ]]; then source "$Q_Mod_SettingsFile" ; else source "$Q_Mod_SettingsFile"  QWRAP ; fi

  # make sure other functions know that the settings was was re-read

  SettingsFileAdjusted=1

  # re-load:

  [[ $XDG_GeneralDesktopStart ]] &&  function_xdg_start_folder
 
  function_create_VM_folderList  

  function_scan_VM_folderList  

  check_screen_percentage

  set_drive_paths

  find_main_drive

  # reload screen 

  ByPass_VM_Array_Selector=1

  KVM_MSR_Error=

  ShowUtilsMenu=

  printf "\033c"

  show_qmod_title

}


# Record any set ExtraArgs in case of need to reset

ExtraSetArgs="$ExtraArgs"


#  Add default values, if none supplied

[[ ! $P_Kill_WaitSecs ]] && P_Kill_WaitSecs="20"

P_Kill_WaitSecs_PreSet="$P_Kill_WaitSecs"



#   Check and set the 'quickget' version, which is used in isolated wrapping mode.

#   Quickemu gets absorb wrapped & uses the internal var "$VERSION" as its ref, so use that.

[[ $QE_Version ]] && [[ ! $(type -p "$QE_Version") ]] &&  printf "\n\n  ERROR  quickemu not found \n\n  Re-check Installation &/or Installation instructions \n\n"  && sleep 10         

[[ $QG_Version ]] && [[ ! $(type -p "$QG_Version") ]] &&  printf "\n\n  ERROR  quickget not found \n\n  Re-check Installation &/or Installation instructions \n\n"   && sleep 10         


##  MOD  add checks for 'curl' and 'aria2' 

if [[ ! $(type -p curl) ]] ; then
  echo
  echo "  You should have downloader 'curl' installed to run parts of the quickget script ..."
  echo
  if [[ $1 ]]; then exit 1 ; else read -rp "  [enter] to continue > " ; fi
fi

if [[ ! $(type -p aria2c) ]]; then
  echo
  echo "  You should have downloader 'aria2' installed to run parts of the quickget script ..."
  echo
  if [[ $1 ]]; then exit 1 ; else read -rp "  [enter] to continue > " ; fi
fi

if [[ ! $(type -p zsync) ]]; then
  echo
  echo "  You should have downloader 'zsync' installed to run parts of the quickget script ..."
  echo
  if [[ $1 ]]; then exit 1 ; else read -rp "  [enter] to continue > " ; fi
fi



function quickget {

  # finds the right version for the standard 'quickget' call 

  # quickemu is later as more complex

  if [[ $QG_Version ]]; then  eval command "$QG_Version" " $*"

  else eval command quickget " $*" ; fi
  
}



##  START of new functions that may be used by the menu system (or by Mod API)


#  GENERAL COLOR & THEMING   (see settings)

[[ ! $X_Shade ]] &&  X_Shade="3"

#  Yellow 3 (recommended), Blue 4, Cyan 6 (brighter blue), Red 1

#  https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit

#  https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x405.html

#  if source without declared shade, set default shade

[[ ! $X_Shade ]]  && X_Shade=3


echColor () {

	# for X_Shade see qqX configs

  # deprecated > use printColor 

	if [[ $2 ]] ; then

		if [[ "$1" == "-n" ]] ; then
			tput setaf "$X_Shade"
			echo -n "$2"
			tput sgr0
		else
			tput setaf "$X_Shade"
			echo "$@"          			
			tput sgr0
		fi

	else
		tput setaf "$X_Shade"
		echo "$1"
		tput sgr0
	fi

}


# non-color echo trap, mainly designed to capture the technical output that quickemu doesn't send to log file

printf "\n"  > "/tmp/qqX_echo_output.log"

#

echo () { command echo "$@" | tee -a  "/tmp/qqX_echo_output.log" ; }



printColor () {

	tput setaf "$X_Shade"

	# shellcheck disable=SC2059

	printf "$@"

	tput sgr0

}


## Analyse Current Version  (Latest version is carried out in the updater function)

IFS='.' read -ra qqX_CurrentVer_Arr <<< "$ModVersion"

# qqX_CurrentVer_Arr[0] remains unpadded  (& to the left of the decimal point)

[[ ${#qqX_CurrentVer_Arr[1]} -lt 2 ]] && printf -v qqX_CurrentVer_Arr[1] "%.2d" "${qqX_CurrentVer_Arr[1]}"

[[ ${#qqX_CurrentVer_Arr[2]} -lt 2 ]] && printf -v qqX_CurrentVer_Arr[2] "%.2d" "${qqX_CurrentVer_Arr[2]}"

#legacy 3dp pre "0.09.00.017"

[[ ${#qqX_CurrentVer_Arr[3]} -gt 2 ]] && qqX_CurrentVer_Arr[3]="${qqX_CurrentVer_Arr[3]:(-2)}"

[[ ${#qqX_CurrentVer_Arr[3]} -lt 2 ]] && printf -v qqX_CurrentVer_Arr[3] "%.2d" "${qqX_CurrentVer_Arr[3]}"

qqX_CurrentVer_Float="${qqX_CurrentVer_Arr[0]}.${qqX_CurrentVer_Arr[1]}${qqX_CurrentVer_Arr[2]}${qqX_CurrentVer_Arr[3]}"

if [[ "${qqX_CurrentVer_Arr[3]}" ]] && [[ "${qqX_CurrentVer_Arr[2]}" == "00" ]]; then 

  qqX_CurrentReleaseType="beta"

else qqX_CurrentReleaseType="release"

fi


## General default title:

qqX_title="[quickemu quickget X terminal project] - $qqX_CurrentReleaseType: $ModVersion "



## qqX chrome up  ( runs if ModName == qqX [or qqx] )


function_qqX_logo() {
  
  # deprecated

  echColor "  _    _   \/   "
  echColor " (_|  (_|  /\ "
  echColor "   |.   |.    "
}


function_qqX_printf_logo() {

  # printf version (no end line feed)

  printColor "  _    _   \/   "
  printColor " (_|  (_|  /\ "
  printColor "   |.   |.    "
}


# Variant on   http://www.figlet.org/  -f mini  (-k)   (c)  Alex Genovese


function_qqX_logo_title() {

  # deprecated

  if [[ $1 ]]; then

    qqX_LogoTxt="$1"

  else

    qqX_LogoTxt="$qqX_title"

  fi

  echColor "  _    _   \/   "
  echColor " (_|  (_|  /\ "
  echColor "   |.   |.     $qqX_LogoTxt"

}

function_qqX_printf_logo_title() {

  # printf version (no end line feed & also avoids the quickemu echo trap)

  if [[ $1 ]]; then

    qqX_LogoTxt="$1"

  else

    qqX_LogoTxt="$qqX_title"

  fi

  printColor "\n  _    _   \/   "
  printColor "\n (_|  (_|  /\ "
  printColor "\n   |.   |.     %s"  "$qqX_LogoTxt"

}




show_wrap_CLI_usage () {

  printColor  "\n  Command line Usage %s:  \n\n"    "$ModName"

  printf     "  Either plain %s  or  with parameters  --vm  [path/to/vms-folder/]vm-name.conf   " "$ModName"    

  printf     "\n\n  Scripts not located in /usr/bin should be in the VMs folder or a path should be supplied. "

  printf     "\n\n  Start non /usr/bin with './' eg:  ./%s "  "$ModName" 

  printf     "\n\n  Or by clicking on an edited .conf file:"

  printf     "\n\n  Edit the first line of the .conf to point to %s instead of quickemu"  "$ModName" 

  printf     "\n\n  eg. #!/usr/bin/quickemu --vm  becomes  #!/usr/bin/%s --vm  or similar (VM name not needed)" "$ModName" 

  printf     "\n\n  For more complex CLI usage, try the alternative 'q-mod' script or quickemu itself."
  
  printf     "\n\n  @ 2023/08 qqX will now issue short version numbers on 'qqX --version' "

  #printf     "\n\n"

}


function exit {

  # trap to keep terminal open if started by mouse click  -t secs

  # or to stop sourced quickemu quitting as 'normal' procedure   (tput resets any hidden cursors)

  if [[ $1 == "directly" ]]; then

    tput cnorm

    command exit

  elif [[ $1 ]] && [[ ! $NoExit ]]; then

    printf "\n\n"

    printColor "  ERROR : [Enter] to quit  or [h] to hold terminal open \n\n"
  
    read -rp  "  >  "  -t 30  ExitTrap

    [[ $ExitTrap == "h" ]] &&  printf "\n\n  Holding terminal open  [Enter] to quit  \n\n"  && read -rp "  >  "

    tput cnorm

    # https://unix.stackexchange.com/questions/220330/hide-and-unhide-cursor-with-tput

    command exit "$@"

  fi

  # zero the optional 'exit 1' bypass flag (if it has been set)

  NoExit=

}



## QMOD MSRS FUNCTIONS  (may also be called via the Mod API)  

function_find_kvm_msr_default_and_status () {

  # outputs boths vars 'KVM_MSR_DefaultConf' & 'KVM_MSR_status' with value Y or N 

  # finds and flags if MSRS has a config conflict

  KVM_MSR_Error=
  KVM_MSR_Warn=

  KVM_MSR_status="$(cat /sys/module/kvm/parameters/ignore_msrs)"

  [[ ! $KVM_MSR_ModProbeFile ]] && KVM_MSR_ModProbeFile="/etc/modprobe.d/kvm-quickemu.conf"

  KVM_MSR_DefaultConf="$(cat "$KVM_MSR_ModProbeFile" 2> /dev/null)"

  [[ "$KVM_MSR_DefaultConf" == *'=Y' ]] &&  KVM_MSR_default="Y"

  [[ "$KVM_MSR_DefaultConf" == *'=N' ]] || [[ ! -e "$KVM_MSR_ModProbeFile" ]] &&  KVM_MSR_default="N"

  if [[ $VM_InstanceName ]]; then
  
    if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]] ; then

      if [[ $KVM_MSR_status == "N" ]]; then KVM_MSR_Error=1 ; else KVM_MSR_Error= ; fi

    elif [[ "$VM_InstanceName" != *windows*  ]] &&	[[ "$VM_InstanceName" != *macos*  ]] ; then

      if [[ $KVM_MSR_status == "Y" ]]; then KVM_MSR_Warn=1 ; else KVM_MSR_Warn= ; fi

    fi

  fi
}

print_kvm_status () {

  function_find_kvm_msr_default_and_status

  if [[ $VM_InstanceName ]]; then

    if [[ $KVM_MSR_Warn ]] && [[ $Verbose_MSR_dialog || $MSR_Warnings ]] || [[ ! $MSR_Warnings && $ShowUtilsMenu ]] ; then 
    
    Show_MSR_Warnings=1 ; else Show_MSR_Warnings= ; fi

    if [[ $KVM_MSR_status == "Y" ]] ; then  
    
      [[ $KVM_MSR_Error || $Show_MSR_Warnings ]] && printf "\n  /sys/module/kvm/parameters/ignore_msrs  = Y" 

      if  [[ $KVM_MSR_Error ]]; then  printColor "  ERROR \n" 

      elif [[ $Show_MSR_Warnings ]]; then printf "  WARNING \n" ; fi
      
    else 

      [[ $KVM_MSR_Error || $Show_MSR_Warnings ]] && printf "\n  /sys/module/kvm/parameters/ignore_msrs  = N" 

      if [[ $KVM_MSR_Error ]]; then printColor "  ERROR \n" 

      elif [[ $Show_MSR_Warnings ]] ; then printf "  WARNING \n" ; fi

    fi

  fi

}


toggle_msr_defaults () {

  # Modded & now reversible rewrite of original quickemu's function 'ignore_msrs_always'

  Verbose_MSR_dialog=1

  # https://www.linux-kvm.org/page/Category:Docs

  if [[ ! -d /etc/modprobe.d ]]; then

    printf "\n  ERROR! /etc/modprobe.d was not found. \n\n  See notes, it may be possible to manually create modprobe.d/kvm-quickemu.conf \n\n"

  else

    printColor "\n\n  Configure default, boot-up, KVM behaviour "
    
    printf "for unhandled machine-specific registers"

    printf "\n\n  Normal setting is N (don't ignore) but Windows and MacOS require Y (true) 'ignore' "
    
    function_find_kvm_msr_default_and_status

    printf "\n\n  Status:  /sys/module/kvm/parameters/ignore_msrs = %s   Current Default = %s"   "$KVM_MSR_status"  "$KVM_MSR_default"


    [[ ! $KVM_MSR_ModProbeFile ]] && KVM_MSR_ModProbeFile="/etc/modprobe.d/kvm-quickemu.conf"

    if [[ ! -e "$KVM_MSR_ModProbeFile" ]]; then 

      printf "\n\n  \'%s\'  needs to be created "  "$KVM_MSR_ModProbeFile" 

    fi

    printf "\n\n  [y] to set Y  [n] to set N  [b] to go back \n\n"

    read -rp  "  > "  Set_MSR_defaults

    # set .conf file content & update initramfs in all kernels (y/n or none)

    if [[ $Set_MSR_defaults == "y" ]]; then

      printf "\n\n  Updating 'initramfs' may take a moment or two ... \n\n"

      # As per Martin's solution in original quickemu, needs 'tee' to get this to work, 
      # but route tee's stdout to null to tidy the screen 

      echo "options kvm ignore_msrs=Y" | sudo tee "$KVM_MSR_ModProbeFile" 1> /dev/null
      sudo update-initramfs -k all -u

    elif [[ $Set_MSR_defaults == "n" ]]; then

      printf "\n\n  Updating 'initramfs' may take a moment or two ... \n\n"

      echo "options kvm ignore_msrs=N" | sudo tee "$KVM_MSR_ModProbeFile" 1> /dev/null
      sudo update-initramfs -k all -u

    fi

  fi

}


show_kvm_sudo_security_note () {

  printColor "\n  If you mainly use Windows or Mac VM's then a file '.../modprobe.d/kvm-quickemu.conf' "
  
  printf   "\n\n  can be created to modify the load up settings. %s has a new built in function"  "$ModName"

  printf   "\n\n  that can set this up & also allows future adjustments may be made."
  
  printf   "\n\n  Or it may be carried out manually...  See settings, script & further notes for details."
 
  printColor "\n\n\n  Status:  /sys/module/kvm/parameters/ignore_msrs = %s   Current Default = %s"   "$KVM_MSR_status"  "$KVM_MSR_default"
 
  printf "\n\n  Windows or MacOS should be set to 'Y' "

  printColor "\n\n\n  %s requires 'sudo' permissions to echo true or false to 'ignore_msrs'" "$ModName"
  
  printf   "\n\n  This allows you to create a temporary MSRS status that may be changed at any time,"
  
  printf   "\n\n  allowing you to match the selected guest VM that you want to run."

  
  printColor "\n\n\n  If you have concerns about this script, or about giving elevated permissions, "
  
  printf   "\n\n  then the script should be checked or you should issue these commands manually:"
  
  printf   "\n\n  Open a side terminal, use shift-crtl-c to copy the displayed command & shift-crtl-v to paste it. "
  
  printf   "\n\n  Elevated permissions will then exist only in the side terminal & cease once it is closed. "

  printf   "\n\n  Return to %s & select 'leave as'.  %s will re-read msrs settings & auto-update. "   "$ModName" "$ModName"

  printf   "\n"
  
}


select_msr_config () {

  # MSR_offer normally present if MSRS/OS conflict previously detected, 
  # however, presume selector is being used to change current status  REVIEW 

  # where KVM_MSR_status="$(cat /sys/module/kvm/parameters/ignore_msrs)"

  function_find_kvm_msr_default_and_status

  if [[ $KVM_MSR_status == "Y" ]]; then 

    if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]]; then  MSR_offer="N" 

    else  MSR_offer="neutral" ; fi
    
  else 
  
    MSR_offer="Y" 
    
  fi

  KVM_MSR_selector=

  [[ $KVM_MSR_selector_LoadHelp ]] && show_kvm_sudo_security_note  


  while true ; do

    if [[ $MSR_offer == "Y" ]]; then

      printf "\n\n  Set Y : echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs ? "

      printColor "\n\n  [y] to set Y "

      printf "  [enter]  leave as N"

    elif [[ $MSR_offer == "neutral" ]]; then

      printf "\n\n  Set N : echo 0 | sudo tee /sys/module/kvm/parameters/ignore_msrs ? "

      printf "\n\n  [n] to set N "

      printColor "  [enter]  leave as Y"

    else

      printf "\n\n  Set N : echo 0 | sudo tee /sys/module/kvm/parameters/ignore_msrs ? "

      printColor "\n\n  [n] to set N "

      printf "  [enter]  leave as Y"

    fi
    
    if [[ $KVM_MSR_selector == "h" ]] || [[ $KVM_MSR_selector_LoadHelp ]] ; then printf "   [d] to set the boot defaults \n\n"

    else  printf "   [h] see help  \n\n" 

    fi
    
    read -rp "  >  "  KVM_MSR_selector
    
    printf "\n"

    [[ ! $KVM_MSR_selector ]]  &&  break  

    [[ $KVM_MSR_selector == "y" && $MSR_offer == "N" ]] || [[ $KVM_MSR_selector == "n" && $MSR_offer == "Y" ]] && break

    if [[ $KVM_MSR_selector == "y" ]] || [[ $KVM_MSR_selector == "n" ]]; then   

      # As per Martin's solution in original quickemu, needs 'tee' to get this to work, 
      # but route tee's stdout to null to tidy the screen  

      [[ $KVM_MSR_selector == "y" ]] &&  echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs  1> /dev/null   

      [[ $KVM_MSR_selector == "n" ]] &&  echo 0 | sudo tee /sys/module/kvm/parameters/ignore_msrs  1> /dev/null  

      print_kvm_status

      printColor "\n\n\n  [enter]  to return \n\n"
      read -rp  "  > "

      break

    fi

    if [[ $KVM_MSR_selector == "d" ]]; then

      toggle_msr_defaults  

      if [[ $Set_MSR_defaults == "b" ]]; then 
      
        Set_MSR_defaults= 
        print_kvm_status
        printColor "\n\n\n  Make TEMPORARY setting adjustments to MSRS ?"

      else 
        function_find_kvm_msr_default_and_status
        break 
      fi 

    fi

  done

  KVM_MSR_selector=
  KVM_MSR_selector_LoadHelp=

}

msrs_conflict_check_resolver() {  

  # Do a check ...

  function_find_kvm_msr_default_and_status
    
  # Display & Offer config settings if MSRS/OS CONFLICT exists

  if [[ $KVM_MSR_status == "N" ]] ; then

    # usual system default = N

    if [[ "$VM_InstanceName" == *windows*  ]] ||	[[ "$VM_InstanceName" == *macos*  ]] ; then 

      [[ ! $ByPass_VM_Array_Selector ]] && printf "\033c"
    
      printColor "\n\n  Selected: %s "  "$VM_InstanceName"
      
      printf " 'ignore_msrs' is set & is recommended for Windows and Mac"  

      MSR_offer="Y"

      select_msr_config

      function_find_kvm_msr_default_and_status

      if [[ $KVM_MSR_status == "N" ]]; then KVM_MSR_Error=1 ; else KVM_MSR_Error= ; fi

    fi
    
  else

    #  Status = Y  &  which is only recommended for Windows & Mac 

    if [[ "$VM_InstanceName" != *windows*  ]] &&	[[ "$VM_InstanceName" != *macos*  ]] ; then

      [[ ! $ByPass_VM_Array_Selector ]] && printf "\033c"

      printColor "\n\n  Selected: %s "  "$VM_InstanceName"
    
      printf "\n\n 'ignore_msrs' is set:  can be okay for other OS's but is normally used only with Windows and Mac"  

      MSR_offer="N"

      select_msr_config

      function_find_kvm_msr_default_and_status

      if [[ $KVM_MSR_status == "Y" ]]; then KVM_MSR_Error=1 ; else KVM_MSR_Error= ; fi

    fi

  fi

}

#   End of MSRS functions


##  Start ADD-IN of ORIGINAL quickemu functions & the needed variables

#   Technically, this script absorbs rather than wraps. 

#   The original code remains basically as is but some calls get re-routed via new functions ....


## Load the right version of quickemu  (from settings)

# shellcheck disable=SC2154

if [[ $QE_Version ]]; then QuickEmuSource="$QE_Version" ; else QuickEmuSource="/usr/bin/quickemu" ; fi

# shellcheck disable=SC2154

if [[ ! $(type -p "$QuickEmuSource") ]] ; then

  printf "\n\n  QUICKEMU not found. See https://github.com/quickemu-project/quickemu "

  printColor  "\n\n  ERROR  Settings or Installation FilePath:\n\n  %s \n\n"  "$QuickEmuSource"

  exit  hold

fi


QE_StartFuncsPoint=$(grep -n -m 1 'function' "$QuickEmuSource" | cut -d ':' -f 1)

# grep -n : print line number with the output lines   -m : stop after NUM selected lines

((QE_StartFuncsPoint -= 1))

QE_EOfuncsPoint=$(grep -n '### MAIN' "$QuickEmuSource" | cut -d ':' -f 1)

QE_EOfuncsTrim=$((QE_EOfuncsPoint - QE_StartFuncsPoint -1))

tail +"$QE_StartFuncsPoint" "$QuickEmuSource" | head -"$QE_EOfuncsTrim"  > "/tmp/qmod-functions-temp"

source "/tmp/qmod-functions-temp" 


# Quickemu Variables (set & clear)

QE_VarsEndPoint=$(grep -n '# Take command line arguments' "$QuickEmuSource" | cut -d ':' -f 1)

QE_varsLines=$((QE_VarsEndPoint - QE_EOfuncsPoint))

tail +"$QE_EOfuncsPoint" "$QuickEmuSource" | head -"$QE_varsLines"  > "/tmp/qmod-qe-all-vars-temp"

source "/tmp/qmod-qe-all-vars-temp"


# quickemu_vars have to be cleared before every call to quickemu as the base code is normally set to be run once & exit

# create function to refresh the rewritables

QE_rw_Vars_StartPoint=$(grep -n -m 1 -e 'readonly' "/tmp/qmod-qe-all-vars-temp" | cut -d ':' -f 1)

((QE_rw_Vars_StartPoint -=2))

head -"$QE_rw_Vars_StartPoint" "/tmp/qmod-qe-all-vars-temp"  > "/tmp/qmod-qe-rw-vars-temp"

function clear_quickemu_vars {

  source "/tmp/qmod-qe-rw-vars-temp"

}

clear_quickemu_vars



## Overwrite Original Functions Source, as required

declare -f vm_boot  >  "/tmp/qmod-function-vm_boot-orig-temp"

# shellcheck disable=SC2016

#QE_qemuCallPoint=$(grep -n -m 1 -e '${QEMU} "${args' "/tmp/qmod-function-vm_boot-orig-temp" | cut -d ':' -f 1)

QE_qemuCallPoint=$(grep -n -m 1 -e 'QEMU}" "${SHELL_ARGS' "/tmp/qmod-function-vm_boot-orig-temp" | cut -d ':' -f 1)

QE_vm_bootLength=$(wc -l < "/tmp/qmod-function-vm_boot-orig-temp")

QE_vm_bootCutOff=$((QE_vm_bootLength-QE_qemuCallPoint+1))

#echo "QE_qemuCallPoint  $QE_qemuCallPoint  QE_vm_bootLength  $QE_vm_bootLength  QE_vm_bootCutOff  $QE_vm_bootCutOff  "

declare -f vm_boot  | head -n -"$QE_vm_bootCutOff"  >  "/tmp/qmod-function-vm_boot-temp"


## ADD-IN extra code  ( place between the first EOF line & the brace that closes the tail trimmed boot function, just before the second EOF)

# See https://stackoverflow.com/questions/22697688/how-to-cat-eof-a-file-containing-code     ( NB use escape EOF, not quotes )

cat << \EOF >> "/tmp/qmod-function-vm_boot-temp"

    #  REVIEW can patching in $WinHyperV_RC  & creating a RC reader function be done here ??

    # Show all the compiled qemu & swmtp arguments as a human readable list 
    # both to a log file and to screen   (Args & Args/HW record are defined after the VM selection or re-selection)

    # @2023/08  in qqX, the quickemu screen output now gets logged


    # @2023 the quickemu .sh file gets to be more readable in version 4.8 here:  
    
    # https://github.com/quickemu-project/quickemu/pull/707

    # BUT  sed -i only seems to work in GNU sed  >  fix errored fix here ....  REVIEW 

    #  https://stackoverflow.com/questions/6537490/insert-a-line-at-specific-line-number-with-sed-or-awk#6537587


    # Using $VERSION $VMDIR and other internal quickemu variables  & adding the qqX extra args:

    { printf "\n#  qqX:  This file is NOT used by quickemu to run the VM but it will run it if the script is placed"

      printf "\n\n#  in the calling folder, where the .conf file is located, and it is given execute permission ...\n\n"
    
    } >> "${VMDIR}/${VMNAME}.sh"

    echo "${QEMU}" "${SHELL_ARGS}${ExtraArgs}${SharedDriveArgs}${SecondDriveArgs}" >> "${VMDIR}/${VMNAME}.sh"

    [[ "$(sed --version | head -1)" == *'GNU'* ]] && sed -i -e 's/ -/ \\\n    -/g' "${VMDIR}/${VMNAME}.sh"


    printf   "\n  Present Working Directory:  %s"  "$(pwd)" > "$QemuArgsFile"
    printf "\n\n  Qemu:      %s  %s" "$QEMU" "$QEMU_VER_LONG" >> "$QemuArgsFile"
    printf "\n\n  QuickEmu:  %s" "$VERSION"  >> "$QemuArgsFile"
    printf "\n\n  %s:       %s" "$ModName" "$ModVersion" >> "$QemuArgsFile"
    printf "\n\n  Date:      %s \n" "$(date)" >> "$QemuArgsFile"

    i=0

    while [[ "${args[i]}" ]]; do

      a="${args[i]}"
      if [[ "$a" == -dev* ]]; then printf "\n\n  %s" "$a" >> "$QemuArgsFile"
      elif [[ "$a" == -* ]]; then printf "\n  %s" "$a" >> "$QemuArgsFile" 
      else printf " %s" "$a" >> "$QemuArgsFile"
      fi

      if [[ "$a" == *'(c)'* ]]; then
        a="${a//(/'\('}"
        a="${a//)/"\)"}"
        args[i]="$a"
      fi
      
      # add extra spaces
      args[i]=" $a"

      # add quotes
      # if [[ "$a" != -* ]]; then [[ "$a" != \'* ]] && args[i]='"'"$a"'"' ; fi

      ((i+=1))

    done


    declare -p args > "$VM_Conf_Dir/$VM_InstanceName/Qemu_args_Array.txt" 

    # echo "${args[*]}" >> "$VM_Conf_Dir/$VM_InstanceName/Qemu_args_Array.txt" 


    [[ $ExtraArgs ]] && printf "\n\n  ExtraArgs: %s "  "$ExtraArgs"  >> "$QemuArgsFile"

    [[ $SharedDriveArgs ]] && printf "\n\n  SharedDriveArgs: \n %s "  "$SharedDriveArgs"  >> "$QemuArgsFile"

    [[ $SecondDriveArgs ]] && printf "\n\n  SecondDriveArgs: \n %s "  "$SecondDriveArgs"  >> "$QemuArgsFile"

    if [[ $tpm == "on" ]]; then 
      printf "\n\n\n  Secure Boot:  %s \n\n  %s " "$SWTPM" "${tpm_args[*]}" >> "$QemuArgsFile"
    else    
      printf "\n\n\n  Secure Boot:  Not Set" >> "$QemuArgsFile"
    fi
      printf "\n\n\n"  >> "$QemuArgsFile"

    if [[ $VerboseArgs ]]; then 

      # hold the launch till we have checked the config 
      BreakAtVerboseArgs=
      cat "$QemuArgsFile"
      printColor "  [enter] to continue  [b] to go back \n\n"
      read -rp " >  " BreakAtVerboseArgs
      printf "\n\n"
      [[ $BreakAtVerboseArgs == "b" ]]  && return

    fi


    mapfile -t QE_echo_Arr < "/tmp/qqX_echo_output.log"

    { printf "\nQUICKEMU SCREEN OUTPUT & other ...  \n"

      for Line in "${QE_echo_Arr[@]}"; do

        if [[ "$Line" == *'-name'* ]]; then
        
          printf "\n\n\n$Line"

          printf "\n\n\nNote, the .sh file is NOT used by quickemu to run the VM but it will run it if the script is placed"

          printf "\n\nin the calling folder, where the .conf file is located, and it is given execute permission ..."

        elif [[ "$Line" == *'/usr/bin/env bas'* ]]; then true

        elif [[ ! "$(tr -cd '[:print:]' <<< "$Line")" ]]; then true

        else  printf "\n\n$Line"

        fi

      done
      
      printf "\n\n\n\n"
    
    } >> "$QemuArgsFile"


    ## Tested adding this from quickemu (with correction) for the '(c)' in the MacOS command:

    # The OSK parameter contains parenthesis, they need to be escaped in the shell
    # scripts. The vendor name, Quickemu Project, contains a space. It needs to be
    # double-quoted.
    #SHELL_ARGS="${args[*]}"
    ##SHELL_ARGS="${SHELL_ARGS//\(/\\(}"  # code error here but in practice, in quickemu, it somehow works ...  REVIEW 
    #SHELL_ARGS="${SHELL_ARGS//(/\\(}"
    #SHELL_ARGS="${SHELL_ARGS//)/\\)}"
    #SHELL_ARGS="${SHELL_ARGS//Quickemu Project/\"Quickemu Project\"}"

    ## Not needed here.  Use args mod in the above for-loop instead.


    ##  Make sure we have a record of the virtual hardware that Qemu creates. Especially useful for Windows builds.

    #   See  https://github.com/quickemu-project/quickemu/issues/572#issuecomment-1531348755

    [[ ! -e "$QemuArgsFile" ]] && printColor "\n\n  ERROR QemuArgsFile %s failed to create \n\n"  "$QemuArgsFile" && sleep 3 && exit 1

    [[ ! -e "$QemuVirtHardwareRecord" ]]  &&  cp "$QemuArgsFile"  "$QemuVirtHardwareRecord"

    ## call QEMU  (with any extras, if present)

    #  Remove '-D' switch  https://qemu.readthedocs.io/en/latest/system/invocation.html  > problematic
  
    #"$QEMU  ${args[*]} $ExtraArgs  $SharedDriveArgs  $SecondDriveArgs"  2> "${VMDIR}/${VMNAME}.qemu.error.log" &  

    #"$QEMU  ${SHELL_ARGS[@]}  $ExtraArgs  $SharedDriveArgs  $SecondDriveArgs"  2> "${VMDIR}/${VMNAME}.qemu.error.log" &  
    
    #"$QEMU  ${args[@]}  $ExtraArgs"  2> "${VMDIR}/${VMNAME}.qemu.error.log" &  

    # This one:

    eval "$QEMU"  "${args[*]}"  "$ExtraArgs"  "$SharedDriveArgs"  "$SecondDriveArgs" 2> "${VMDIR}/${VMNAME}.qemu.error.log" &  

    # Control happens in 'function_KillPID_Menu'

  fi
  
}

EOF


## Now add the modded boot code as the new function 'vm_boot'

source "/tmp/qmod-function-vm_boot-temp"


## Add in the standard parameter cases 

tail +"$QE_EOfuncsPoint" "$QuickEmuSource" > "/tmp/qmod-endof-file-temp"

# note ' case' with space or grep picks up "Lowercase" on line 3

QE_StartCasePoint=$(grep -n -m 1 ' case' "/tmp/qmod-endof-file-temp" | cut -d ':' -f 1)

QE_EoCasePoint=$(grep -n -m 1 'esac' "/tmp/qmod-endof-file-temp" | cut -d ':' -f 1)

((QE_EoCasePoint -= (QE_StartCasePoint -1) ))

tail "+$QE_StartCasePoint" "/tmp/qmod-endof-file-temp" | head -"$QE_EoCasePoint"  > "/tmp/qmod-case-temp"


##  Add in the standard actions 

((QE_EoCasePoint += (QE_StartCasePoint +2) ))

QE_vm_bootPoint=$(grep -n -m 1 'vm_boot' "/tmp/qmod-endof-file-temp" | cut -d ':' -f 1)

((QE_vm_bootPoint -= 2))

QE_EoLength=$(wc -l < "/tmp/qmod-endof-file-temp")

QE_BootRemainder=$((QE_EoLength - QE_vm_bootPoint))

tail "+$QE_EoCasePoint" "/tmp/qmod-endof-file-temp" | head -n -"$QE_BootRemainder" > "/tmp/qmod-actions-temp"

tail "+$QE_vm_bootPoint" "/tmp/qmod-endof-file-temp" | head -n -1 > "/tmp/qmod-boot-temp"



function quickemu {      

  # Any calls to quickemu become re-routed to this function instead.

  # Check 'mod' params first, then quickemu's

  # plus quickemu_vars have to be cleared before every call to quickemu as the base code is normally set to be run once & exit

  clear_quickemu_vars


  ## Do a first check for amy qwrap internal commands 

  local FirstParamCount=0

  IFS=' '  read -ra FirstParamsArray <<< "$*"

  # declare -p FirstParamsArray

  # read

  # https://unix.stackexchange.com/questions/50654/function-caller-positional-parameters?rq=1

  while [[ "${FirstParamsArray[$FirstParamCount]}" ]]; do

    for FirstParam in "${FirstParamsArray[@]}"; do

      case "$FirstParam" in
      
        --vm_boot)  
            VM_ExecBoot=1 
            unset "FirstParamsArray[$FirstParamCount]"
            set -- "${FirstParamsArray[@]}"
            # no other cases applicable, move on.
            break
            ;;
        --menu_bypass)
            # used for msr functions below
            unset "FirstParamsArray[$FirstParamCount]"
            set -- "${FirstParamsArray[@]}"          
            shift ;;
        --toggle_msr_defaults)  
            toggle_msr_defaults 
            exit directly ;; 
        --select_msr_config)  
            select_msr_config 
            exit directly ;; 
        --msrs_conflict_check_resolver)  
            msrs_conflict_check_resolver 
            exit directly ;; 
      esac

      ((FirstParamCount+=1))

    done

  done

  ## Source in original or modded-original code

  if [[ -e "/tmp/qmod-case-temp" ]] && [[ -e "/tmp/qmod-actions-temp" ]] && [[ -e "/tmp/qmod-boot-temp" ]]; then
    
    while [[ $1 ]]; do

      source "/tmp/qmod-case-temp"  

    done  

    # after read, remove any leftover params not cleared due to trapped exit re-route 

    # & if not yet given, decide on action   

    #  https://unix.stackexchange.com/questions/18981/how-to-unset-the-positional-parameters

    shift  $#

    source "/tmp/qmod-actions-temp"  


    if [[ $VM_ExecBoot ]]; then

      # In the modded version, functions such as snapshots no longer exit. We need to make sure that 
      # unless flagged to do so, quickemu doesn't carry on to run the vm boot

      source "/tmp/qmod-boot-temp" 

      VM_ExecBoot=

    fi

  else

    printColor "\n\n ERROR %s restart needed \n\n"  "$ModName"

    sleep 5

  fi

}


# Temps usually get removed with reboot 

# BUT can get removed by time (eg 24hrs) so check they are there still ( REVIEW  if causes problems )

# See https://serverfault.com/questions/377348/when-does-tmp-get-cleared#377349




## The quick EMU/GET version numbers, now that rerouting functions quickemu & quickget are in place & code has been sourced

QG_VerNumber="$(quickget "--version")"

# Quick EMU uses its internal var '$VERSION'

QE_VerNumber="$VERSION"

# Also create integer version number which is easy to process eg 4.8 becomes 48 & makes possible tests such as if [[ -gt 48 ]] 

QE_Ver_Integer=${QE_VerNumber/./}



##  From quickemu 4.8 onwards, the value " --screenpct xx"  may be used on SDL, where xx is a value from 25 to 100  & Linux VM's only.

#  Runnning this when loading the main menu, and after a VM has been selected, enables individual per .conf values, as well as default

function check_screen_percentage {

  SDL_ScreenPercent=

  SDL_ScrnPcnt_Cmd=

  if [[ $VM_Conf_File ]]; then

    eval "$(grep -s Custom_SDL_ScreenPercent "$VM_Conf_File")"

    [[ $Custom_SDL_ScreenPercent ]] && SDL_ScreenPercent="$Custom_SDL_ScreenPercent"

  fi

  if [[ ! $SDL_ScreenPercent ]]; then

    [[ $Default_SDL_ScreenPercent ]] && SDL_ScreenPercent="$Default_SDL_ScreenPercent"

  fi

  if [[ $SDL_ScreenPercent ]]; then

    SDL_ScrnPcnt_Error=

    if (( 24 < SDL_ScreenPercent && SDL_ScreenPercent < 101 )); then

      if [[ $QE_Ver_Integer -ge "48" ]]; then 
      
        SDL_ScrnPcnt_Cmd=" --screenpct  $SDL_ScreenPercent"

      else

        printf "\033c"
        printColor "\n\n  ERROR  SDL_ScreenPercent needs quickemu 4.8+ \n\n "
        sleep 3
        SDL_ScrnPcnt_Error="Quickemu Version"

      fi

    else
      
      printf "\033c"
      printColor "\n\n  ERROR  SDL_ScreenPercent = %s  Range is 25 to 100 \n\n "  "$SDL_ScreenPercent"
      sleep 3
      SDL_ScrnPcnt_Error="Out of Range"

    fi

  fi

}  



function set_drive_paths {

  #  For a SECOND/SHARED DRIVE (thanks @gnudoc on the quickemu Discord channel)  do "qemu-img create -f qcow2 disk2.qcow2 40G"  or as required

  #  Set  ExtraArgs=" -device virtio-blk-pci,drive=SharedDrive -drive id=SharedDrive,if=none,format=qcow2,file=/vm_folder/disk2.qcow2"  

  #  Edit path & boot a VM.  Use 'Disks'  Gparted or similar to find, format and mount.  

  #  The function needs to be run everytime a different VM is selected to allow for individual VM settings or requirements.


  #  Older versions of MacOS require a non pci set up. See quickemu script "Qemu optimisations based on the macOS release" 

  #  Any OS older than and including 10.13 Mojave 2018 should have a flag in the .conf file > MacLegacyDrive="true"

  #  See https://en.wikipedia.org/wiki/MacOS_version_history


  #  SECOND DRIVE and .conf file

  #  Drive path to be individually set in the .conf file on a per VM basis.  

  SecondDrive=
  SharedDrive=
  SharedDrive_Conf=
  SecondDriveArgs=
  SharedDriveArgs=
  MacLegacyDrive=

  if [[ $VM_Conf_File ]]; then

    eval "$(grep -s MacLegacyDrive "$VM_Conf_File")"

    if [[ $MacLegacyDrive == "true" ]]; then  BusType="ide-hd,bus=ahci.2" 
          
    else BusType="virtio-blk-pci"; fi

    #  SECOND DRIVE 

    #  Drive path to be individually set in the .conf file on a per VM basis.  

    eval "$(grep -s SecondDrive "$VM_Conf_File")"

    if [[ -e "$SecondDrive" ]]; then

      SecondDriveArgs=" -device ${BusType},drive=SecondDrive -drive id=SecondDrive,if=none,format=qcow2,file=$SecondDrive"  

    elif [[ $SecondDrive ]]; then 
      
      printf "\n\n ERROR SecondDrive NOT found"

      printf "\n\n  %s \n\n"  "$SecondDrive"

      sleep 1.4

    fi

  fi

  #  SHARED DRIVE

  #  This drive should be availble to all VMs and act as a shared resource.  See main settings.

  if [[ $(grep -s 'SharedDrive=' "$Q_Mod_SettingsFile" | grep -v '#' | grep -c 'SharedDrive') == 1 ]]; then

      eval "$(grep -s 'SharedDrive=' "$Q_Mod_SettingsFile" | grep -v '#' )"

  fi

  if [[ $SharedDrive ]]; then 

    eval "$(grep -s SharedDrive_Conf "$VM_Conf_File")"

    if [[ $MacLegacyDrive ]] || [[ $SharedDrive_Conf ==  "no-shared" ]]; then 

      SharedDrive=
      SharedDriveArgs=

    elif [[ -e "$SharedDrive" ]]; then

      [[ ! $BusType ]] && BusType="virtio-blk-pci"

      SharedDriveArgs=" -device ${BusType},drive=SharedDrive -drive id=SharedDrive,if=none,format=qcow2,file=$SharedDrive"  

    elif [[ $SharedDrive ]]; then 

      printf "\n\n ERROR SharedDrive NOT found"

      printf "\n\n  %s \n\n"  "$SharedDrive"

      sleep 1.4

    fi

  fi

}  


## MAIN DRIVE

#  Drive path to be individually set in the .conf file on a per VM basis.  

#  The function needs to be run everytime a different VM is selected.

#  Added so we can distinguish between different drives for snapshots.

#  Finds the quickemu var 'disk_img' which is the main drive 'disk.qcow2' 

function find_main_drive {

  MainDrive=
  disk_img=

  if [[ $VM_Conf_File ]]; then

    eval "$(grep disk_img "$VM_Conf_File" 2>/dev/null)"

    if [[ -e "$disk_img" ]]; then

      MainDrive="$disk_img"

    else
      
      printf "\n\n  Main Drive NOT found (yet)  >  Start VM (to create one)"

      printf "\n\n  %s \n\n"  "$disk_img"

      sleep 1.4

    fi

  fi

}  



##  WRAPPING FUNCTIONS FOR 'quickget' 


print_quickget_choices () {

  # listing function for use inside 'function_quick_get_wrap'

  # adapted with $2 as number per line

  declare -n QGW_List_ArrName="$1"

  if [[ $2 ]]; then QGW_List_NewLinePoint="$2"; else QGW_List_NewLinePoint="6"; fi

  QGW_List_ArrNum=0

  QGW_List_DisplayNum=1

  QGW_List_NewLineCounter=1

  for QGW_List_Arr_Item in "${QGW_List_ArrName[@]}" ; do

    printf "  %2d)  %-18s  "  "$QGW_List_DisplayNum"  "$QGW_List_Arr_Item"

    ((QGW_List_ArrNum+=1))

    ((QGW_List_DisplayNum+=1))

    ((QGW_List_NewLineCounter+=1))

    [[ $QGW_List_NewLineCounter == "$QGW_List_NewLinePoint" ]] &&  QGW_List_NewLineCounter=1   &&  printf "\n\n"

  done

}


function_quick_get_wrap ()  {

  printf "\033c"

  if [[ $ModName_qqX ]]; then 

    # printf "\n"
  
    function_qqX_printf_logo_title "$ModVersion"

  else 
  
    printColor "\n\n  %s  ver %s"  "$ModName"  "$ModVersion"

  fi

  
  # shellcheck disable=SC2154

  printf "  Wrapping quickget version %s  (needs internet, including some selectors) \n\n\n" "$QG_VerNumber"
 
  tput sc
  echo 
  echo "  Checking connections ..." ; echo

  InternetUp=
  Test_Internet=

  while [[ ! $InternetUp ]]; do   

    if  ( ping -w 2  1.1.1.1 | grep -q ttl ) 2> /dev/null ; then

      InternetUp=1

    elif wget -q -T2 -t2 --spider 1.1.1.1  2> /dev/null ; then
    
      InternetUp=1

    elif wget -q -T2 -t2 --spider cloudflare.com  2> /dev/null ; then

      InternetUp=1

    elif wget -q -T2 -t2 --spider google.com 2> /dev/null ; then

      InternetUp=1

    elif ( ping -w 2  8.8.8.8  | grep -q ttl ) 2> /dev/null ; then

      InternetUp=1    
      
    else

      printColor "\n\n  INTERNET CONNECTION NOT FOUND. Check settings and equipment \n\n"

      printf "\n\n  [enter] to re-test,  [i] ignore, continue anyway  [b] back to main menu"

      read -rp "   >  "   Test_Internet

      echo

      [[ $Test_Internet == "b" ]] &&  QGW_List_NumSelected="b"  && break   

      [[ $Test_Internet == "i" ]] &&  break   

    fi

  done


  if [[ $Zsync_Updatable_ISO && $Zsync_OS_Name && $Zsync_Release_Name ]] ; then  

    QGW_OS_Arr_NameSelected="$Zsync_OS_Name"

    QGW_Release_Arr_NameSelected="$Zsync_Release_Name"

  else

    tput rc; tput ed  

    QGW_OS_ListRaw="$(quickget | tail -n +2 )"

    QGW_OS_ListString="${QGW_OS_ListRaw/'- Operating Systems: '/}"

    read -ra QGW_OS_Array <<< "$QGW_OS_ListString"

    print_quickget_choices  "QGW_OS_Array"

    printColor "\n\n\n  Give list NUMBER of OS name to select for download  [b] to go back \n\n"    

    read -rp "  >  "  QGW_List_NumSelected


    if [[ $QGW_List_NumSelected == "b" ]]; then 
    
      QGW_List_NumSelected=

      return

    else

      [[ $QGW_List_NumSelected -gt "${#QGW_OS_Array[@]}" ]] && QGW_List_NumSelected="${#QGW_OS_Array[@]}"

      QGW_OS_Arr_NumSelected=$((QGW_List_NumSelected-1))

      QGW_OS_Arr_NameSelected="${QGW_OS_Array[QGW_OS_Arr_NumSelected]}"

      printColor  "\n\n  Selected = %s "  "$QGW_OS_Arr_NameSelected"

    fi

    #

    QGW_Releases_ListRaw="$(quickget "$QGW_OS_Arr_NameSelected" | tail -n +2 | grep Releases)"

    QGW_Releases_ListString="${QGW_Releases_ListRaw/'- Releases: '/}"

    read -ra QGW_Releases_Array <<< "$QGW_Releases_ListString"


    if [[ ${#QGW_Releases_Array[@]} -eq 1 ]] ; then

    printf "\n\n  Only one current release found: "

    QGW_Release_Arr_NameSelected="${QGW_Releases_Array[0]}"

    else

      printf "\n\n"

      print_quickget_choices  "QGW_Releases_Array"

      printColor "\n\n  Give LIST number of Release   [b] to go back \n\n"     

      read -rp "  >  "  QGW_List_NumSelected    

      if [[ $QGW_List_NumSelected == "b" ]]; then 

        QGW_List_NumSelected= 

        QGW_OS_Arr_NameSelected=
      
        function_quick_get_wrap

      else

        [[ $QGW_List_NumSelected -gt "${#QGW_Releases_Array[@]}" ]] && QGW_List_NumSelected="${#QGW_Releases_Array[@]}"

        QGW_Release_Arr_NumSelected=$((QGW_List_NumSelected-1))

        QGW_Release_Arr_NameSelected="${QGW_Releases_Array[QGW_Release_Arr_NumSelected]}"

      fi

    fi

    printColor  "\n\n  Selected = %s %s "  "$QGW_OS_Arr_NameSelected" "$QGW_Release_Arr_NameSelected"

    #

    QGW_Editions_ListRaw="$(quickget "$QGW_OS_Arr_NameSelected" | tail -n +2 | grep Editions)"

    QGW_Editions_ListString="${QGW_Editions_ListRaw/'- Editions: '/}"

    QGW_Editions_ListTest="$(tr -d '[:space:]' <<< "$QGW_Editions_ListString" )"

    if [[ $QGW_Editions_ListTest ]]; then

      read -ra QGW_Editions_Array <<< "$QGW_Editions_ListString"

      if [[ ${#QGW_Editions_Array[@]} -eq 1 ]] ; then

      printf "\n\n  Only one current edition found: "

      QGW_Edition_Arr_NameSelected="${QGW_Editions_Array[0]}"

      else

        printf "\n\n"

        print_quickget_choices  "QGW_Editions_Array"

        printColor "\n\n  Give LIST number of Edition   [b] to go back \n\n"  

        if [[ $QGW_OS_Arr_NameSelected == "fedora" ]]  && [[ $QGW_Release_Arr_NameSelected == "33" ]] || [[ $QGW_Release_Arr_NameSelected == "34" ]]; then 
        
          printf "  Note: Fedora 33 i3 and Fedora 34 Cinnamon are not possible \n\n"

        fi

        read -rp "  >  "  QGW_List_NumSelected   

        if [[ $QGW_List_NumSelected == "b" ]]; then  

          QGW_List_NumSelected=
          QGW_OS_Arr_NameSelected=
          QGW_Release_Arr_NameSelected=
        
          function_quick_get_wrap

        else

          [[ $QGW_List_NumSelected -gt "${#QGW_Editions_Array[@]}" ]] && QGW_List_NumSelected="${#QGW_Editions_Array[@]}"
      
          QGW_Edition_Arr_NumSelected=$((QGW_List_NumSelected-1))

          QGW_Edition_Arr_NameSelected="${QGW_Editions_Array[QGW_Edition_Arr_NumSelected]}"

        fi

      fi

    else

      QGW_Edition_Arr_NameSelected=

      printf "\n\n  Further selection not available"

    fi

  fi


  QGW_DownloadSelection="$QGW_OS_Arr_NameSelected  $QGW_Release_Arr_NameSelected  $QGW_Edition_Arr_NameSelected"

  if [[ $QGW_Edition_Arr_NameSelected ]]; then

    QGW_DownloadName="${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}-${QGW_Edition_Arr_NameSelected}"

  elif [[ $QGW_Release_Arr_NameSelected ]]; then

    QGW_DownloadName="${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}"

  else

    QGW_DownloadName="${QGW_OS_Arr_NameSelected}"

  fi 
  
  printColor  "\n\n  Selected =   %s "  "$QGW_DownloadSelection"


  if [[ $Zsync_Updatable_ISO ]]; then

    if [[ ! $Zsync_OS_Name || ! $Zsync_Release_Name  ]]; then

      printColor "\n\n  ERROR  Variables for OS Name &/or Release NOT found \n\n"

    else

      printf "\n\n  Updating the live boot development iso with any changes"

      printColor "\n\n  May take a while to synchronise"

      [[ $LastZsync -gt 200000 ]] && printColor " - last updated over %d days ago"  "$((LastZsync/86400))"

      printf "\n\n"

      ZsyncDownload=1

    fi

  elif [[ "$QGW_DownloadSelection" == *'ubuntu'* ]] && [[ "$QGW_DownloadSelection" == *'daily'* ]]; then 
  
    printColor "  ** may download with some kind of NAMING variance ** "

    ZsyncDownload=1

  else

    ZsyncDownload=

  fi

  function show_current_preset_folder_list {

    i=0

    printf "\n"

    while [[ ${VM_Folder_List[i]} ]]; do

      if [[ $i -eq 0 ]]; then printf "\n\n  [0]  %s (current)"  "${VM_Folder_List[i]}"

      elif [[ $i -eq 1 ]]; then printf "\n\n  [1]  %s (default)"  "${VM_Folder_List[i]}"

      else printf "\n\n  [%s]  %s "  "$i" "${VM_Folder_List[i]}"

      fi

      ((i +=1))

    done

  }


  if [[ $Zsync_Updatable_ISO && $Zsync_OS_Name ]]; then 

      QWG_DownLoadFolder="$VM_Conf_Dir"

  else

    show_current_preset_folder_list

    printf "\n\n\n"

    QWG_DownLoadFolder="$Default_VM_Folder"

  fi

  #####  Start Download  ####

  QGW_OverWriteAllow=
  
  while true ; do

    printf "  Installation target folder:  %s "   "$QWG_DownLoadFolder"  

    # If not sync updating, list other copies of similar VM's in the target folder

    if [[ ! $Zsync_Updatable_ISO ]]; then

      SimilarVMs=
      SimilarVM_ShorterCheck=
      QGW_OverWrite=
      DailyVMsPresent=

      if [[ -e "$QWG_DownLoadFolder/$QGW_DownloadName" ]]; then

        printColor "\n\n  ERROR?  VM's is already present? "

        printf "\n\n  %s / %s "    "$QWG_DownLoadFolder" "$QGW_DownloadName"

        [[ ! $QGW_OverWriteAllow ]] && QGW_OverWrite=1
        
      else

        declare -a SimilarVM_Arr
       
        SimilarVMs="$(ls "$QWG_DownLoadFolder/${QGW_OS_Arr_NameSelected}"*.conf 2>/dev/null )"

        if [[ ! $SimilarVMs ]] && [[ "$QGW_OS_Arr_NameSelected" == *'-'* ]]; then 
        
          SimilarVM_ShorterCheck="$(echo "$QGW_OS_Arr_NameSelected" | cut -d '-' -f1)"

          SimilarVMs="$(ls "$QWG_DownLoadFolder/${SimilarVM_ShorterCheck}"*.conf 2>/dev/null )"

        fi

        [[ $SimilarVMs ]] &&  mapfile -t  SimilarVM_Arr  <<< "$SimilarVMs"

        if [[ ${SimilarVM_Arr[*]} ]]; then  

          for DailyCheckVM in "${SimilarVM_Arr[@]}" ; do

            [[ "$DailyCheckVM" == *'daily'* ]] && DailyVMsPresent=1

          done

          printColor "\n\n   %s  >>  Similar VM's are present: \n\n"  "$QGW_DownloadName"
        
          print_quickget_choices  "SimilarVM_Arr" 3

          # Request second confirmation, if similar && if daily live, as daily live can be from different download name 

          [[ $DailyVMsPresent ]] && [[ ! $QGW_OverWriteAllow ]] && QGW_OverWrite=1

        fi

      fi

    fi


    if [[ $QGW_OverWriteAllow ]];then  

      printColor  "\n\n\n  Installation target folder:  %s"  "$QWG_DownLoadFolder"
      
      show_current_preset_folder_list
    
      printf  "\n\n  [enter] Start the download  "

      printColor " ?? BACKUP > " 
    
    else  printColor  "\n\n  [enter] Start the download  " 
    
    fi
    
    if [[ ! $Zsync_Updatable_ISO ]]; then

      if [[ $QGW_OverWriteAllow ]]; then printf "[number] select a DIFFERENT FOLDER  "

      else printColor "[number] select a different (preset or current) folder  "

      fi

    fi
    
    printColor "[h] help  [b] go back \n\n\n"

    read -rp "  >  " QGW_DownloadStart

     printf "\n"

     case "$QGW_DownloadStart" in

      b)
        QGW_List_NumSelected=
        QGW_OS_Arr_NameSelected=
        QGW_Release_Arr_NameSelected=
        QGW_DownloadStart=
        QGW_DownloadSelection=

        function_quick_get_wrap

        break
      ;;


      0|1|2|3) QWG_DownLoadFolder="${VM_Folder_List[QGW_DownloadStart]}" 
      
      ;;

      h)  
          printf "\n\n  Once the download and initial setup up has finished, the new folder and .conf file may be easily moved"
          printf "\n\n  and/or edited before running. Part downloads can usually be re-started, if stopped."
          printf "\n\n  Zsync Iso Updates may leave residual rcksum files, if stopped, and may need removing."
          printf "\n\n  But, if an iso.part file has been started, a restart is possible, after doing a re-sync."
          printf "\n\n  If re-syncing, the rcksum files will be auto-removed."
      ;;

      *)
        if [[ $QGW_OverWrite ]]; then 

          printf "  RECONFIRMATION is required  >>  %s"  "$QGW_DownloadName"

          printColor " \n\n  ** may install with some kind of NAMING variance **  \n\n"

          QGW_OverWriteAllow=1

        else

          QGW_DownloadStart="start"
          break

        fi
      ;;

    esac

    [[ ! $QWG_DownLoadFolder ]] &&  QWG_DownLoadFolder="$Default_VM_Folder" 

  done


  if [[ $QGW_DownloadStart == "start" ]]; then

    QGW_DownloadStart=
    QGW_DownloadStopped=
    
    cd "$QWG_DownLoadFolder"  ||  function_conf_error  "FOLDER not accessible: $QWG_DownLoadFolder"

    if [[ $Zsync_Updatable_ISO ]]; then

      printf "  If stopped, Zsync Iso Updates may leave residual rcksum files that %s will remove."  "$ModName"

      printf "\n\n  To resume stopped downloads, any .iso.part files should be retained."

      # https://bugs.launchpad.net/ubuntu/+source/zsync/+bug/477551

      function remove_old_rcksum_files {

        if [[ $(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null) ]]; then

          mapfile -t RckSumArray <<< "$(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null)"

          for RckItem in "${RckSumArray[@]}"; do

            rm "$RckItem"

          done

        fi

      }

      remove_old_rcksum_files

    else

      printf "\n  Once a download and initial setup up has finished, the new folder and .conf file may be easily moved"
      printf "\n\n  and/or edited before running. Part downloads can usually be re-started, if stopped >> "

    fi

    
    if [[ $ZsyncDownload ]]; then  printf "\n\n" ; else printColor "  %s \n\n" "$QGW_DownloadName" ; fi


    printColor "\n\n  Press [enter] at finish  or  [enter] to STOP ALL current downloads & zsync"

    printf "\n\n  Quickemu & downloader output: "


    ## Although quickget will run as a background process, quickget will then go on to run aria2 etc 

    #  but as even further into the background. The download programs will grab the cursor in order to report progress
    
    #  and as this will compete with read & keyboard input we are limited to using [enter] ....


    #  quickget will also run a python3 command for macrecovery for MacOS 

    #  eg 26102 pts/1    S+     0:11 python3 /usr/bin/macrecovery --board-id Mac-00BE6ED71E35EB86 --mlb 00000000000000000 --os-type default --basename Recover

   
  
   
    # QUICKGET RUNS FIRST, in the background, then it starts a downloader 

    quickget "$QGW_DownloadSelection" &  


    printf "\n\n\n\n\n"

    #  move the cursor   "\e[1A\r"  "\e[2K\r"  etc    See https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797

    printf "\e[3A\r"

    sleep 2

    if [[ $Zsync_Updatable_ISO ]]; then 

      while [[ ! $(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null) ]]; do  sleep 2 ; done
        
    fi

    function show_rcksum_progress {

      RckFile="$(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null)"

      while [[ -e "$RckFile" ]]; do
        
        RckFile="$(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null)"

        RckDone="$(du -a "$RckFile" 2> /dev/null)"
        RckDone="${RckDone/"$RckFile"/}"

        # gives some kind of rough indication that work is in progress  (percentages don't seem to be possible)

        printf "  Synchronising  %s "  "$RckDone" 

        sleep 2

        printf "\e[2K\r"

      done
      
    }



    while true ; do

      if [[ $(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null) ]]; then 
      
        show_rcksum_progress &
       
      fi
     
      mapfile -t  Jobs_Arr <<< "$(jobs -p)"


      # waits here for an [enter] to finish :

      read -r 


      for Jobs_PID in "${Jobs_Arr[@]}" ; do

        kill "$Jobs_PID" 2> /dev/null

      done


      # removing the old rcksum files not only tidies up but also stops the background monitor process

      [[ $(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null) ]] && remove_old_rcksum_files

      
      # check macOS particularities

      P3_Arr=()

      mapfile -t  P3_Arr <<< "$(pgrep python3)"

      for P3_PID in "${P3_Arr[@]}" ; do

        P3_MacOS_Cmd="$(ps --no-headers -o cmd "$P3_PID" 2> /dev/null)" 
      
        if [[ "$P3_MacOS_Cmd" == *'/usr/bin/macrecovery'* ]]; then 
        
          kill "$P3_PID" 2> /dev/null
          
          printColor "\n\nStopped \n\n" 
          QGW_DownloadStopped=1
          break

        fi

      done


      if [[ $(pgrep aria2) || $(pgrep curl) || $(pgrep wget) || $(pgrep zsync) ]]; then

        while true; do 

          pkill aria2  2> /dev/null
          pkill curl   2> /dev/null
          pkill wget   2> /dev/null
          pkill zsync  2> /dev/null

          sleep 2

          if [[ ! $(pgrep aria2) && ! $(pgrep curl) && ! $(pgrep wget) && ! $(pgrep zsync) ]]; then

            QGW_DownloadStopped=1

            sleep 2 ; break

          fi

        done

      fi

      break

    done

  fi

  # variable sleep/pauses needed to give different processes time to output their summaries & finish up

  sleep 1


  New_VM_Folder=

  New_VM_File=

  if [[ ! $ZsyncDownload ]]; then

    if [[ -d "${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}-${QGW_Edition_Arr_NameSelected}" ]]; then 

      New_VM_Folder="${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}-${QGW_Edition_Arr_NameSelected}"

    elif [[ -d "${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}" ]]; then 

      New_VM_Folder="${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}"

    elif [[ -d "${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}" ]]; then 

      New_VM_Folder="${QGW_OS_Arr_NameSelected}"

    fi

    if [[ -f "${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}.conf" ]]; then 

      New_VM_File="${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}.conf"

    elif [[ -f "${QWG_DownLoadFolder}/${QGW_OS_Arr_NameSelected}.conf" ]]; then 

      New_VM_File="${QGW_OS_Arr_NameSelected}.conf"

    fi

  fi


  QGW_FolderDelete=

  if  [[ $ZsyncDownload ]]; then

    if [[ $QGW_DownloadStopped ]]; then 
    
      printf "\n\n  Download Stopped > Residual files may be present"
      printf "\n\n  Removal of any residual files & folders has to be completed manually"

      if [[ $Zsync_Updatable_ISO ]]; then

        printf "\n\n  Part downloads can usually be re-started if the .iso.part file is retained."

      else

        printf "\n\n  Part downloads can usually be re-started if the folder is retained."
        printf "\n\n  Dev downloads usually undergo some kind of NAMING variance"

      fi

    else  
    
      printf "\n\n  Hopefully all completed  ..." 

      # Note (@2023/07) that quickget includes code to remove 'zs.old' files, which may or may not have been needed,
          
      # but Zsync can now give these files root protection so this removal may not work ...   REVIEW  Add a qqX copying mechanism? 

      if [[ ! $Zsync_Updatable_ISO ]]; then  
      
        printf "\n\n  as Dev downloads usually undergo some kind of NAMING variance" 

        printf "\n\n  checking of files & folders should to be completed manually"

      fi
      
    fi

    ZsyncDownload=


  elif [[ $New_VM_Folder ]]; then
  
    printColor "\n   Folder created:     %s "  "$New_VM_Folder"

    [[ $New_VM_File ]] && printColor "\n  .conf file created:  %s "  "$(basename "$New_VM_File")"

    if [[ ! $New_VM_File ]] || [[ $QGW_DownloadStopped ]]; then

      if [[ $QGW_DownloadStopped ]]; then
     
        printf "\n\n  Download Stopped > Residual files are present"

        printf "\n\n  Part downloads can usually be re-started if the folder is retained."

      fi
    
      [[ ! $New_VM_File ]] && printf "\n\n  As there is no .conf file, there may have been an ERROR >" 


      printColor "\n\n  Folder contents: \n\n"

      ls "$New_VM_Folder"

      printColor "\n\n  [d] delete the folder" 

      [[ $New_VM_File ]] && printColor " and .conf" 

      printf "  [enter] to retain & continue "

      printf "\n\n\n"

      read -rp "  >  "    QGW_FolderDelete

      if [[ $QGW_FolderDelete == "d" ]]; then
      
        printf "\n  Folder/file being deleted ... "

        rm -f -r "$New_VM_Folder"

        rm -f "$New_VM_File"

      else  printf  "  Folder/file retained"

      fi

    fi

  fi


  QGW_ConfEdit=

  if [[ $New_VM_File ]] && [[ ! $QGW_DownloadStopped ]]; then

    printColor "\n\n  CHECK ME: \n\n"

    cat "$New_VM_File"

    printColor "\n\n  So far, so good  >  "

    printf "\n\n  The start line may be edited to point to %s"  "$ModName"

    QGW_ConfEdit_DiskSize=

    QGW_ConfEdit_Qstart=

    printColor "\n\n  Change the start line to point to %s ?"  "$ModName"

    printf "\n\n  [enter] yes, go for it    [no] maybe not ... \n\n"

    read -rp "  >  "  QGW_ConfEdit_Qstart

    if [[ $QGW_ConfEdit_Qstart != "no" ]]; then

      tail +2  "$New_VM_File" > "/tmp/New_VM_File.temp"

      printf "#!/usr/bin/%s --vm \n" "$ModName"   > "$New_VM_File"

      cat "/tmp/New_VM_File.temp" >> "$New_VM_File"

    fi

    printColor "\n\n  Suggest adding disk_size=\"64G\" or higher if expecting to create snapshots: " 

    printf "\n\n  qcow2 disks auto-compress & will normally occupy much less space"
    
    printColor "\n\n  & an empty disk only takes up 196k."
    
    printf "\n\n  It is easier make them larger now than to resize later ... " 

    printf  "\n\n\n  [enter] 128G  or  [number] in Gb 32, 64, 192   [no] leave as possibly sub-minimal"  

    printf "\n\n"

    read -rp  "  >  "  QGW_ConfEdit_DiskSize

    [[ ! $QGW_ConfEdit_DiskSize ]]  && QGW_ConfEdit_DiskSize="128"

    [[ $QGW_ConfEdit_DiskSize ]]  &&  QGW_ConfEdit_DiskSize="$(tr -cd "[:digit:]" <<< "$QGW_ConfEdit_DiskSize")"

    if [[ $QGW_ConfEdit_DiskSize ]]; then 
    
      printf "disk_size=\"%sG\"\n"  "$QGW_ConfEdit_DiskSize"  >> "$New_VM_File"

    fi


    # add cores menu  (using code from ffX project ...)

    if [[ $(type -p lscpu) ]]; then

      CoresAvail=$(lscpu | grep "Core(s) per socket:" | tr -cd "[:digit:]")

      SocketsAvail=$(lscpu | grep "Socket(s):" | tr -cd "[:digit:]")   #  REVIEW  for dual cpu mobo (untested)

      CoresAvail=$((SocketsAvail*CoresAvail))

      # CoresAvail=2

      ThreadsPerCoreAvail=$(lscpu | grep "Thread(s) per core:" | tr -cd "[:digit:]")      #  REVIEW  

      ThreadsAvailable=$((ThreadsPerCoreAvail*CoresAvail))

      ThreadsSuggested=$(echo "scale=0; ((($ThreadsAvailable*3)/4)+0.5)/1" | bc 2>/dev/null )

      #  Use 'modulo' to detect odd/even   See: https://stackoverflow.com/a/15660039  

      [[ "$(( ThreadsSuggested % 2 ))" == "1" ]] && (( ThreadsSuggested +=1 ))

      ThreadsSuggestLower=$(echo "scale=0; ((($ThreadsAvailable*2)/3)+0.5)/1" | bc 2>/dev/null )

      [[ "$(( ThreadsSuggestLower % 2 ))" == "1" ]] && (( ThreadsSuggestLower +=1 ))

    fi

    printf "\n\n"

    [[ $ThreadsAvailable ]] && printColor "  You have %s 'cores' available  (actual cores, or cores x threads) \n\n" "$ThreadsAvailable"

    [[ $ThreadsSuggested ]] && printf "  Suggested setting:  cpu_cores=\"%s\"  or  cpu_cores=\"%s\"\n\n" "$ThreadsSuggested"  "$ThreadsSuggestLower"

    printColor "  All available 'cores x threads' may be allocated, esp. if running the VM full screen"

    printf "\n\n  Quickemu defaults to safe half, minimals ..."

    printf "\n\n  Normal guest setting should be at least 2/3 to 3/4 of the host."
    
    printf "\n\n  Remember, this is the maximum-allowed number. Be generous as less will actually be used."
    
    printf "\n\n  Your host CPU's microcode & virtualization units will have the final say ...."

    CoresSetNumber=

    printColor "\n\n  Give [integer] to set max (even numbers are usual)  [enter] to use defaults  \n\n"

    read -rp  "  >  "  CoresSetNumber


    if [[ $CoresSetNumber ]] && [[ $(tr -cd "[:digit:]" <<< "$CoresSetNumber") ]]; then

      printf "cpu_cores=\"%s\"\n"  "$CoresSetNumber"  >> "$New_VM_File"

    fi

    RAM_Available="$(free --mega -h | grep Mem | cut -d':' -f2 | cut -d'G' -f1 | tr -cd '[:graph:]' 2>/dev/null)"

    printf "\n\n\n"

    [[ $RAM_Available ]] && printColor "  Your host system is showing %sG of RAM  \n\n" "$RAM_Available"

    printColor "  Don't stinge on the VM's RAM  Again, esp. if running the VM full screen."

    printf "\n\n  Quickemu will default to half, even quarter minimals ..."

    printf "\n\n  More can be added if you are not using host RAM for graphics & have a separate graphics card"
    
    printf "\n\n  Use more than half if your host is to stay quietly in the background."

    printf "\n\n  Integer values only. Use programs such as 'htop' to tune your setup."

    RAM_SetNumber=

    printColor "\n\n  Give [integer] to allocate    [enter] to use defaults  \n\n"

    read -rp  "  >  "  RAM_SetNumber

    printf "\n\n"

    if [[ $RAM_SetNumber ]] && [[ $(tr -cd "[:digit:]" <<< "$RAM_SetNumber") ]]; then

      printf "ram=\"%s\"\n"  "$RAM_SetNumber"  >> "$New_VM_File"

    fi


    QGW_ConfEdit_DiskSize=

    QGW_ConfEdit_Qstart=

    if [[ $QGW_OS_Arr_NameSelected =~ "windows" ]]; then
    
      printColor "\n\n  Windows: needs tpm=\"on\" secureboot=\"on\""

      printf "\n\n  Set disk_size=\"128G\" or higher "
      printf "\n\n  plus set other vals high eg cpu_cores=\"12\" ram=\"10G\" "

    fi

    printColor "  CHECK ME, NOW: \n\n"

    cat "$New_VM_File"

    #  TODO  automatic double entry removal

    printColor "\n\n  [enter] edit the config file in more detail (check for double entries) "
    
    printf "   [c] continue (with current settings)  [d]  delete the VM - something went wrong ..."

    printf "\n\n"

    read -rp "  >  "   QGW_ConfEdit

  
    if [[ $QGW_ConfEdit == "c" ]]; then 

      true
    
    elif [[ $QGW_ConfEdit == "d" ]]; then 
    
      function_delete_Selected_VM  "$New_VM_Folder" "$New_VM_File"

    else 
    
      qqX_edit_settings  "new_conf"

    fi


  elif [[ $QGW_FolderDelete == "d" ]]; then

    sleep 1.4

  else

    printColor "\n\n  [enter] to return or continue \n\n" 
    read -rp "  > "

  fi

  
  # return back to any working directory if one had already been set  ( REVIEW is this right in all cases?)

  if [[ $VM_Conf_Dir ]]; then cd "$VM_Conf_Dir"  || function_conf_error  "Quickget-Wrap Working Directory NOT FOUND ," ; fi

  
  if [[ $Zsync_Updatable_ISO ]]; then 

    LastZsync="0"

    date +%s > "$VM_InstanceName/zsync.date.txt"

    SettingsFileAdjusted=

    ByPass_VM_Array_Selector=1

  else

    # re-load arrays, if not already done
    
    SettingsFileAdjusted=1

    function_refresh_and_reload_VM_arrays

    ByPass_VM_Array_Selector=1

  fi

}




##  END of ADD-IN of ORIGINAL QUICKEMU and setting up the QUICKGET wrapper.  START MENU FUNCTIONS:



function_conf_error () {

  ErrorMenuSelect=

  NewSetupFlag=

  printf "\n\n  %s Settings, VM folder & conf file(s)"  "$ModName"

  if [[ $1 ]] ; then printf "\n\n  Check %s settings, location & content ... "  "$1"

  else printf "\n\n  Check the settings and re-run this script ... " ; fi


  printf "\n\n  Settings file:  %s \n\n" "$Q_Mod_SettingsFile"

  
  if [[ "$1" == *'COMMAND'* ]]; then 
  
    printColor "\n\n  [q] to quit "

    printf "  [enter] to view/edit settings file \n\n"

  elif [[ $1 == "folder" ]] && [[ $(ls "$VM_InstanceName"/*.iso 2> /dev/null) ]]; then 

    printColor "\n  CHECK ME, NOW: \n\n"

    cat "$VM_Conf_File"

    NewSetupFlag=1

    printColor "\n\n  NEW SETUP: " 

    printf "\n\n  The main qcow2 disk will NOW be created ..."
     
    if [[ "$VM_InstanceName" =~ 'windows' ]]; then 
    
      printf "\n\n  fixed_iso=\"windows-xx/virtio-win-0.1.225.iso\" may be added for display drivers & guest additions "

    fi

    printColor "\n\n\n  [enter]  edit the .conf file"
    
    printf "   [c] continue  (with current settings) looks okay "

    printf "\\n\n  [e] to edit %s general settings   [q] to quit \n\n"   "$ModName"
    
  else   
  
    printColor "\n\n  [Enter] to edit %s settings"  "$ModName" 

    [[ "$1" == *'No VMs'* ]] && printColor "  [gt] quickget a new distro "

    printColor "  [q] to quit \n\n"  

  fi   

  read -rp "  >  "   ErrorMenuSelect

  if [[ $ErrorMenuSelect == "q" ]]; then 
  
    printf "\n\n"; command exit 

  elif [[ $ErrorMenuSelect == "c" ]] || [[ $ErrorMenuSelect == "e" ]] || [[ $ErrorMenuSelect == "gt" ]]; then  
  
    SelectArrayError=
    IgnoreFolderCheck=1

    if [[ $ErrorMenuSelect == "c" ]]; then 

      true

    elif [[ $ErrorMenuSelect == "e" ]]; then 

      if [[ $NewSetupFlag ]]; then qqX_edit_settings ; else qqX_edit_settings  "conf" ; fi
      

    elif [[ $ErrorMenuSelect == "gt" ]]; then 

      VM_Selection=
      function_quick_get_wrap 
      return

    fi
 
  else  
  
    if [[ $NewSetupFlag ]]; then 

      NewSetupFlag=

      printf "\n\n  Remember, if not set, to enable starting via %s from the .conf file:"  "$ModName"

      printf "\n\n  #!/usr/bin/quickemu --vm   should become   #!/usr/bin/%s --vm  " "$ModName"

      printColor "\n\n  [enter] to continue \n\n"

      read -rp "  >  "
    
      qqX_edit_settings  "conf" 
      
    else 
    
      qqX_edit_settings
    
    fi
    
  fi

}


function_VM_array_add_confs () {

  ## Adds to VM array & lists, if submitted item has not been already listed 

  #  where $1 is 'VM_Path' and  $2 is 'VM_Conf' to be tested against the existing list (non-sparse)

  if [[ $1 ]]; then

    # make sure that a $1 has been sent & that the calling array splitter hasn't sent an empty value

    TestFolderFile="$1/$2"

    [[ ! -e $TestFolderFile ]] && function_conf_error  "VM_array_add_confs: File Not Found" && return 
    

    if [[ ! ${VM_Array[0,0]} ]]; then 
    
      New_VM_ElementCount=0  

    else 
    
      New_VM_ElementCount="$((${#VM_Array[@]} / 2))" 

      local i=0

      while [[ ${VM_Array[$i,0]} ]]; do

        ArrFolderFile="${VM_Array[$i,0]}/${VM_Array[$i,1]}"

        if [[ $ArrFolderFile == "$TestFolderFile" ]]; then 
        
          # already exists, stop searching, quit function:
          return

        else  

          # carry on interating the array
          ((i+=1))  

        fi
        
      done

    fi

      # if it's the first entry, or at the end there is no match found in the array, then add it

      VM_Array[$New_VM_ElementCount,0]="$1" 
      VM_Array[$New_VM_ElementCount,1]="$2" 

  fi
  
}


function_scan_VM_folderList () {

  ##  Scans of current & listed VM folders for other potential '.conf' files to the VM array

  #   Adds via calls to 'function_VM_array_add_confs'


  #  If the general settings file has populated or part-populated the VM array, then ${VM_Array[0,0]} will be present

  #  Starts by checking for settings file errors

  VM_SettingsError=

  VM_ElementCount=

  VM_ElementCount="${#VM_Array[@]}" 

  if [[ $VM_ElementCount ]]; then 

    while true ; do

      # Settings file checking loop. Runs until either settings file reads correctly or the user quits.

      ## CHECK 1

      #  Use 'modulo' to detect odd/even   See: https://stackoverflow.com/a/15660039  

      [[ "$(( VM_ElementCount % 2 ))" == "1" ]] &&  VM_SettingsError=1 


      ## CHECK 2

      if [[ ! $VM_SettingsError ]]; then

        # Check that array is non-sparse & is in pairs & that the elements exist

        # Note that a sparse array will stop listing at the first empty entry

        i=0
        PairsCount=0

        while [[ ${VM_Array[$i,0]} ]]; do

          ArrFolderFile="${VM_Array[$i,0]}/${VM_Array[$i,1]}"

          if [[ -d "${VM_Array[$i,0]}" && -f "$ArrFolderFile"  ]]; then  

            [[ $PairsCount -eq  "$VM_ElementCount" ]] &&  break

            # else carry on interating the array 
            ((i+=1))  
            ((PairsCount+=2))  
            
          else  

            VM_SettingsError=1
            printf "\n\n  Array Element(s) Not Found "
            printf "\n\n  Folder:  %s " "${VM_Array[$i,0]}"
            printf "\n\n  .conf :  %s " "${VM_Array[$i,1]}"
            break
            
          fi
          
        done

      fi


      ## CHECK 3

      # If empty array elements were present, the pairs counter won't have incremented fully

      # & in associative arrays, unlike indexed ones, are not possible (@2023) to test for directly. 

      if [[ $PairsCount != "$VM_ElementCount" ]]; then  
      
        VM_SettingsError=1

        printf "\n\n  Empty Array Element(s) Found "

      fi


      if [[ $VM_SettingsError ]]; then

        printColor "\n\n  ERROR in VM array general settings"

        printf "\n\n  [enter] to open settings editor  [q] to quit \n\n"

        read -rp  "  >  "  VM_SettingsError

        printf "\n\n"

        if [[ $VM_SettingsError == "q" ]] ; then  exit directly ; else  qqX_edit_settings ; fi

      else 

        break

      fi

    done

  fi

  i=0

  while [[ ${VM_Folder_List[i]} ]]; do

    FolderPathName="${VM_Folder_List[i]}"

    Folder_Conf_String="$(ls "$FolderPathName/"*.conf 2> /dev/null)"

    Folder_Conf_String=${Folder_Conf_String//"$FolderPathName/"/}

    mapfile -t  Folder_Conf_Array  <<< "$Folder_Conf_String"

    if [[ ${Folder_Conf_Array[0]} ]]; then 

      for TestFile in "${Folder_Conf_Array[@]}"; do 

        # calls adding function, one by one, if the .conf file appears to be valid, & builds the ${VM_Array[*,*]} 

        if grep -q -s 'guest_os=' "$FolderPathName/$TestFile"; then
            
          function_VM_array_add_confs  "$FolderPathName" "$TestFile" 

        fi
      
      done

    fi

    ((i +=1))

  done
  

  if [[ ! ${VM_Array[0,0]} ]] ; then
    function_conf_error  "VM ARRAY - No VMs found?"
    SelectArrayError=1
  fi

}



function_print_conf_array () {

  # Print a list of the VM's in the VM array

  i=0

  while [[ ${VM_Array[$i,0]} ]] ; do

    if [[ ! -d "${VM_Array[$i,0]}" ]]; then 

      printf "\n\n  ERROR  %s folder not found: \n\n  %s \n\n" "$ModName" "${VM_Array[$i,0]}"   

      function_conf_error  "folder $i" 
      SelectArrayError=1
      break 

    else

      ArrayConf_Item="${VM_Array[$i,0]}/${VM_Array[$i,1]}"

      if [[ -e "$ArrayConf_Item" ]]; then 

        if [[ ! $ByPass_VM_Array_Selector ]]; then

          QcowTarget=

          QcowTarget="$(grep -s 'disk_img' "$ArrayConf_Item" )"   

          QcowTarget="${QcowTarget/'disk_img='/}"  

          QcowTarget="${QcowTarget//'"'/}"

          # Newly downloaded VMs will have a qcow disk path in the .conf file 
          # BUT it won't be be there yet, not until quickemu has done a first run against the .conf

          if [[ ! -e "${VM_Array[$i,0]}/$QcowTarget" ]]; then 

            printColor "\n\n %2d  %s  (new)" "$i" "$ArrayConf_Item"

          else

            printf "\n\n %2d  %s " "$i" "$ArrayConf_Item"

            if [[ "${VM_Array[$i,1]}" == 'ubuntu'* ]] && [[ "${VM_Array[$i,1]}" == *'daily'* ]]; then
           
              [[  ! $(du -b -t 500000 "${VM_Array[$i,0]}/$QcowTarget" 2>/dev/null) ]]  &&  printf "(z)"

              #  Live VMs only, as zsync only updates the iso file.  Live VM qcow2 disks are normally only 196k. 

              #  Test ceiling is set at 500k.  REVIEW if problems.
 
            fi

          fi

        fi

      else

        printf "\n\n  ERROR  %s ' .conf ' not found: \n\n  %s \n\n" "$ModName" "$ArrayConf_Item"

        function_conf_error  "config $i" 
        SelectArrayError=1
        break

      fi

    fi

    ((i+=1))

  done
  
}


function_Select_VM () {  

  SelectArrayError=

   
  if [[ $ByPass_VM_Array_Loader ]] && [[ ${VM_Array[0,0]} ]]; then

    # if reselecting & the array is already loaded (which it should be ...)

    # printf "\n\n  ByPassing VM Loader ... "  

    ByPass_VM_Array_Loader=

  else 

    # Re-scan folders as something new may have been added

    function_scan_VM_folderList

    function_VM_array_add_confs

  fi


  if [[ $ByPass_VM_Array_Selector ]] || [[ $SelectArrayError ]] ; then

    # printf "\n\n  ByPassing VM Selector ... "

    true

  else 

    VM_Selection=
    VM_Conf_Dir=
    VM_Conf_File=

    function_print_conf_array

    
    if [[ $DefaultFolderError || $ExtraFolderError ]]; then 

      printf "\n\n\n  Settings file: %s" "$Q_Mod_SettingsFile"

      [[ $DefaultFolderError ]] && printf "\n\n  ERROR: DEFAULT FOLDER   [enter] to edit settings file  [q] to quit " 

      [[ $ExtraFolderError ]] && printf "\n\n  ERROR: EXTRA FOLDER   [enter] to edit settings file  [q] to quit "

    else

      printf "\n\n\n  [number] to select a VM   [gt] quickget a new distro   [q] to quit "

      printColor "\n\n  [Enter]  to select %s (VM 0)"  "${VM_Array[0,1]}"

    fi

    printf "\n\n"

    read -rp  "   >  "  VM_Selection



    [[ $VM_Selection == "q" || $VM_Selection == "Q" ]] && echo && exit directly 

    if [[ $DefaultFolderError || $ExtraFolderError ]]; then 
          
      DefaultFolderError= 
      ExtraFolderError=
      VM_Selection=
      VM_InstanceName=
      qqX_edit_settings 
      return

    fi



    if [[ $VM_Selection == "gt" || $VM_Selection == "GT" ]]; then

      if [[ $VM_Selection == "GT" ]]; then

        printColor "\n\n  CAPS LOCK should be unset \n\n"

        read -rp "  [enter] to continue  >  "

      fi

      VM_Selection=
      function_quick_get_wrap 

      ByPass_VM_Array_Loader=

      printf "\033c"
      show_qmod_title
      return

    fi

    [[ ! $VM_Selection ]] &&  VM_Selection=0  

    printf "\n\n  Selecting instance %s \n\n"  "$VM_Selection"

    VM_Conf_Dir="${VM_Array[$VM_Selection,0]}"
    VM_Conf_File="${VM_Array[$VM_Selection,1]}"

  fi


  if [[ $SettingsFileAdjusted && $ByPass_VM_Array_Selector ]] || [[ $SelectArrayError ]]; then

    # Only the array checker is run after a settings edit, if a VM selection is already in place 

    # printf "\n\n  Maintaining current KVM settings ... "

    true

  else

    ## Check file/folder exists

    [[ ! -d "$VM_Conf_Dir" ]] &&  function_conf_error  "folder"  && SelectArrayError=1


    ## CHANGE DIRECTORY to where the VM is

    ! cd "$VM_Conf_Dir"  &&  printColor "\n\n  ERROR  .conf  folder switching \n\n" && sleep 5 && exit 1


    [[ ! -e "$VM_Conf_File" ]] &&  function_conf_error  ".conf file" && SelectArrayError=1


    # Set Instance Name, following Quickemu pattern which sets the same name to the .conf file and to the main folder 

    VM_InstanceName="${VM_Conf_File/.conf}"


    # Check that the dir contains the right files  &&  grep .conf for right content

    if [[ $IgnoreFolderCheck ]]; then

      IgnoreFolderCheck=

    else

      [[ ! $(ls "$VM_InstanceName"/*.qcow2 2> /dev/null) ]] && function_conf_error  "folder"  && SelectArrayError=1

    fi

    ! grep -q 'guest_os=' "$VM_Conf_File" 2> /dev/null && function_conf_error  ".conf file"   && SelectArrayError=1
  

    # Check KVM parameter settings & advise according to guest OS

    KVM_MSR_selector=

    function_find_kvm_msr_default_and_status

    if [[ $Verbose_MSR_dialog ]] || [[ ! $Verbose_MSR_dialog ]] && [[ "$VM_InstanceName" == *windows* || "$VM_InstanceName" == *macos* ]]; then 
    
      msrs_conflict_check_resolver

    fi

  fi

  # clear any no-longer needed flags

  Select_VM=

  ByPass_VM_Array_Loader=
  ByPass_VM_Array_Selector=

  # reload if the editor was called, due to settings error

  if [[ $SelectArrayError ]]; then
  
    MainMenuChoice="refresh" 
    Select_VM=1

    [[ $VM_InstanceName ]] && ByPass_VM_Array_Selector=1

  else

    SettingsFileAdjusted=

  fi

}


drives_and_snapshots() {

  #  @ 2023/08  with adding of second and shared drives,  
   
  #  also start accessing qemu-img directly instead of going round the houses with with quickemu calls

  Selected_Drive=

  if [[ $SecondDriveArgs ]]; then

    printColor "\n  Second Drive: \n\n"
    if [[ $1 == "info" ]]; then "$QEMU_IMG" info "$SecondDrive"; echo ; else "$QEMU_IMG" snapshot -l "$SecondDrive"; fi

    if ! "$QEMU_IMG" snapshot -l "$SecondDrive" | grep -s -q 'Snapshot list:' ; then printf "  No Snaphots \n\n" ; fi

  fi

  if [[ $SharedDriveArgs ]]; then

    printColor "\n  Shared Drive: \n\n"
    if [[ $1 == "info" ]]; then "$QEMU_IMG" info "$SharedDrive"; echo ; else "$QEMU_IMG" snapshot -l "$SharedDrive"; fi

    if ! "$QEMU_IMG" snapshot -l "$SharedDrive" | grep -s -q 'Snapshot list:' ; then printf "  No Snaphots \n\n" ; fi

  fi

  if [[ $SharedDriveArgs || $SecondDriveArgs ]]; then printColor "\n  Main Drive: \n\n"
  
  else printColor "\n  One Main Drive: \n\n"
  
  fi

  if [[ $1 == "info" ]]; then "$QEMU_IMG" info "$MainDrive"; echo ; else "$QEMU_IMG" snapshot -l "$MainDrive"; fi

  if ! "$QEMU_IMG" snapshot -l "$MainDrive" | grep -s -q 'Snapshot list:' ; then printf "  No Snaphots \n\n" ; fi

  if [[ $1 == "select" ]] && [[ $SharedDriveArgs || $SecondDriveArgs ]]; then

    printColor "\n  Select:  [enter]  Main Drive (or back to main menu)"
    
    [[ $SecondDriveArgs ]] && printColor "   [2]  Second Drive"
    [[ $SharedDriveArgs ]] && printColor "   [3]  Shared Drive"

    [[ $SharedDriveArgs && $SecondDriveArgs ]] && printColor "  (scroll to view)"

    printf "\n\n"

    read -rp "  >  "   Selected_Drive

    case "$Selected_Drive" in

      2)  Selected_Drive="$SecondDrive" 
          Selected_DriveName="Second Drive"
      ;;

      3)  Selected_Drive="$SharedDrive" 
          Selected_DriveName="Shared Drive"
      ;;

      *)  Selected_Drive="$MainDrive" 
          Selected_DriveName="Main Drive"
      ;;

    esac

    printf "\033c"
    printColor "\n\n Selected Drive = %s \n\n"  "$Selected_DriveName"

    #"$QEMU_IMG" snapshot -l "$Selected_Drive" # make sure there is enough space too
    "$QEMU_IMG" info "$Selected_Drive"

  fi

}



function_KillPID_Menu() {

  tput civis

	# WAIT for background load & QEMU messages to appear before showing menu (unless reloading)

	if [[ $KillPID_Menu_Exited ]]; then  KillPID_Menu_Exited=

  elif [[ $BreakAtVerboseArgs ]]; then BreakAtVerboseArgs= ; return

  else  sleep 2 ; fi
  
  #if [[ ! $InstancePID ]]; then

    # belt & braces check for the PID:  

    #InstancePID="$(pgrep "$VM_InstanceName")"

    #echo "PID $InstancePID - VM_InstanceName $VM_InstanceName "


    # braces: qemu SHOULD write a .pid file while it is running & remove it when not  
    
    # REVIEW  Probably we should assume VM is not running if QEMU's & file is not there as this would indicate QEMU failure

    # [[ ! $InstancePID ]] && InstancePID="$(cat "${VMDIR}/${VMNAME}.pid")"

    InstancePID="$(cat "${VMDIR}/${VMNAME}.pid" 2> /dev/null)"

    # echo "PID $InstancePID - VMDIR $VMDIR  VMNAME  $VMNAME QEMU $QEMU"

  #fi

  if [[ $InstancePID ]]; then 

    SpicyPID=

    sleep  "$P_Kill_WaitSecs"      # REVIEW  

    printColor "\n  Quickemu instance %s on PID:  %s"  "$VM_InstanceName"  "$InstancePID"

    printColor  "   [k] force close the Quickemu instance   "
    
    SpicyPID="$(pgrep spicy)"

    if [[ $SpicyPID ]]; then 

      #  TODO   if possible, add SDL reconnect 

      SpicyReStartCmd="$(ps --no-headers -o cmd "$SpicyPID")"
    
      printColor " [r] reload Spicy window (if closed)"

    fi

    printf "\n\n"
  fi

  # return to menu requires VM to be shutdown first

  while true ; do 

    read -rp  "  >  " -t 1  KillPID_Menu

    if [[ $KillPID_Menu == "k" ]]; then 

      printf "\n\n"
      if [[ $( ps -p "$InstancePID" --no-headers ) ]]; then
        [[ $SpicyPID ]] && kill "$SpicyPID" 2>/dev/null &
        kill "$InstancePID" 2>/dev/null &
      fi

      sleep 3
      printf "\n\n"

      tput cnorm
      break

    elif [[ $KillPID_Menu == "r" ]]; then 

      if [[ ! $(pgrep spicy) ]]; then 
        eval "$SpicyReStartCmd"
        sleep 2
        SpicyPID="$(pgrep spicy)"
      fi

    else

      if [[ ! $( ps -p "$InstancePID" --no-headers ) ]]; then 
      
        tput cnorm 
        break 

      else

        #  Erase text and adjust cursor:   "\e[1A\r"  "\e[2K\r"  etc    See https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797
       
        printf "\r"

      fi

    fi

  done

  KillPID_Menu=

  KillPID_Menu_Exited=1

  P_Kill_WaitSecs="$P_Kill_WaitSecs_PreSet"

}	

qqX_edit_settings() {

  if [[ ! $TextEditor ]]; then
  
    DefaultTextEditor="$(xdg-mime query default text/plain)"

    EditorTest="${DefaultTextEditor/\/.desktop//}"

    EditorTest="$(tr -cd "[:alnum:]" <<< "$EditorTest")"

    if [[ $DefaultTextEditor ]] && [[ $(type -p "$EditorTest") ]] ; then

      TextEditor="${DefaultTextEditor/.desktop/}"

    elif [[ $(type -p gedit) ]] ; then 

      TextEditor="gedit"

    elif [[ $(type -p pluma) ]] ; then 

      TextEditor="pluma"

    elif [[ $(type -p kate) ]] ; then 

      TextEditor="kate"

    elif [[ $(type -p nano) ]] ; then 

      TextEditor="nano"

    fi

  fi

  if [[ $(type -p "$TextEditor") ]]; then 

    # Run the editor: 

    # Note, these commands can throw a complaint if 'xapps' has not not been installed.
    
    # But works okay...  YMMV    Use: 2>/dev/null

    # https://askubuntu.com/questions/1396739/failed-to-load-module-xapp-gtk3-module


    if [[ $1 == "conf" ]]; then

      custom_conf_notes

      "$TextEditor" "$VM_Conf_Dir/$VM_Conf_File"  2> /dev/null 

      ConfSettingsAdjusted=1

    elif [[ $1 == "new_conf" ]]; then

      custom_conf_notes

      "$TextEditor" "$New_VM_File"  2> /dev/null 

    else 

      "$TextEditor" "$Q_Mod_SettingsFile"  2> /dev/null 

      SettingsFileAdjusted=1

      # .conf is read only when booting the VM, just the general settings needs a system refresh

      VM_InstanceName="$VM_InstanceName"" - Settings Updated  >> ReSelect"

      function_refresh_and_reload_VM_arrays
     
    fi

  else

    printColor "\n\n  Unable to find a default or basic text editor \n\n "

    printf "\n\n  Try an install of 'nano' or give settings file the command name of a preferred editor ..  "

    printf "\n\n  Settings location:  %s  \n\n"  "$Q_Mod_SettingsFile"

    read -rp "  [enter] to return >  "

  fi

}


function_delete_Selected_VM () {

  if [[ ! $1 && ! $2 ]]; then

    # Normally: VM_InstanceName="${VM_Conf_File/.conf}"

    printColor "\n\n  Params VM Name & VM config file (NO PATH) must be given \n\n " 

    sleep 2 ;  return

  else

    if [[ ! -d "$1" ]] || [[ ! -e "$2" ]]; then

      printColor "\n\n  Params VM Name & VM config file (NO PATH) must be given \n\n " 

      printColor "\n\n  Params VM Name / VM config file  NOT FOUND  \n\n " 

      sleep 2 ;  return

    fi

    if [[ $(type -p gio 2>/dev/null) ]]; then TrashingAvailable=1 ; else TrashingAvailable= ; fi

    printColor "\n\n  Folder: %s " "$1"
  
    printColor " & %s to be deleted?"  "$2"

    printf "\n\n Folder content: \n\n "

    ls "$1"

    if [[ $TrashingAvailable ]]; then 

      printColor "\n\n  [enter] safely move things to the trash bin"  
      
      printf "\n\n  [n] keep   [y] yes, PERMANENTLY, I have back-ups ..."

    else

      printColor "\n\n  [enter] use the file manager to move things the trash bin "
      
      printf "\n\n  [y] yes, PERMANENTLY, I have back-ups ..."

    fi

    printf "\n\n"

    read -rp "  >  "   Delete_VM_Option

    if [[ $Delete_VM_Option == "y" ]]; then 

      printf "\n\n  Folder & .conf file being deleted ... \n\n"
      
      rm -f -r "$1"  
      echo

      rm -f "$2"
      echo

    else

      # https://specifications.freedesktop.org/trash-spec/trashspec-latest.html

      if [[ $TrashingAvailable ]] && [[ $Delete_VM_Option != "n" ]]; then

        gio trash "$1"
        gio trash "$2"

      else

        printf "\n\n  NOT deleted ... \n\n"

      fi

    fi

    sleep 1.4

    printColor "\n\n  [enter] to return or continue \n\n" 
    read -rp "  > "

    VM_InstanceName="$VM_InstanceName"" - Deleted >> ReSelect"

    SettingsFileAdjusted=1

    function_refresh_and_reload_VM_arrays

  fi

}



function show_quickemu_WRAP_help {

  HelpSelect=

  if [[ $ModName_qqX ]]; then 

    printf "\n"
  
    function_qqX_printf_logo_title  "$qqX_title"

    printf "\n\n\n  %s is currently wrapping: QEMU %s  quickemu %s  &  quickget %s"  "$ModName" "$QEMU_VER_LONG" "$QE_VerNumber"  "$QG_VerNumber" 

  else 
  
    printColor "\n\n\n  Quickemu Mod - Virtual Machine Launcher - Wrap Version %s %s " "$ModName" "$ModVersion" 

  fi

  printf "\n\n  https://en.wikipedia.org/wiki/Wrapper_library   https://en.wikipedia.org/wiki/Adapter_pattern"  

  printf "\n\n\n  For code contributions, bugs and updates, see: https://github.com/TuxVinyards"  

  [[ ! $ModName_qqX ]] &&  printf "\n\n  May be started in a folder terminal:  ./%s   or by mouse click"  "$ModName"
  
  printf "\n\n  [enter] to return   [a] %s API detail   " "$ModName"

  [[ ! $ModName_qqX ]] && printf "[p] parameters for VM runtime settings"

  printf "\n\n"

  read -rp "  >  "  HelpSelect

  if [[ $HelpSelect == "a" ]]; then   
  
    show_wrap_CLI_usage  

    printf "\n\n\n"
  
    read -rp  "  [enter] to return >  " 

  elif [[ $HelpSelect == "p" ]]; then
  
    printf "\n\n  Extra quickemu parameters for qmod API & qmod settings."  
  
    printf "\n\n  NB  not all options can be applicable  CAUTION \n\n" 

    NoExit=1
    echo
    usage | tail +6
    echo

    read -rp  "  [enter] to return >  " 

  fi
}

# As check_for_qqX_updates runs in the background, the variables need transfering to the foreground

qqX_LatestRelease=

qqX_LatestTarBall=

qqX_UpdateAvail=

qqX_Upd_VarsTmpFile="/tmp/qqX.upd.chk.txt"

echo > "$qqX_Upd_VarsTmpFile"


check_for_qqX_updates() {

  # Quietly do a check for new releases 

  wget -q -T2 -t2 -O "/tmp/latest-qqX"  "https://api.github.com/repos/TuxVinyards/qqX/releases/latest" 

  qqX_LatestRelease="$(grep -s tag_name "/tmp/latest-qqX" )"

  
  if [[ $qqX_LatestRelease ]]; then

    # should normally be the case, if an internet connection was existant

    qqX_LatestRelease="${qqX_LatestRelease/'"tag_name": "'/}"

    qqX_LatestRelease="${qqX_LatestRelease//'",'/}"

    qqX_LatestRelease="$(tr -cd '[:graph:]' <<< "$qqX_LatestRelease")"

    # std downloads: 

    # eg "tarball_url": "https://api.github.com/repos/TuxVinyards/qqX/tarball/0.09.00.016",

    qqX_LatestTarBall="$(grep -s tarball "/tmp/latest-qqX" )"

    qqX_LatestTarBall="${qqX_LatestTarBall/'"tarball_url": "'/}"

    qqX_LatestTarBall="${qqX_LatestTarBall//'",'/}"

    qqX_LatestTarBall="$(tr -cd '[:graph:]' <<< "$qqX_LatestTarBall")"

    # assets: 
    
    # eg "browser_download_url": "https://github.com/TuxVinyards/qqX/releases/download/0.09.00.016/qqX-0.09.00.016.tar.gz"

    # &  "browser_download_url": "https://github.com/TuxVinyards/qqX/releases/download/0.09.00.016/qqX-0.09.00.016.tar.gz.sha256"

    qqX_Latest_Secure_TarTest="https://github.com/TuxVinyards/qqX/releases/download/$qqX_LatestRelease/qqX-$qqX_LatestRelease.tar.gz"


    if [[ "$(grep -s -c "$qqX_Latest_Secure_TarTest" "/tmp/latest-qqX")" == "2" ]] ; then

      qqX_Latest_Secure_TarBall="$qqX_Latest_Secure_TarTest"
      
      qqX_Latest_Secure_TarSha="https://github.com/TuxVinyards/qqX/releases/download/$qqX_LatestRelease/qqX-$qqX_LatestRelease.tar.gz.sha256"
           
    fi


    IFS='.' read -ra qqX_LatestVer_Arr <<< "$qqX_LatestRelease"

    # Current Version is carried out at the start, in similar way


    # qqX_LatestVer_Arr[0] remains unpadded  (& to the left of the decimal point)

    [[ ${#qqX_LatestVer_Arr[1]} -lt 2 ]] && printf -v qqX_LatestVer_Arr[1] "%.2d" "${qqX_LatestVer_Arr[1]}"

    [[ ${#qqX_LatestVer_Arr[2]} -lt 2 ]] && printf -v qqX_LatestVer_Arr[2] "%.2d" "${qqX_LatestVer_Arr[2]}"

    #legacy 3dp pre "0.09.00.017"

    [[ ${#qqX_LatestVer_Arr[3]} -gt 2 ]] && qqX_LatestVer_Arr[3]="${qqX_LatestVer_Arr[3]:(-2)}"

    [[ ${#qqX_LatestVer_Arr[3]} -lt 2 ]] && printf -v qqX_LatestVer_Arr[3] "%.2d" "${qqX_LatestVer_Arr[3]}"

    qqX_LatestVer_Float="${qqX_LatestVer_Arr[0]}.${qqX_LatestVer_Arr[1]}${qqX_LatestVer_Arr[2]}${qqX_LatestVer_Arr[3]}"

    
    #echo "latest $qqX_LatestVer_Float  current $qqX_CurrentVer_Float"   


    #  Flag up release type.  Also used in qqX general title to show if using beta or release.

    if [[ "${qqX_LatestVer_Arr[3]}" ]] && [[ "${qqX_LatestVer_Arr[2]}" == "00" ]]; then 
    
      qqX_LatestReleaseType="beta"

    else qqX_LatestReleaseType="release"
    
    fi
    
    #echo "latest $qqX_LatestReleaseType  current $qqX_CurrentReleaseType"   


    #  If current ver is beta OR if beta notifications are requested in the general settings:

    [[ $qqX_CurrentReleaseType == "beta" ]] && Hide_qqX_BetaUpdates=


    # Set up TRANSFER FILE for all needed variables,  as check runs in background ...  NB 

    if [[ ! $Hide_qqX_BetaUpdates && $qqX_LatestReleaseType == "beta" ]] || [[ $qqX_LatestReleaseType == "release" ]]; then
   
      if [[ $(echo "$qqX_LatestVer_Float > $qqX_CurrentVer_Float" | bc  2>/dev/null) == "1" ]]; then 

        { printf "\n\n qqX_UpdateAvail=\"1\""   
        
          printf "\n\n qqX_LatestRelease=\"%s\""  "$qqX_LatestRelease" 

          printf "\n\n qqX_LatestTarBall=\"%s\""  "$qqX_LatestTarBall" 
        
          printf "\n\n qqX_Latest_Secure_TarBall=\"%s\""  "$qqX_Latest_Secure_TarBall" 
        
          printf "\n\n qqX_Latest_Secure_TarSha=\"%s\""  "$qqX_Latest_Secure_TarSha" 

          printf "\n\n qqX_LatestReleaseType=\"%s\""  "$qqX_LatestReleaseType" 

          printf "\n\n qqX_LatestVer_Float=\"%s\""  "$qqX_LatestVer_Float" 
        
        } >> "$qqX_Upd_VarsTmpFile"

      else 
      
        printf "\n\n qqX_UpdateAvail="   > "$qqX_Upd_VarsTmpFile"

      fi

    fi

    #  REVIEW  dev searches for pre-releases?  Needs 'jq' but for dev probably okay to add this.  Or just leave as UnHide_Beta?
    
    # https://stackoverflow.com/questions/67688662/how-can-i-get-the-latest-pre-release-release-for-my-github-repo-bash

  fi 


}


show_qmod_title() {

  if [[ $ModName_qqX ]]; then printf "\n" ; function_qqX_printf_logo_title  "$qqX_title" ;  printf "\n"

  else printColor "\n\n  Quickemu Mod - Virtual Machine Launcher  Wrap Version %s"  "$ModVersion" ; fi

  printf "\n\n  Currently wrapping:  QEMU %s   quickemu %s  &  quickget %s" "$QEMU_VER_LONG"  "$QE_VerNumber"  "$QG_VerNumber"

  [[ $VerboseArgs ]] && printf  "  (Verbose Args)"
  
  #printf "\n"   

  printf "\n\n  Current Folder: %s \n"  "$(pwd)"

}


function_show_main_menu_header () {

  if [[ ! $VM_InstanceName ]]; then

    Select_VM=1

  else

    #[[ $InstancePID ]] && [[ ! $( ps -p "$InstancePID" --no-headers 2>/dev/null) ]] && InstancePID=

    [[ $InstancePID ]] && [[ ! $(cat "${VMDIR}/${VMNAME}.pid" 2>/dev/null) ]] && InstancePID=

    #  Now using Qemu's PID file.  REVIEW   

    [[ ! $InstancePID ]] && printf "\033c"  && show_qmod_title
 
    printf "\n"

    printColor "    %s " "$VM_InstanceName" 

    #  Default_VM_Folder, as defined in settings.  Highlight if using non-default or current (pwd).

    if [[ "$(pwd)" == "$Default_VM_Folder" ]]; then printf "  @   %s"  "$VM_Conf_Dir"     

    else  printColor "  @   %s"  "$VM_Conf_Dir" 

    fi

    printf "\n"

    [[ $KVM_MSR_Error ||  $Show_MSR_Warnings  || $MSR_Warnings || $Verbose_MSR_dialog ]] && print_kvm_status

  fi

}



##  START:  QUICKEMU-WRAP  menu interface  &  API DIVIDER  ###

#   NB   Also see initial $1 flag setting traps at script start

if [[ $1 ]]; then

  # simple API for command line or .conf starts  ie.  --vm  "path/folder/file.conf"   

  if [[ $XDG_QcowRightClick ]]; then

    # should haved changed to the parent directory at this point

    if grep -q -s "disk_img="'"'"$XDG_QcowRightClick_VM_Dir_Name/$XDG_QcowRightClick_DiskName" "$XDG_QcowRightClick_VM_Dir_Name.conf" ; then

      VM_Conf_Dir="$(pwd)"

      VM_Conf_File="$XDG_QcowRightClick_VM_Dir_Name.conf"

      VM_InstanceName="$XDG_QcowRightClick_VM_Dir_Name"

      shift

    else

      XDG_QcowRightClick_NO_qqX=1

      shift

    fi

  elif [[ $XDG_StartVariant ]]; then

    echo
    
    function_qqX_logo

    printColor "\n\n  %s  not understood \n\n  Or non valid file type %s \n\n"  "$1 "  "$XDG_MimeType"

    sleep 5 


  elif [[ "$1" == *'vm' ]] && [[ "$2" == *'.conf' ]]; then

    # conforms to  -vm | --vm  file.conf
  
    VM_Conf_Dir="$(dirname "$2")"

    VM_Conf_File="$(basename "$2")"

    shift $#

  else 
  
    show_wrap_CLI_usage 

    printf "\n\n"

    exit directly

  fi


  if [[ ! $VM_Conf_Dir ]]; then 
  
    VM_Conf_Dir="$CurrentFolder"

  else

    if [[ ! -e  "$VM_Conf_Dir"  ]]; then 

      printColor "\n\n  %s  not found "  "$VM_Conf_Dir "
    
      function_conf_error  "Q-wrap COMMAND LINE Path Instruction,"

    else

      cd "$VM_Conf_Dir"  || function_conf_error  "Q-wrap COMMAND LINE Path Instruction,"

    fi

  fi

  if [[ ! -e "$VM_Conf_Dir/$VM_Conf_File" ]]; then 

    printColor "\n\n  %s  not found "  "$VM_Conf_File"
  
    function_conf_error  "Q-wrap COMMAND LINE .Conf Instruction,"

  fi


  # Selection now made, but array must still be loaded as may be needed for reselecting later ...

  ByPass_VM_Array_Selector=1

fi


##  Start Q-wrap menu :   

tput civis

printf "\033c"

show_qmod_title

MultiInstanceCount="$(pgrep -c "$ModName")"

if [[ $MultiInstanceCount -gt 1 ]]; then 

  printColor "\n\n  WARNING: more than one instance of %s appears to be running "  "$ModName"

  printf "\n\n  To prevent cross-linking, this instance or the other instance(s) should be closed \n\n"

  read -rp "  [q] to quit    [enter] to continue  > "   MultiQuit

  [[ $MultiQuit == "q" ]] && exit directly

fi

# quietly check for qqX updates, in the background. Once only, at the start.

if [[ ! $Disable_qqX_upd_Checks ]]; then

  check_for_qqX_updates &   

  qqX_UpdaterPID="$!"

fi


# MAIN MENU  (select VM then choose actions to do)

while true ; do

  MainMenuChoice=

  SnapTitle=

  SnapNumber=

  SnapName=

  function_show_main_menu_header

  if [[ $XDG_QcowRightClick_NO_qqX ]]; then

      printColor  "\n\n QEMU qcow2 disk found BUT not configured as qqX/quickemu bootable: \n\n"

      "$QEMU_IMG" info "$XDG_QcowRightClick_VM_Dir_Name/$XDG_QcowRightClick_DiskName"

      printf "\n\n"

      read -rp  "  [enter] to continue  >  "
      
      XDG_QcowRightClick_NO_qqX=

      XDG_QcowRightClick=

      function_refresh_and_reload_VM_arrays

      MainMenuChoice="vm"

      continue

  elif [[ $SettingsFileAdjusted ]]; then 

    function_Select_VM

    MainMenuChoice="vm" 

  elif [[ $KillPID_Menu_Exited ]] || [[ $Select_VM ]] ; then

    if [[ $InstancePID ]] && [[ $( ps -p "$InstancePID" --no-headers ) ]] && [[ $(cat "${VMDIR}/${VMNAME}.pid" 2> /dev/null) ]]; then 

      #  REVIEW  add use of PID file
    
      printf "\n\n  %s is still running ..." "$VM_InstanceName"

      function_KillPID_Menu

      continue

    else 

      InstancePID=
    
      if [[ $Select_VM ]]; then  

        #declare -p VM_Array
        #echo    "  main menu loop - after Select_VM call:"
        #read -p "  VM_InstanceName is $VM_InstanceName  ByPass_VM_Array_Loader is $ByPass_VM_Array_Loader  ByPass_VM_Array_Selector is $ByPass_VM_Array_Selector"
        #echo

        function_Select_VM

        MainMenuChoice="refresh" 

        #declare -p VM_Array
        #echo    "  main menu loop - after Select_VM run:"
        #read -p "  VM_InstanceName is $VM_InstanceName  ByPass_VM_Array_Loader is $ByPass_VM_Array_Loader  ByPass_VM_Array_Selector is $ByPass_VM_Array_Selector"
        #echo

      else

        printf "\n\n    %s is now shut down" "$VM_InstanceName" 

      fi
    
    fi

    [[ $KillPID_Menu_Exited ]] && KillPID_Menu_Exited=

  fi


  ##  Set or adjust any VM_Conf_Dir related globals  (VM is now selected OR has been re-selected)

  QemuArgsFile="$VM_Conf_Dir/$VM_InstanceName/Qemu_args_List.txt"

  QemuVirtHardwareRecord="$VM_Conf_Dir/$VM_InstanceName/QemuVirtHardwareRecord.txt"

  check_screen_percentage

  set_drive_paths

  find_main_drive


  ## Print menu:

  if [[ ! $MainMenuChoice ]]; then

    printf  "\n\n"

    [[ $KVM_MSR_Error || $KVM_MSR_Warn ]] && [[ ! $ShowUtilsMenu ]] && printf  "  [m]  msrs help "


    if [[ ! $VM_InstanceName ]]; then printColor  "  [vm]  reselect " ; else   printf  "  [vm]  reselect " ; fi

    
    if [[ $ShowUtilsMenu ]]; then

      printf "   [del] delete selected VM"

      printColor  "    [u]   hide utils & technical"

      printf "\n"

      if [[ $Q_Mod_SettingsFile ]] ; then echo; echo "  Using settings file $Q_Mod_SettingsFile" ;  fi

      if [[ $SharedDriveArgs ]]; then echo; echo "  SharedDrive: $SharedDrive" ;  fi

      if [[ $SecondDriveArgs ]]; then echo; echo "  SecondDrive: $SecondDrive" ;  fi


      if [[ $Default_SDL_ScreenPercent ]]; then echo; echo "  Default_SDL_ScreenPercent: $Default_SDL_ScreenPercent" 

      else echo; echo "  Default_SDL_ScreenPercent:  not set" ; fi


      if [[ $VerboseArgs ]]; then printf  "\n\n  [v]   hide verbose qemu args"	

      else  printf  "\n\n  [v]   show verbose qemu args & check before booting"	; fi


      printf  "\n\n  [xa]  add extra qemu args   [m] msrs help   [2] create a second  [3] a shared  > virtual hard-drive"
    
      printf "\n\n  [hdw]  Add current config to this VM's Virtual Hardware Record"
    
      [[ $ExtraArgs ]] && printf  "\n\n  Extra Args:  %s"  "$ExtraArgs"

      printf "\n"

    else

      printf  "  [u]  show utils & technical"

    fi

    printf  "\n\n  [sc]  create   [sd]  delete   [sa]  apply   [sl]  list   >  snapshots "

    printf "\n"

    if [[ $XDG_QcowRightClick_NO_qqX ]]; then

      printColor  "\n\n  ?? "

    else

      printColor  "\n\n  [d]   start with default sdl display"
      
      if [[ "$VM_InstanceName" =~ 'windows' ]]; then  printColor " (sizes to Windows > display, useful for Windows updates)" 

      elif [[ "$VM_InstanceName" =~ 'macos' ]]; then  printColor " (size determined by MacOS)" 

      elif [[ $SDL_ScrnPcnt_Cmd ]]; then printColor " (%s%%)"  "$SDL_ScreenPercent"

      elif [[ $SDL_ScrnPcnt_Error ]]; then printf " (ERROR %s%% %s > See settings)"  "$SDL_ScreenPercent"  "$SDL_ScrnPcnt_Error"

      fi

      printColor 	"\n\n  [s]   start with spice display (scaleable) "  

    fi

    printf "\n"


    printf  "\n\n  [gt]  quickget a new distro   [info]  show VM drives info "

    if [[ "$VM_InstanceName" == 'ubuntu'* ]] && [[ "$VM_InstanceName" == *'daily'* || "$VM_InstanceName" == "ubuntustudio-dvd" ]]; then 
    
      if [[ ! $(du -b -t 500000 "$VM_InstanceName/disk.qcow2" 2>/dev/null) ]] && [[ $(ls "$VM_InstanceName/"*devel.iso 2>/dev/null) ]] ; then

        #  Live VMs only, as zsync only updates the iso file.  Live VM qcow2 disks are normally only 196k.  
        
        #  Test ceiling is set at 500k.  REVIEW if problems.

        if [[ -e "$VM_InstanceName/zsync.date.txt" ]]; then

          SyncDateNow="$(date +%s)"

          SyncDateOld="$(cat "$VM_InstanceName/zsync.date.txt")"

          LastZsync="$((SyncDateNow - SyncDateOld))"

          #  older than 6hrs (in epoch seconds)

          if [[ $LastZsync -gt 21600 ]]; then  printColor "   [z] run a quick zsync iso update - last run %d hrs ago"  "$((LastZsync/3600))"

          else  printf "   [z] run a quick zsync iso update - last run %d hrs ago"  "$((LastZsync/3600))"
          
          fi

        else

          date +%s > "$VM_InstanceName/zsync.date.txt"
            
        fi


        function_hide_quickget_code_snippets_in_a_way_that_retains_a_formatted_display () {

          ## FROM:  function get_ubuntu in quickget (original, ver 4.8)

          if [[ "${RELEASE}" == *"daily"* ]] && [ "${OS}" == "ubuntustudio" ]; then
              # Ubuntu Studio daily-live images are in the dvd directory
              RELEASE="dvd"
          elif [ "${RELEASE}" == "daily-canary" ] && [ "${OS}" != "ubuntu" ]; then
              # daily-canary is only available for Ubuntu, switch flavours to daily-live
              RELEASE="daily-live"
          elif [ "${RELEASE}" == "daily-legacy" ] && [ "${OS}" != "ubuntu" ]; then
              # daily-legacy is only available for Ubuntu, switch flavours to daily-live
              RELEASE="daily-live"
          fi

          # AND from function list_csv()

          # shellcheck disable=SC2086,SC2034

          if [ "${OS}" == "macos" ]; then
            DOWNLOADER="macrecovery"

          elif [ "${OS}" == "ubuntu" ] && [ "${RELEASE}" == "daily-canary" ] && [ ${HAS_ZSYNC} -eq 1 ]; then
            DOWNLOADER="zsync"

          elif [ "${OS}" == "ubuntu" ] && [ "${RELEASE}" == "daily-legacy" ] && [ ${HAS_ZSYNC} -eq 1 ]; then
            DOWNLOADER="zsync"

          elif [[ "${OS}" == *"ubuntu"* ]] && [ "${RELEASE}" == "devel" ] && [ ${HAS_ZSYNC} -eq 1 ]; then
            DOWNLOADER="zsync"

          # qqX: NB only the iso gets dubbed with 'devel' suffix, otherwise VMs they keep their names 
          
          # eg  'ubuntu-mate-daily-live' 'ubuntustudio-dvd' 'ubuntu-daily-canary'


          # An actual 'ubuntu-devel' release or folder doesn't seem to ever get created or offered.

          # Presume release=devel (@2023/07) has now been superseded, or was merely intended as an indicative name only ...

          
          # Also note that quickget includes code to remove 'zs.old' files, which may or may not have been needed,
          
          # but Zsync can now give these files root protection so this removal may not work ...   REVIEW  Add a qqX copying mechanism? 

          else
            DOWNLOADER="${DL}"
          fi

        }

        #  Sort out the quickget / function_quick_get_wrap  call & the var/flags   
        
        # Expect these to need updating from time to time ...

        Zsync_OS_Name="$VM_InstanceName"

        Zsync_OS_Name="${Zsync_OS_Name/'-daily'/}"
        Zsync_OS_Name="${Zsync_OS_Name/'-live'/}"
        Zsync_OS_Name="${Zsync_OS_Name/'-canary'/}"
        Zsync_OS_Name="${Zsync_OS_Name/'-legacy'/}"
        Zsync_OS_Name="${Zsync_OS_Name/'-jammy'/}"
        Zsync_OS_Name="${Zsync_OS_Name/'-dvd'/}"

        Zsync_Release_Name="$VM_InstanceName"

        Zsync_Release_Name="${Zsync_Release_Name/"${Zsync_OS_Name}-"/}"

        #echo; echo "$Zsync_OS_Name  $Zsync_Release_Name" 

        Zsync_Updatable_ISO=1

      fi

    else 

      Zsync_Updatable_ISO=
      Zsync_OS_Name=
      Zsync_Release_Name=

    fi
    
    printf  "\n\n  [h]  show help & info   [set] open settings file in text editor   [conf] open .conf file"

    if [[ $ConfSettingsAdjusted ]]; then 

      ConfSettingsAdjusted=
      printf "\n\n  done - no general refresh needed for .conf edits "

    fi

    printf  "\n\n"

    if [[ $qqX_UpdaterPID ]]; then

      while true ; do

        if [[ $( ps -p "$qqX_UpdaterPID" --no-headers 2>/dev/null) ]]; then  
        
          sleep 1

        else 
        
          # shellcheck source=/dev/null
          source "$qqX_Upd_VarsTmpFile"
          qqX_UpdaterPID= 
          break
          
        fi

      done

    fi

    [[ $qqX_UpdateAvail ]] &&  printColor "  [new] qqX update: %s %s is available " "$qqX_CurrentReleaseType" "$qqX_LatestRelease"

    printf  "  [q]  quit \n\n"

    read -rp "  >  "  MainMenuChoice

  fi


  # ACTIONS: 

  if [[ $MainMenuChoice == "h" ]] ; then

    show_quickemu_WRAP_help

   elif [[ $MainMenuChoice == "del" ]]; then 

    function_delete_Selected_VM  "$VM_InstanceName"  "$VM_Conf_File"

  elif [[ $MainMenuChoice == "hdw" ]] ; then

    AddHW_Record=

    if [[ -e "$QemuArgsFile" ]]; then 

      printf "\033c"

      if [[ -e "$QemuVirtHardwareRecord" ]]; then printf "\n\n  Existing Record: \n\n"; cat "$QemuVirtHardwareRecord"; fi

      printf "\n\n  Current Args / Qemu Virtual Hardware \n\n"
    
      cat "$QemuArgsFile"
      
      if [[ -e "$QemuVirtHardwareRecord" ]]; then printColor "  Copy Current Args onto the end of existing record list?\n\n"

      else printColor "  Create new Virtual Hardware Record using Current Args?\n\n"

      fi

      read -rp "  [enter] to continue  [b] to go back"  AddHW_Record

      if [[ $AddHW_Record != "b" ]]; then 
             
        cat "$QemuArgsFile" >> "$QemuVirtHardwareRecord"

      fi

    else

      printf "\n\n  No Args log found. The virtual machine launch process must be run first. \n\n"

      printf "\n\n  The 'VerboseArgs' option may be used, which will allow checking.  \n\n"

    fi 

  elif [[ $MainMenuChoice == "u" ]] ; then

    if [[ ! $ShowUtilsMenu ]]; then ShowUtilsMenu=1 ; else ShowUtilsMenu= ; fi

  elif [[ $MainMenuChoice == "set" ]] ; then

    qqX_edit_settings

  elif [[ $MainMenuChoice == "new" ]] ; then

    printf "\033c \n\n"

    function_qqX_printf_logo_title  "qqX updater"

    printf "\n\n\n  https://github.com/TuxVinyards/qqX/releases/latest" 

    if [[ $qqX_LatestTarBall ]] ; then

      if [[ $qqX_Latest_Secure_TarBall ]]; then printColor "\n\n  %s"  "$qqX_Latest_Secure_TarBall"

      else  printColor "\n\n  %s"  "$qqX_LatestTarBall"
      
      fi

      AboutRelease="$(grep -s 'body' "/tmp/latest-qqX")"

      AboutRelease="$(tr -cd '[:print:]' <<< "$AboutRelease")"

      AboutRelease="$(cut -d ':' -f2 <<< "$AboutRelease")"

      AboutRelease="${AboutRelease//\"/}"

      AboutRelease="${AboutRelease//'###'/}"

      AboutRelease="${AboutRelease//'##'/}"

      AboutRelease="${AboutRelease//'\n'/}"

      AboutRelease="${AboutRelease//'\r'/}"

      IFS='-' read -ra AboutReleaseArray <<< "$AboutRelease"

      # declare -p AboutReleaseArray

      for Line in "${AboutReleaseArray[@]}" ; do

        printf "\n\n  %s"  "$Line" 

      done

      printColor "\n\n\n  Secure Download the tarball to: "
      
      [[ -d "$HOME/Downloads" ]] && printf "\n\n  [d] Downloads folder  %s"  "$HOME/Downloads"

      if [[ $(pwd) == "$Default_VM_Folder" ]]; then 
      
        printColor "\n\n  [enter] Current/Default Folder  %s "  "$(pwd)" 

      else  
        
        printf "\n\n  [f] Default VM folder  %s"  "$Default_VM_Folder"

        printColor "\n\n  [enter] Current Folder  %s "  "$(pwd)"  

      fi 

    else

      printColor "\n\n  ERROR  No latest release found.  Reload & retry ..."

    fi

    printf "\n\n  or [b] to go back \n\n"

    read -rp "  >  "  qqX_LatestTarBall_Folder

    printf "\n\n"

    if [[ $qqX_LatestTarBall_Folder == "d" ]]; then  qqX_LatestTarBall_Folder="$HOME/Downloads"

    elif [[ $qqX_LatestTarBall_Folder == "f" ]]; then  qqX_LatestTarBall_Folder="$Default_VM_Folder"

    elif [[ $qqX_LatestTarBall_Folder == "b" ]]; then  qqX_LatestTarBall_Folder=

    else qqX_LatestTarBall_Folder="$(pwd)"

    fi

    if [[ $qqX_LatestTarBall_Folder ]]; then 

      if [[ ! -d "$qqX_LatestTarBall_Folder/qqX.releases" ]]; then

        mkdir "$qqX_LatestTarBall_Folder/qqX.releases" ||  printColor "\n\n  ERROR  making qqX.releases folder"

      fi

      qqX_LatestTarBall_Folder="$qqX_LatestTarBall_Folder/qqX.releases"

      ReturnFolder="$(pwd)"

      cd "$qqX_LatestTarBall_Folder"  || printColor "\n\n  ERROR  changing to qqX.releases folder"

      if [[ $qqX_Latest_Secure_TarBall ]]; then
        
        wget "$qqX_Latest_Secure_TarBall" -O "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}.tar.gz"

        wget "$qqX_Latest_Secure_TarSha" -O "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}.tar.gz.sha256"

        SHA_Check="$(sha256sum -c "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}.tar.gz.sha256")"

        printColor "\n  SHA256 Check: %s "  "$SHA_Check"

        [[ "$SHA_Check" != *'OK' ]] &&  printf "\n\n  ERROR  - RETRY  DOWNLOAD \n\n"
      
      else

        wget "$qqX_LatestTarBall" -O "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}.tar.gz"

      fi

      printColor "\n\n  Files downloaded to %s"  "$qqX_LatestTarBall_Folder"

      printf "\n\n\n  [enter] to run the installer script   [r] to return to main menu \n\n"

      read -rp "  >  "  qqX_UpdateExit

      if [[ $qqX_UpdateExit != "r" ]]; then 

        # https://stackoverflow.com/questions/651018/opening-a-tar-gz-file-with-a-single-command

        tar xvfz "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}.tar.gz" 

        cd "$qqX_LatestTarBall_Folder/qqX-${qqX_LatestRelease}" || printColor "\n\n  ERROR  changing to qqX.releases folder"

        exec  "./qqX_setup_and_install"  "Upgrade" 

      fi

    fi

    sleep 0.6

    cd "$ReturnFolder"  || printColor "\n\n  ERROR  returning from qqX.releases folder"


  elif [[ $MainMenuChoice == "conf" ]] ; then

    qqX_edit_settings  conf

  elif [[ $MainMenuChoice == "gt" ]] ; then

    function_quick_get_wrap

  elif [[ $MainMenuChoice == "z" ]] ; then

    if [[ $Zsync_Updatable_ISO && $Zsync_OS_Name && $Zsync_Release_Name ]]; then

      function_quick_get_wrap

    else 

      printColor "\n\n  %s is not being recognised as Zsync updatable Release \n\n"   "$VM_InstanceName"

    fi

  elif [[ $MainMenuChoice == "m" ]] ; then

    KVM_MSR_selector_LoadHelp=1
    select_msr_config

  elif [[ $MainMenuChoice == "d" ]] ; then 

    printf "\n\n"

    eval quickemu "-vm $VM_Conf_File --vm_boot  $SDL_ScrnPcnt_Cmd  $Extra_QE_Params" 

    [[ $InstancePID ]] && printf "\n  SDL: Use guest based display resize. Avoid resizing with the host mouse ...\n\n"

    function_KillPID_Menu
        
  elif  [[ $MainMenuChoice == "s" ]] ; then

    printf "\n\n"

    eval quickemu "-vm $VM_Conf_File --vm_boot --display spice  $Extra_QE_Params"

    #  https://qemu.readthedocs.io/en/latest/system/invocation.html#hxtool-3 

    [[ $P_Kill_WaitSecs  -gt 1 ]] && P_Kill_WaitSecs="$(echo "scale=0; ($P_Kill_WaitSecs+1.5)/2" | bc 2>/dev/null)"

    function_KillPID_Menu
      
  elif  [[ $MainMenuChoice == "q" ]] ; then

    printf "\n\n"
    MainMenuChoice=
    exit directly	

  elif  [[ $MainMenuChoice == "info" ]] ; then

    drives_and_snapshots  info

    [[ $SharedDriveArgs || $SecondDriveArgs ]] && printColor "\n\n  Scroll to View "
    printf "\n\n  [enter] to return to menu \n\n "
    read -rp "  >  "  
  

  elif  [[ $MainMenuChoice == "sl" ]] ; then

    drives_and_snapshots

    [[ $SharedDriveArgs && $SecondDriveArgs ]] && printColor "\n\n  Scroll to View "
    printf "\n\n  [enter] to return to menu \n\n "
    read -rp "  >  "  
  

  elif  [[ $MainMenuChoice == "sc" ]] ; then

  drives_and_snapshots  select

  printColor "\n\n  [enter] for date.time title  OR  give [text input] descriptor   [b] back to menu " 
  SnapTitle=
  printf "\n\n"
  read -rp "  >  "  SnapTitle
  printf "\n\n"	

    [[ ! $SnapTitle ]] && SnapTitle="$(date +%b%d.%R)"
    
    if [[ $SnapTitle != "b" ]]; then 
    
      # remove spaces, make title dot separated, as easier to IFS
      SnapTitle="${SnapTitle// /.}"

      "$QEMU_IMG" snapshot -q -c "$SnapTitle" "$Selected_Drive" 

      "$QEMU_IMG" info "$Selected_Drive"

      printColor "\n\n  Drive Updated ..."

      printf "\n\n  [enter] to return to menu \n\n "
      read -rp "  >  "  

    fi


  elif  [[ $MainMenuChoice == "sd" ]] ; then

    drives_and_snapshots  select 

    printColor "\n\n %s Snapshot Delete function "  "$ModName"

    printf "\n\n %s  (reselection & cancel prompts are given before starting)" "$Selected_DriveName"

    # Create range-selectable array 
    #SnapListString="$(drives_and_snapshots | grep '[0-9][0-9]:')"
    
    SnapListString="$("$QEMU_IMG" info "$Selected_Drive" | grep '[0-9][0-9]:')"

    # turns the multiline string into raw array with one whole line for each entry making each array element

    # then line by line extract the snap number and its title:

    mapfile -t SnapListArrRaw <<< "$SnapListString"

    i=0
    SnapListArrSeparated=()

    printColor "\n\n ID   Array  Name \n\n"
    while [[ "${SnapListArrRaw[i]}" ]]; do
      IFS=' ' read -ra SnapListArrSeparated <<< "${SnapListArrRaw[i]}" 
      # prints the first two elements of each snapshot info line 
      printf "%2d    %2d    %s \n"  "${SnapListArrSeparated[0]}"  "$i"  "${SnapListArrSeparated[1]}"
      ((i+=1))
    done

    SnapListArrTotal=$((i-1))

    printColor "\n\n Enter ARRAY number [0] to [%s], either for individual snapshot, or for the start of snapshot range"  "$SnapListArrTotal"
    printf "\n\n or [full individual name] for difficult names only showing correctly in the FULL listing"
    printf "\n\n or [enter] to return to main menu "

    SnapName=
    SnapDeleteStart=
    SnapDeleteEnd=
    SnapDeleteConfirm=
    
    printf "\n\n"
    read -rp " >  "  SnapDeleteStart
    

    if [[ $SnapDeleteStart ]]; then

        SpecialSnapName="$SnapDeleteStart"

        SpecialSnapName="$(tr -d "[:digit:]" <<< "$SpecialSnapName")"

      if  [[ $SpecialSnapName ]]; then

        # restore name as valid name if, when all digits removed, there is still something
        SpecialSnapName="$SnapDeleteStart"

        printf "\n\n  Snap to delete: \"%s\"" "$SpecialSnapName"

      else

        printColor "\n\n [enter] for an individual snapshot  or give ARRAY [number] for end of range (inclusive) \n\n"
        read -rp " >  "  SnapDeleteEnd

        if [[ $SnapDeleteEnd ]]; then 
          printf "\n Array Range = %s to %s \n\n" "$SnapDeleteStart"  "$SnapDeleteEnd"

          i="$SnapDeleteStart"
          SnapListArrSeparated=()

          printColor "\n\n ID   Array  Name \n\n"
          while true; do
            IFS=' ' read -ra SnapListArrSeparated <<< "${SnapListArrRaw[i]}" 
            # prints the first two elements of each snapshot info line 
            printf "%2d    %2d    %s \n"  "${SnapListArrSeparated[0]}"  "$i"  "${SnapListArrSeparated[1]}"
            [[ $i == "$SnapDeleteEnd" ]] && break
            ((i+=1))
          done

        else         
          printf "\n Delete = ARRAY entry %s " "$SnapDeleteStart" 
          printf "\n\n  %s" "${SnapListArrRaw[SnapDeleteStart]}" 
          SnapDeleteEnd="$SnapDeleteStart"
        fi

      fi

      printColor "\n\n [enter] to delete  [b] back to main menu (or reselect) \n\n"

      read -rp " >  "  SnapDeleteConfirm


      if [[ $SnapDeleteConfirm == "b" ]]; then

        printf "\n\n Deletion schedule has been CANCELLED"

      else

        if [[ $SpecialSnapName ]]; then

          "$QEMU_IMG" snapshot -q -d "$SpecialSnapName" "$Selected_Drive" 

        else
      
          SnapDeleteRangeCounter=$SnapDeleteStart

          while [[ $SnapDeleteRangeCounter -le $SnapDeleteEnd ]]; do
            IFS=' ' read -ra SnapListArrSeparated <<< "${SnapListArrRaw[$SnapDeleteRangeCounter]}"
            SnapName="${SnapListArrSeparated[1]}"

            if [[ ! $SnapName ]]; then
              printColor "\n\n ERROR with SnapShot Array List \n\n"
              sleep 5
              exit 1
            else
              printColor "\n\n Deleting SnapShot %2d   %2d  %s \n\n"  "${SnapListArrSeparated[0]}"  "$SnapDeleteRangeCounter"  "${SnapListArrSeparated[1]}"
              
              "$QEMU_IMG" snapshot -q -d "$SnapName" "$Selected_Drive" 

            fi
            ((SnapDeleteRangeCounter+=1))
          done

        fi

        "$QEMU_IMG" info "$Selected_Drive"


      fi

      printf "\n\n [enter] to return to menu \n\n "
      read -rp " >  "  

    fi

    #  TODO  see if tiano core bios can be set to select 'misc device' instead of 'windows boot manager' 
    #        as this can cause problems when rebooting on updates
    
    #  https://github.com/tianocore/tianocore.github.io/wiki/UEFI-application

    #  https://github.com/theopolis/uefi-firmware-parser
          
  elif  [[ $MainMenuChoice == "sa" ]] ; then

    drives_and_snapshots select

    printColor "\n\n  Give number of snapshot to use  [enter] to return to menu "
    SnapNumber=
    
    printf "\n\n"
    read -rp "  >  "  SnapNumber
    printf "\n\n"	

    if [[ $SnapNumber ]]; then
    
      "$QEMU_IMG" snapshot -q -a "$SnapNumber" "$Selected_Drive" 

      printf "\n\n  May take a moment .... \n\n"
      printColor "\n\n  Snapshot %s has been applied. \n\n"  "$SnapNumber "

    fi
  
  elif [[ $MainMenuChoice == "2" || $MainMenuChoice == "3" ]] ; then

    SecondDriveCreateSize=
    DriveCreated=

    if [[ $MainMenuChoice == "3" ]] && [[ $SharedDriveArgs ]] ; then printColor "\n\n  ERROR:  a shared drive already exists. Make backups ...\n\n"

    elif [[ $MainMenuChoice == "2" ]] && [[ $SecondDriveArgs ]] ; then printColor "\n\n  ERROR:  a second drive already exists. Make backups ...\n\n"

    else

      [[ $MainMenuChoice == "2" ]] && printColor "\n\n  Create a SECOND virtual hard-drive for this VM instance:"
      
      [[ $MainMenuChoice == "3" ]] && printColor "\n\n  Create a SHARED virtual hard-drive for this VM instance:"
      
      printf "\n\n\n  Suggest 32G or higher, especially if expecting to create snapshots. Note that" 

      printf "\n\n  qcow2 disks auto-compress & will normally occupy much less of your hard drive "
      
      printf "\n\n  than that allocated.  An empty disk only takes up 70Mb when formatted."
      
      printf "\n\n  It is easier make them larger now than to resize later ... " 

      printColor "\n\n\n  [enter] create 64G   [integer] create int G   [b] go back \n\n"

      read -rp "  >  "  SecondDriveCreateSize

      [[ ! $SecondDriveCreateSize ]]  && SecondDriveCreateSize="64"

      [[ $SecondDriveCreateSize ]]  &&  SecondDriveCreateSize="$(tr -cd "[:digit:]" <<< "$SecondDriveCreateSize")"

      if [[ $SecondDriveCreateSize ]]; then 

        if [[ $MainMenuChoice == "2" ]] && grep -s -q SecondDrive "$VM_Conf_File" ; then

          printColor "\n\n  ERROR: A SecondDrive entry is already present in your .conf file ??"

          printf "\n\n  Check general settings & notes on drives set up.  Edit the configuration. \n\n"

        elif [[ $MainMenuChoice == "3" ]] && [[ ! -d "$Default_VM_Folder" ]]; then

            printf "\n\n  Default_VM_Folder not present. Edit the main settings file first. \n\n"  

        else
           
          if [[ $MainMenuChoice == "2" ]]; then

            printf "\n\n  A Storage Drive will be created in the VM's folder \n\n  %s"  "$VM_InstanceName"

          elif [[ $MainMenuChoice == "3" ]]; then 

            printf "\n\n  A folder 'SharedDrive will be created in the Default_VM_Folder \n\n  %s"  "$Default_VM_Folder"

            printf "\n\n  It may later be moved. Editing settings file: \n\n  %s" "$Q_Mod_SettingsFile"

          fi

          printColor "\n\n  [enter] to continue  [b] to go back \n\n"

          NewDriveCreate=

          read -rp "  > "  NewDriveCreate

          if [[ $NewDriveCreate != "b" ]]; then

            if [[ $MainMenuChoice == "2" ]]; then 

              printf "SecondDrive=\"%s/%s/storage.qcow2\"" "$VM_Conf_Dir" "$VM_InstanceName"  >> "$VM_Conf_File"

              "$QEMU_IMG"  create -q -f qcow2 "$VM_Conf_Dir/$VM_InstanceName/storage.qcow2" "${SecondDriveCreateSize}G"

              [[ -e "$VM_Conf_Dir/$VM_InstanceName/storage.qcow2" ]] && DriveCreated=2
          
            elif [[ $MainMenuChoice == "3" ]]; then

              "$QEMU_IMG"  create -q -f qcow2 "$Default_VM_Folder/SharedDrive/shared.qcow2" "${SecondDriveCreateSize}G"

              [[ -e "$Default_VM_Folder/SharedDrive//shared.qcow2" ]] && DriveCreated=3

              # 'sed' can get very HIEROGLYPHICAL  https://stackoverflow.com/a/9453461

              # 'awk' ?  https://stackoverflow.com/a/32995760

              #  awk :  https://stackoverflow.com/a/6541653   https://stackoverflow.com/tags/awk/info 

              #  sed awk easy methods: https://www.ubuntumint.com/insert-line-specific-line-number-linux/

              #  date ref awk:  https://unix.stackexchange.com/a/599097

              #  https://www.gnu.org/software/sed/manual/sed.html#Command_002dLine-Options   

              #  Make sure sed command works in --posix  if testing on gnu sed ...

              #  Also note here:

              #  https://stackoverflow.com/questions/6537490/insert-a-line-at-specific-line-number-with-sed-or-awk#6537587

              #  sed -i only works in GNU sed  ... 
              

              if [[ "$(sed --version | head -1)" == *'GNU'* ]] && [[ $(grep -s 'SharedDrive=' "$Q_Mod_SettingsFile" | grep -v '#' | grep -c 'SharedDrive') == 1 ]]; then

                # do a grep -c (count) & make sure that other than in comments (#) there is only one entry that is possible
                
                SharedDriveSettingsLine="$(grep -s -n 'SharedDrive=' "$Q_Mod_SettingsFile" | grep -v '#' | cut -d ':' -f 1)"

                printf "\n\n  Backing up settings file to /tmp and changing line %s \n\n"  "$SharedDriveSettingsLine"

                eval cp "$Q_Mod_SettingsFile"  "/tmp/qqX_settings.$(date +%s).old"     # REVIEW add awk version?

                eval sed -i \'"$SharedDriveSettingsLine" c\ SharedDrive=\""$Default_VM_Folder"/SharedDrive/shared.qcow2\"\'  "$Q_Mod_SettingsFile"

              else 

                printColor "\n\n  A drive has been created but the settings file will need to be edited manually \n\n"

                grep 'SharedDrive=' "$Q_Mod_SettingsFile"

                printf "\n\n"

              fi

            fi

            if [[ $DriveCreated ]]; then

              set_drive_paths

              printColor "\n  The Created Drive should now be formatted from inside a VM:"

              printf "\n\n  Use Gparted or similar to set a device table and add partition(s)"

              printf "\n\n  Read notes in main settings if older MacOS or if Windows present."

            else

              printColor "\n\n  Something went wrong. Drive not created "

            fi

          fi

        fi

      fi
        
    fi

    printf "\n\n"

    read -rp "  [enter] to return > "

    QGW_ConfEdit_DiskSize=

    QGW_ConfEdit_Qstart=



  elif [[ $MainMenuChoice == "v" ]] ; then

    if [[ $VerboseArgs ]]; then VerboseArgs=

    else VerboseArgs=1  ; fi

  
  elif [[ $MainMenuChoice == "vm" ]] ; then

    if [[ ! ${VM_Array[0,0]} ]]; then

      function_refresh_and_reload_VM_arrays

    fi

    Select_VM=1
    ByPass_VM_Array_Selector=
    ByPass_VM_Array_Loader=

  elif [[ $MainMenuChoice == "xa" ]] ; then

    MenuXA=
    MenuXA_Correct=

    printColor "\n\n  Give extra qemu arguments to use "
    printf     "\n\n  Format = grouped & with space separated elements "
    printf     "\n\n  eg.  -device  tpm-tis,tpmdev=tpm0 "

    [[ $ExtraSetArgs ]] && printf  "\n\n  Extra Set Args:  %s"  "$ExtraSetArgs"

    if [[ $ExtraArgs ]] && [[ "$ExtraArgs" != "$ExtraSetArgs" ]]; then
    
      printf  "\n\n  Extra Args:  %s"  "$ExtraArgs"

      if [[ $ExtraSetArgs ]]; then printf "\n\n  [r] reset back to Set Args only "

      else printf "\n\n  [r] remove the Extra Args " ; fi

    fi

    printf "\n\n"

    read -rp "  > "  MenuXA

    if [[ $MenuXA != "r" ]]; then

      printf "\n\n  %s %s"  "$ExtraArgs" " $MenuXA"

      printf "\n\n  Is this correct y/n ? \n\n"

      read -rp "  >  "  MenuXA_Correct

    fi

    

    if [[ $MenuXA_Correct == "n" ]]; then printColor "\n\n  Ignoring the entered Qemu Args \n\n" ; sleep 1.5 

    elif [[ $MenuXA == "r" ]]; then printColor "\n\n  Resetting \n\n" ; ExtraArgs="$ExtraSetArgs" ; sleep 1 
    
    else  ExtraArgs="$ExtraArgs $MenuXA" ; fi

    printf "\033c\n\n"


  fi

done


# vim:tabstop=2:shiftwidth=2:expandtab

## 