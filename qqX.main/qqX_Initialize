#!/usr/bin/env bash

##  qqX component to be located in folder 'qqX.main'

##  Copyright (c)  Alex Genovese   https://github.com/TuxVinyards

#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED  
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.

# 	Otherwise:  

#   Licence  GPL3   https://www.gnu.org/licenses 

##  qqX - quickemu quickget X terminal project   

## ShellCheck global disables:

# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC2024, SC154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242
#  shellcheck disable=SC1090 
#  shellcheck disable=SC2034
#  shellcheck disable=SC2154 


qqX_logo_plain() {
  
  # early loader 

  echo "  _    _   \/   "
  echo " (_|  (_|  /\ "
  echo "   |.   |.    "

}


if  [[ $NoClear ]]; then 

	printf () {

		# shellcheck disable=SC2199
		# checks for occurence of the clearing pattern within the parameter text, treating the text as a single string

		if [[ "$@" ==  '\033c'* ]]; then

			# shellcheck disable=SC2124
			# see http://www.tldp.org/LDP/abs/html/internalvariables.html#APPREF
			# and http://mywiki.wooledge.org/BashGuide/Parameters#Special_Parameters_and_Variables

			PFtext="$@"
			PFtext=${PFtext//'\033c'/}			# remove all escape clears from the printf instruction
      command echo
      command echo "  ***************************************************************************"
      sleep "$NoClear"
			command printf "$PFtext"
    else

      # let all other printf commands through
      command printf "$@"

    fi

	}

fi


if ! tput -V | grep -q ncurses 2> /dev/null; then
  printf "\n\n  Check for your OS >  \n\n  An 'ncurses' installation should normally be present. Test using 'tput -V' "
  sleep 5
  exit 1
fi

if [[ ! -d "/tmp" ]]; then
  printf "\n\n  Check for your OS >  \n\n  A directory '/tmp' should be present. A symbolic link may be needed. "
  printf "\n\n  See:  https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard"
  sleep 5
  exit 1
fi

##  Check for 'curl' and 'aria2' etc  as is often omitted from quickemu install recipes
#   & where $1 test is true if command line is being used 

if [[ ! $(type -p curl) ]] || [[ ! $(type -p aria2c) ]] || [[ ! $(type -p zsync) ]]; then
  echo
  echo "  You need to install 'curl' & 'aria2' & 'zsync' to run parts of the quickget script ..."
  echo
  if [[ $1 ]]; then exit 1 ; else read -rp "  [enter] to continue > " ; fi
fi


#  Check any MOUSE CLICK or COMMAND LINE parameters and set any initial flags
#  Further processing is done in the 'qqX_api_and_mouse_tidyup' script, after other functions have been loaded

# echo "$@"  ; echo  

if [[ $1 == "XDG" ]]; then 

  if [[ -e "$2" ]]; then

    XDG_MimeType="$(mimetype "$2" 2>/dev/null)"
   
    if [[ "$XDG_MimeType" == *'application/x-qemu-disk' ]]; then XDG_MimeType_is_QCOW=1

    elif [[ "$XDG_MimeType" == *'text/plain' ]] &&  grep -q -s 'guest_os' "$2" ; then 
    
     QCOW_RightClick= 

      # conforms to  -vm | --vm  file.conf
      VM_Conf_Dir="$(dirname "$2")"
      [[ "$VM_Conf_Dir" == '.' ]] && VM_Conf_Dir="$(pwd)"
      VM_Conf_File="$(basename "$2")"
      VM_InstanceName="${VM_Conf_File/'.conf'/}"
      shift $#

    elif [[ "$XDG_MimeType" == *'text/plain' ]] ; then
    
      QCOW_RightClick= 
      XDG_MimeType_is_QCOW=  
      QCOW_RightClick_Conf_Dir=
      echo
      qqX_logo_plain
      echo; echo " $2"; echo
      echo " qqX has been associated to open .conf (text) files via the file properties 'open-with' option."
      echo; echo; echo "<<" 
      head -20 "$2"
      echo ">>" ; echo
      FileLines="$(wc -l < "$2")"
      printf "\n This current file is plain text only. " 
      [[ $FileLines -gt 20 ]] && printf " File length %s lines \n"  "$FileLines"  &&  TextAll="[a] view full text & quit   "
      echo
      echo " [enter] to run qqX   $TextAll [q]  quit"
      echo
      read -rp " >  "   ConfOpener
      echo  

      if [[ $ConfOpener == "a" ]]; then  cat "$2"; echo; echo " [enter] to quit  "; echo; read -rp " >  "; exit 
      elif [[ $ConfOpener == "q" ]]; then exit
      else VM_InstanceName= ; XDG_MimeType_Recognised=1
      fi

    else

      XDG_StartVariant=1
      XDG_MimeType_Recognised=
      XDG_MimeType_is_QCOW=  
      
    fi

  fi

  if [[ $XDG_MimeType_is_QCOW ]]; then

    # is a right-click start on a qcow2 disk (flag is set for later)  
    shift
    
  elif [[ $2 ]]; then

    # is right click XDG but at this stage needs flagging for later analysis or other type of handling 
    XDG_StartVariant=1
    XDG_MimeType_is_QCOW= 
    shift

  else

    shift
    # set to $HOME folder and flag to run the VM selector
    cd "$HOME"  || printf "\n\n XDG .desktop starter  >  HOME Folder not found " 
    CurrentFolder="$HOME"
    XDG_GeneralDesktopStart=1

  fi

elif [[ $1 == "--version" || $1 == "-V" ]] ; then  echo "$ModVersion" ; exit 

elif [[ "$1" == *'vm' ]] && [[ $2 == *'.conf' ]]; then  

  # conforms to  -vm | --vm  file.conf
  VM_Conf_Dir="$(dirname "$2")"
  [[ "$VM_Conf_Dir" == '.' ]] && VM_Conf_Dir="$(pwd)"
  VM_Conf_File="$(basename "$2")"
  VM_InstanceName="${VM_Conf_File/'.conf'/}"
  shift $#

else 

  CurrentFolder="$(pwd)"
  
fi


#  Pick up the SETTINGS file: 

#  qqX version 1.7 starts on the removal of legacy 'qwrap' code lines. 

#  A possibilty to have a local 'dev' version setting file is retained.  May be .dot hidden or plain

[[ -e "$HOME/.qqX/qqX_settings" ]] && qqX_SettingsFile="$HOME/.qqX/qqX_settings"


if [[ -e "$qqX_SettingsFile" ]]; then  source "$qqX_SettingsFile" 

elif [[ -e "$CurrentFolder/qqX_settings" ]] && [[ "$CurrentFolder" != '/usr'* ]]; then  

  qqX_SettingsFile="$CurrentFolder/qqX_settings" ; source "$qqX_SettingsFile" 

elif [[ -e "$CurrentFolder/.qqX_settings" ]] && [[ "$CurrentFolder" != '/usr'* ]]; then  

  qqX_SettingsFile="$CurrentFolder/.qqX_settings" ; source "$qqX_SettingsFile" 
  
else  printf "\n\n  ERROR with settings file detection \n\n  Re-check Installation &/or Installation instructions \n\n" ; sleep 10 ; exit 1
  
fi


if [[ $AllowMoreLocale ]]; then

  export "LC_NUMERIC=C"
  export "LC_COLLATE=C"

else  export "LC_ALL=C"

fi

# Determine possible XDG folders 

function_xdg_start_folder () {

  #  For a .desktop start, to be run after the settings file has been loaded so that a $Default_VM_Folder can be available

  if [[ ! $(ls "$HOME/"*.conf 2> /dev/null) ]] && [[ -d "$Default_VM_Folder" ]]; then

    cd "$Default_VM_Folder"  || printf "\n\n XDG .desktop starter  >  Default_VM_Folder not found " 
    CurrentFolder="$Default_VM_Folder"

  else

    cd "$HOME"  || printf "\n\n XDG .desktop starter  >  HOME Folder not found " 
    CurrentFolder="$HOME"

  fi

}


[[ $XDG_GeneralDesktopStart ]] &&  function_xdg_start_folder


if [[ $XDG_MimeType_is_QCOW ]]; then

  QCOW_RightClick_Conf_Dir="$(dirname "$1")"
  [[ "$QCOW_RightClick_Conf_Dir" == '.' ]] && QCOW_RightClick_Conf_Dir="$(pwd)"

  QCOW_RightClick_DiskName="$(basename "$1")"  
  
  QCOW_RightClick_VM_Dir_Name="$(basename "$QCOW_RightClick_Conf_Dir")"
 
  # .desktop starts tend to open in the $HOME folder even if right clicking somewhwere else
  #  standard right-click open-with actions will use the current folder

  cd "$QCOW_RightClick_Conf_Dir" || printf "\n\n XDG .desktop starter  >  Disk's start Folder not found " 

  cd ..  || printf "\n\n XDG .desktop starter  >  Disk's root Folder not found " 

  CurrentFolder="$QCOW_RightClick_Conf_Dir"

fi

