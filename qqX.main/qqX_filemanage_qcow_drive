#!/usr/bin/env bash

##  qqX component to be located in folder 'qqX.main'

##  Copyright (c)  Alex Genovese   https://github.com/TuxVinyards
#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED  
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.
# 	Otherwise:  
#   Licence  GPL3   https://www.gnu.org/licenses 
##  qqX - quickemu quickget X terminal project   

## ShellCheck global disables:
# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC1091,SC2024, SC2154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242,SC1090,SC1091,SC2034,SC2154,SC2009  

#  MOUNTS and UNMOUNTS the Shared Drive, or other, if present, in the designated HOST File Manager
#  To be run in a separate terminal to ensure qqX main does NOT get elevated permissions

#  A CUSTOM VERSION for this file MAY BE CREATED, if wished, and placed next to this one
#  at/as "$qqX_CustomFolder/custom_filemanage_qcow_drive" which will be auto-detected 
#  and run by function 'qcow2_filemanage' in the main qqX program in the disk maintenance script

source "/tmp/qqX_nbd_vars"
source "$qqX_MainFolder/qqX_UI_chrome_up"

if [[ ! $(type -p "$FileManager") ]] ; then 
  printf "\n\n\n  File Manager ERROR: '%s' NOT found.\n" "$FileManager" ; sleep 100
fi
if [[ ! $(modinfo -n nbd) ]] ; then 
  printf "\n\n\n  Kernel module WARNING: 'nbd' NOT found. "
  printf "\n\n  Please check your distro repositories for 'linux-modules' \n"  ; sleep 100
fi
# One control window per VM. Auto-closes others if new one opened. Avoids confusion.
# New PID always goes on end of list but 'grep -c' tests fail inside the while loop so use PID check.
ThisPID="$(ps T | grep 'qqX_filemanage' | grep qcow | tr ' ' '\n' | grep -E '^[0-9]' | head -n 1)"
while ps -ef | grep 'qqX_filemanage' | grep -q qcow ; do
  ChkPID="$(ps -ef | grep 'qqX_filemanage' | grep qcow | tr ' ' '\n' | grep -E '^[0-9]' | head -n 1)"
  if [[ $ChkPID == "$ThisPID" ]] ; then break ; else kill "$ChkPID" ; fi
done

show_nbd_help () {
  printf "\n\n  One control window per VM. Auto-closes others if new one opened."
  printf "\n\n  A 'qemu-nbd' connection is separate to host file-system mounting."
  printf "\n\n  and mounted drives need to become disconnected when the VM is started up."
  printf "\n\n  Different distro NBD and file-manager behaviours may possibly occur."
  printColor "\n\n\n  Script name and location:  %s" "$0"
  printf "\n\n  View script for notes on creating Custom versions or for details of its functions" 
  [[ $TextEditor ]] && printf "\n\n  [H] View script in Text Editor"
  printf "\n\n"
}

check_sudo_nbd_active () {
  # https://superuser.com/a/1183480/2243702  
  if ! sudo -nv 2>/dev/null ; then printf "\n\n  " ; sudo -v
  fi
  if ! lsmod | grep -q nbd ; then sudo modprobe nbd max_part=8 nbds_max=4
  fi
}

check_if_target_is_connected () {
  if ps -ef | grep nbd | grep qcow | grep -q "$TargetPathName" ; then
    printf "\n\n  %s is QEMU connected" "$TargetName" ; TargetConnected=1
  else  printf "\n\n  %s is NOT QEMU CONNECTED" "$TargetName" ; TargetConnected=
  fi
}

nbd_disconnect_non_valid () {
  # Disconnect any previously connected non-shared drives from any previous VM's
  # NB qemu connection is not the same as host file system mounting
  if ps -ef | grep nbd | grep -q qcow ; then
    if [[ $MainGreppedPathName ]] && [[ "$MainGreppedPathName" != "$MainTargetPathName" ]]; then sudo qemu-nbd -d /dev/nbd1
    fi
    if [[ $SecondGreppedPathName ]] && [[ "$SecondGreppedPathName" != "$SecondTargetPathName" ]]; then sudo qemu-nbd -d /dev/nbd2
    fi
    printf "\n\n"
    # https://stackoverflow.com/questions/17921544/get-last-field-using-awk-substr#17921589
    # https://unix.stackexchange.com/questions/145672/print-last-element-of-each-row
    # https://stackoverflow.com/questions/2961635/using-awk-to-print-all-columns-from-the-nth-to-the-last#2961994
    # ps -ef | grep nbd | grep nbd2 | grep qcow | awk '{print $NF}'
    # ubuntu-22.04/storage.qcow2
  fi
}

TargetDrive="$SharedDrive"
TargetPathName="$SharedDrive"
TargetName="Shared Drive"
TargetDevice="/dev/nbd3"
MainTargetPathName="$VM_Conf_Dir/$MainDrive"
SecondTargetPathName="$VM_Conf_Dir/$SecondDrive"
SharedTargetPathName="$SharedDrive"

while true; do

  printf "\033c"
  qqX_logo_printf_title "File Manager Utility for mounting/unmounting and for connecting QCOW2 drives"
  printf "\n\n\n  This terminal window is PROCESS SEPARATED from qqX and may be LEFT OPEN, repositioned or minimized"
  printf "\n\n  The elevated permissions required to mount the drives will remain isolated."  
  printf "\n"

  [[ $ShowHelp ]] && show_nbd_help && ShowHelp=

  qf_DriveSelect=
  printColor "\n\n  %s " "${VM_InstanceName^^}"

  printf "\n\n  Available Drive(s): "
  if [[ -e "$MainDrive" ]] && [[ ! $LiveBoot ]]; then printf " Main    "; fi
  if [[ -e "$SecondDrive" ]]; then printf " Second   "; fi
  if [[ -e "$SharedDrive" ]]; then printf " Shared   "; fi

  printf "\n\n  Connected Drive(s): "
  if ps -ef | grep nbd1 | grep -q qcow; then printf " Main    " ; MainConnected=1 ; else MainConnected= ; fi
  if ps -ef | grep nbd2 | grep -q qcow; then printf " Second  " ; SecondConnected=1 ; else SecondConnected= ; fi
  if ps -ef | grep nbd3 | grep -q qcow; then printf " Shared  " ; SharedConnected=1 ; else SharedConnected= ; fi

  printf "\n\n  Mounted Drive(s):   "
  if mount -fl | grep -q '/dev/nbd1'; then printf " Main    "; fi
  if mount -fl | grep -q '/dev/nbd2'; then printf " Second  "; fi
  if mount -fl | grep -q '/dev/nbd3'; then printf " Shared  "; fi

  if [[ $MainConnected ]]; then     
    MainGreppedPathName="$(ps -ef | grep nbd1 | grep qcow | awk '{print $NF}')"
    if [[ "$MainGreppedPathName" != "$MainTargetPathName" ]]; then 
      printf "\n\n  WARNING: Main connects to %s" "$(awk -F "/" '{print $(NF-1)}' <<< "$MainGreppedPathName")"
    fi
  fi
  if [[ $SecondConnected ]]; then     
    SecondGreppedPathName="$(ps -ef | grep nbd2 | grep qcow | awk '{print $NF}')"
    if [[ "$SecondGreppedPathName" != "$SecondTargetPathName" ]]; then 
      printf "\n\n  WARNING: Second connects to %s" "$(awk -F "/" '{print $(NF-1)}' <<< "$SecondGreppedPathName")"
    fi
  fi

  printf "\n\n\n  [1] Main Drive   [2] Second Drive  [3] Shared Drive "

  printColor "\n\n  Selected = %s " "$TargetName" 
  printf " '%s'"  "$TargetDrive"

  printColor "\n\n\n  [enter] to continue   or  [number] for different selection  "
  printf "\n\n  [r] to refresh   [h] help   [q] to quit "

  printf "\n\n"
  read -rp "  >  " qf_DriveSelect

  if   [[ $qf_DriveSelect == "1" ]]; then 
    TargetDrive="$MainDrive" ; TargetPathName="$MainTargetPathName" ; TargetName="Main Drive" ; TargetDevice="/dev/nbd1"
  elif [[ $qf_DriveSelect == "2" ]]; then 
    TargetDrive="$SecondDrive" ; TargetPathName="$SecondTargetPathName" ; TargetName="Second Drive"; TargetDevice="/dev/nbd2"
  elif [[ $qf_DriveSelect == "3" ]]; then 
    TargetDrive="$SharedDrive" ; TargetPathName="$SharedDrive" ; TargetName="Shared Drive"; TargetDevice="/dev/nbd3"
  elif [[ $qf_DriveSelect == "h" ]]; then ShowHelp=1
  elif [[ $qf_DriveSelect == "H" ]]; then nohup &> /dev/null  "$TextEditor"  "$0"
  elif [[ $qf_DriveSelect == "r" ]]; then true
  elif [[ $qf_DriveSelect == "q" ]]; then exit directly
  else 
    check_sudo_nbd_active
    if [[ ! -e "$TargetPathName" ]]; then 
      printf "\n\n  ERROR: The Target Drive needs to be set up first. See the qqX Utils menu ..."
    else check_if_target_is_connected
    fi
    printColor "\n\n  [enter] to continue  [c] connect  [d] disconnect   [r] to reselect or return"
    printf "\n\n"
    read -rp "  >  " qf_DriveSelect
      
    printf "\n\n"

    if [[ $qf_DriveSelect != "r" ]]; then 

      if [[ $qf_DriveSelect == "d" ]] && [[ $TargetConnected ]]; then 
        printf "  qemu-nbd disconnecting ... \n\n  "  
        sudo qemu-nbd -d "$TargetDevice"
      elif [[ $qf_DriveSelect == "c" ]] && [[ ! $TargetConnected ]]; then 
        printf "  qemu-nbd connecting ... \n\n  " 
        nbd_disconnect_non_valid
        sudo qemu-nbd -c "$TargetDevice"  -f qcow2  "$TargetPathName"
      fi
      sleep 2

    fi

    # nohup &> /dev/null  "$FileManager"  "$VM_Conf_Dir/$VM_InstanceName" 

    # works without sudo >  umount "$(mount -fl | grep '/dev/nbd3' | awk '{print $3}')"

  fi

done


