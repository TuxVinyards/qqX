#!/usr/bin/env bash

##  qqX component to be located in folder 'qqX.main'

##  Copyright (c)  Alex Genovese   https://github.com/TuxVinyards
#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED  
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.
# 	Otherwise:  
#   Licence  GPL3   https://www.gnu.org/licenses 
##  qqX - quickemu quickget X terminal project   

## ShellCheck global disables:
# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC1091,SC2024, SC2154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242,SC1090,SC1091,SC2034,SC2154,SC2009  

#  MOUNTS and UNMOUNTS the Shared Drive, or other, if present, in the designated HOST File Manager
#  To be run in a separate terminal to ensure qqX main does NOT get elevated permissions

#  A CUSTOM VERSION for this file MAY BE CREATED, if wished, and placed next to this one
#  at/as "$qqX_CustomFolder/custom_filemanage_qcow_drive" which will be auto-detected 
#  and run by function 'qcow2_filemanage' in the main qqX program in the disk maintenance script

source "/tmp/qqX_nbd_vars"
source "$qqX_MainFolder/qqX_UI_chrome_up"

if [[ ! $(type -p "$FileManager") ]] ; then 
  printf "\n\n\n  File Manager ERROR: '%s' NOT found.\n" "$FileManager" ; sleep 100
fi
if [[ ! $(modinfo -n nbd) ]] ; then 
  printf "\n\n\n  Kernel module WARNING: 'nbd' NOT found. "
  printf "\n\n  Please check your distro repositories for 'linux-modules' \n"  ; sleep 100
fi
# One control window per VM. Auto-closes others if new one opened. Avoids confusion.
# New PID always goes on end of list but 'grep -c' tests fail inside the while loop so use PID check.
ThisPID="$(ps T | grep 'qqX_filemanage' | grep qcow | tr ' ' '\n' | grep -E '^[0-9]' | head -n 1)"
while ps -ef | grep 'qqX_filemanage' | grep -q qcow ; do
  ChkPID="$(ps -ef | grep 'qqX_filemanage' | grep qcow | tr ' ' '\n' | grep -E '^[0-9]' | head -n 1)"
  if [[ $ChkPID == "$ThisPID" ]] ; then break ; else kill "$ChkPID" ; fi
done

show_nbd_help () {
  printf "\n\n  One control window per VM. Auto-closes others if new one opened."
  printf "\n\n  A 'qemu-nbd' connection is separate to host file-system mounting."
  printf "\n\n  and mounted drives need to become disconnected when the VM is started up."
  printf "\n\n  Different distro NBD and file-manager behaviours may possibly occur."
  printColor "\n\n\n  Script name and location:  %s" "$0"
  printf "\n\n  View script for notes on creating Custom versions or for details of its functions" 
  [[ $TextEditor ]] && printf "\n\n  [H] View script in Text Editor"
  printf "\n\n"
}

check_sudo_nbd_active () {
  # https://superuser.com/a/1183480/2243702  
  if ! sudo -nv 2>/dev/null ; then printf "\n\n  " ; sudo -v
  fi
  if ! lsmod | grep -q nbd ; then sudo modprobe nbd max_part=8 nbds_max=4
  fi
}

MainTargetPathName="$VM_Conf_Dir/$MainDrive"
SecondTargetPathName="$VM_Conf_Dir/$SecondDrive"
SharedTargetPathName="$SharedDrive"

# defaults
TargetDrive="$SharedDrive"
TargetPathName="$SharedDrive"
TargetName="Shared Drive"
TargetDevice="/dev/nbd3"

# LOOP

while true; do

  printf "\033c"
  qqX_logo_printf_title "File Manager Utility for mounting/unmounting and for connecting QCOW2 drives"
  printf "\n\n\n  This terminal window is PROCESS SEPARATED from qqX and may be LEFT OPEN, repositioned or minimized"
  printf "\n\n  The elevated permissions required to prepare the drives will remain isolated."  
  printf "\n\n  Mounting of the connected drives is carried out as standard in the file-manager."  
  printf "\n"

  [[ $ShowHelp ]] && show_nbd_help && ShowHelp=

  qf_DriveSelect=
  printColor "\n\n  %s " "${VM_InstanceName^^}"

  printf "\n\n  Available Drive(s): "
  if [[ -e "$MainDrive" ]] && [[ ! $LiveBoot ]]; then printf "  Main   "; fi
  if [[ -e "$SecondDrive" ]]; then printf " Second  "; fi
  if [[ -e "$SharedDrive" ]]; then printf " Shared  "; fi

  printf "\n\n  Connected Drive(s): "
  if ps -ef | grep nbd1 | grep -q qcow; then printf "  Main   " ; MainConnected=1 ; else MainConnected= ; fi
  if ps -ef | grep nbd2 | grep -q qcow; then printf " Second  " ; SecondConnected=1 ; else SecondConnected= ; fi
  if ps -ef | grep nbd3 | grep -q qcow; then printf " Shared  " ; SharedConnected=1 ; else SharedConnected= ; fi

  printf "\n\n  Mounted Drive(s):   "
  if mount -fl | grep -q '/dev/nbd1'; then printf "  Main   "; MainTargetMountPoint="$(mount -fl | grep '/dev/nbd1' | awk '{print $3}')" ; fi
  if mount -fl | grep -q '/dev/nbd2'; then printf " Second  "; SecondTargetMountPoint="$(mount -fl | grep '/dev/nbd2' | awk '{print $3}')" ; fi
  if mount -fl | grep -q '/dev/nbd3'; then printf " Shared  "; SharedTargetMountPoint="$(mount -fl | grep '/dev/nbd3' | awk '{print $3}')" ; fi

  if [[ $MainConnected ]]; then     
    MainGreppedPathName="$(ps -ef | grep nbd1 | grep qcow | awk '{print $NF}')"
    if [[ "$MainGreppedPathName" != "$MainTargetPathName" ]]; then 
      printf "\n\n  NOTE: Main connects to %s" "$(awk -F "/" '{print $(NF-1)}' <<< "$MainGreppedPathName")"
    fi
  fi
  if [[ $SecondConnected ]]; then     
    SecondGreppedPathName="$(ps -ef | grep nbd2 | grep qcow | awk '{print $NF}')"
    if [[ "$SecondGreppedPathName" != "$SecondTargetPathName" ]]; then 
      printf "\n\n  NOTE: Second connects to %s" "$(awk -F "/" '{print $(NF-1)}' <<< "$SecondGreppedPathName")"
    fi
  fi

  printf "\n\n\n  [1] Main Drive   [2] Second Drive  [3] Shared Drive    [A] All Drives  [a] all Non-Shared Drives "

  printColor "\n\n  Selected = %s " "$TargetName" 
  [[ $TargetName != All* ]] && printf " '%s'"  "$TargetDrive"

  printColor "\n\n\n  [enter] to continue   or  [option] for different selection  "
  printf "\n\n  [r] to refresh  [f] open file-manager  [h] help   [q] to quit "

  printf "\n\n"
  read -rp "  >  " qf_DriveSelect

  if   [[ $qf_DriveSelect == "1" ]]; then 
    TargetDrive="$MainDrive" ; TargetPathName="$MainTargetPathName" ; TargetName="Main Drive" ; TargetDevice="/dev/nbd1" ; TargetMountPoint="$MainTargetMountPoint"
  elif [[ $qf_DriveSelect == "2" ]]; then 
    TargetDrive="$SecondDrive" ; TargetPathName="$SecondTargetPathName" ; TargetName="Second Drive"; TargetDevice="/dev/nbd2" ; TargetMountPoint="$SecondTargetMountPoint"
  elif [[ $qf_DriveSelect == "3" ]]; then 
    TargetDrive="$SharedDrive" ; TargetPathName="$SharedDrive" ; TargetName="Shared Drive"; TargetDevice="/dev/nbd3" ; TargetMountPoint="$SharedTargetMountPoint"
  elif [[ $qf_DriveSelect == "A" ]]; then TargetName="All Drives"
  elif [[ $qf_DriveSelect == "a" ]]; then TargetName="All Non-Shared"
  elif [[ $qf_DriveSelect == "h" ]]; then ShowHelp=1
  elif [[ $qf_DriveSelect == "H" ]]; then nohup &> /dev/null  "$TextEditor"  "$0" &
  elif [[ $qf_DriveSelect == "f" ]]; then nohup &> /dev/null  "$FileManager"  "$VM_Conf_Dir" &
  elif [[ $qf_DriveSelect == "r" ]]; then true
  elif [[ $qf_DriveSelect == "q" ]]; then exit directly
  else 
    check_sudo_nbd_active
    if [[ $TargetName != All* ]] && [[ ! -e "$TargetPathName" ]]; then 
      printf "\n\n  ERROR: The Target Drive needs to be set up first. See the qqX Utils menu ..."
    fi
    printColor "\n\n  [c] connect  [d] disconnect and unmount  [enter] [r] to reselect or return"
    printf "\n\n  Connected drives should be mounted as standard in the file-manager."  

    printf "\n\n"
    read -rp "  >  " qf_DriveSelect
      
    printf "\n\n"

    if [[ $qf_DriveSelect ]] && [[ $qf_DriveSelect != "r" ]]; then 

      if [[ $qf_DriveSelect == "c" || $qf_DriveSelect == "d" ]]; then 
        printf "  checking mounts ... \n\n"
        if [[ "$TargetName" == All* ]]; then  
          [[ $MainTargetMountPoint ]] && umount "$MainTargetMountPoint"
          [[ $SecondTargetMountPoint ]] && umount "$SecondTargetMountPoint"
          if [[ $TargetName == "All Drives" ]]; then  
            [[ $SharedTargetMountPoint ]] && umount "$SharedTargetMountPoint"
          fi
        else
          TargetMountPoint="$(mount -fl | grep "$TargetDevice" | awk '{print $3}')" 
          [[ $TargetMountPoint ]] && umount "$TargetMountPoint"
        fi
      fi

      # Qcow2 mount is a complex procedure > use File Manager to do it as much easier
      # But drive must be un-mounted in order to connect, which happily is relatively easy 

      if [[ $qf_DriveSelect == "d" ]]; then 
        printf "  qemu-nbd disconnecting ... \n\n"
        if [[ "$TargetName" == All* ]]; then  
          sudo qemu-nbd -d "/dev/nbd1"
          sudo qemu-nbd -d "/dev/nbd2"
          if [[ $TargetName == "All Drives" ]]; then  
            sudo qemu-nbd -d "/dev/nbd3"
          fi
        else
          sudo qemu-nbd -d "$TargetDevice"
        fi

      elif [[ $qf_DriveSelect == "c" ]]; then 
        printf "  qemu-nbd connecting ... \n\n" 

        if [[ "$TargetName" == All* ]]; then  
          sudo qemu-nbd -c "/dev/nbd1"  -f qcow2  "$MainTargetPathName"
          sudo qemu-nbd -c "/dev/nbd2"  -f qcow2  "$SecondTargetPathName"
          if [[ $TargetName == "All Drives" ]]; then  
            sudo qemu-nbd -c "/dev/nbd3"  -f qcow2  "$SharedTargetPathName"
          fi
        else
          sudo qemu-nbd -c "$TargetDevice"  -f qcow2  "$TargetPathName"
        fi

      fi

      sleep 2

    fi

  fi

done

# https://stackoverflow.com/questions/17921544/get-last-field-using-awk-substr#17921589
# https://unix.stackexchange.com/questions/145672/print-last-element-of-each-row
# https://stackoverflow.com/questions/2961635/using-awk-to-print-all-columns-from-the-nth-to-the-last#2961994

# https://code.visualstudio.com/  (recommended)
# vim:tabstop=2:shiftwidth=2:expandtab

