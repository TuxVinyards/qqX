#!/usr/bin/env bash

##  qqX component to be located in folder 'qqX.main'

##  Copyright (c)  Alex Genovese   https://github.com/TuxVinyards
#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED  
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.
# 	Otherwise:  
#   Licence  GPL3   https://www.gnu.org/licenses 
##  qqX - quickemu quickget X terminal project   

## ShellCheck global disables:
# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC1091,SC2024, SC2154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242,SC1090,SC1091,SC2034,SC2154,SC2009  

#  MOUNTS and UNMOUNTS the Shared Drive, or other, if present, in the designated HOST File Manager
#  To be run in a separate terminal to ensure qqX main does NOT get elevated permissions

#  A CUSTOM VERSION for this file MAY BE CREATED, if wished, and placed next to this one
#  at/as "$qqX_MainFolder/custom_filemanage_qcow_drive" which will be auto-detected 
#  and run by function 'qcow2_filemanage' in the main qqX program in the disk maintenance script

source "/tmp/qqX_nbd_vars"
source "$qqX_MainFolder/qqX_UI_chrome_up"

if [[ ! $(type -p "$FileManager") ]] ; then 
  printf "\n\n\n  File Manager ERROR: '%s' NOT found.\n" "$FileManager" ; sleep 100
fi
if [[ ! $(modinfo -n nbd) ]] ; then 
  printf "\n\n\n  Kernel module WARNING: 'nbd' NOT found. "
  printf "\n\n  Please check your distro repositories for 'linux-modules' \n"  ; sleep 100
fi
# One control window per VM. Auto-closes others if new one opened. Avoids confusion.
# New PID always goes on end of list but 'grep -c' tests fail inside the while loop so use PID check.
ThisPID="$(ps T | grep 'qqX_filemanage' | grep qcow | tr ' ' '\n' | grep -E '^[0-9]' | head -n 1)"
while ps -ef | grep 'qqX_filemanage' | grep -q qcow ; do
  ChkPID="$(ps -ef | grep 'qqX_filemanage' | grep qcow | tr ' ' '\n' | grep -E '^[0-9]' | head -n 1)"
  if [[ $ChkPID == "$ThisPID" ]] ; then break ; else kill "$ChkPID" ; fi
done

show_nbd_help () {
  printf "\n\n  One control window per VM. Auto-closes others if new one opened."
  printf "\n\n  A 'qemu-nbd' connection is separate to host file-system mounting."
  printf "\n\n  and mounted drives need to become disconnected when the VM is started up."
  printColor "\n\n\n  Script name and location:  %s" "$0"
  printf "\n\n  View script for notes on creating Custom versions or for details of its functions" 
  [[ $TextEditor ]] && printf "\n\n  [H] View script in Text Editor"
  printf "\n\n"
}

check_sudo_nbd_active () {
  # https://superuser.com/a/1183480/2243702  
  if ! sudo -nv 2>/dev/null ; then printf "\n\n  " ; sudo -v
  fi
  if ! lsmod | grep -q nbd ; then sudo modprobe nbd 
  fi
}

check_if_target_is_connected () {
  if ps -ef | grep nbd | grep qcow | grep -q "${TargetDrive:0:15}" ; then
    printf "\n\n  %s is QEMU mounted" "$TargetName" ; TargetConnected=1
  else  printf "\n\n  %s is NOT QEMU MOUNTED" "$TargetName" ; TargetConnected=
  fi
}

# Disconnect any previously connected non-shared drives from any previous VM's
# NB qemu connection is not the same as host file system mounting
if ps -ef | grep nbd | grep -v nbd3 | grep -q qcow ; then
  check_sudo_nbd_active
  sudo qemu-nbd -d /dev/nbd1
  sudo qemu-nbd -d /dev/nbd2
  printf "\n\n"
  sleep 1.5
fi


TargetDrive="$SharedDrive"
TargetName="Shared Drive"

while true; do

  printf "\033c"
  qqX_logo_printf_title "File Manager Utility for mounting/unmounting and for connecting QCOW2 drives"
  printf "\n\n\n  This terminal window is PROCESS SEPARATED from qqX and may be LEFT OPEN, repositioned or minimized"
  printf "\n\n  The elevated permissions required to mount the drives will remain isolated."  
  printf "\n"

  [[ $ShowHelp ]] && show_nbd_help && ShowHelp=

  qf_DriveSelect=
  printColor "\n\n  Distro Focus = '%s' " "$VM_InstanceName"

  printf "\n\n  Qemu NBD connected Drive(s): \n"
  ps -ef | grep nbd | grep qcow

  printf "\n\n  [1] Main Drive   [2] Second Drive  [3] Shared Drive "

  printf "\n\n  Selected = %s  '%s'" "$TargetName" "$TargetDrive"

  if [[ ! $TargetDrive || ! -e "$TargetDrive" ]]; then 
    printf "\n\n  ERROR: The Target Drive needs to be set up first. See the qqX Utils menu ..."
  fi

  printColor "\n\n\n  [enter] open selected drive in file manager  or  [number] for different selection"
  printf "\n\n  [h] help   [q] to quit "

  printf "\n\n"
  read -rp "  >  " qf_DriveSelect

  if   [[ $qf_DriveSelect == "1" ]]; then TargetDrive="$MainDrive" ; TargetName="Main Drive" ; TargetDevice="/dev/nbd1"
  elif [[ $qf_DriveSelect == "2" ]]; then TargetDrive="$SecondDrive" ; TargetName="Second Drive"; TargetDevice="/dev/nbd2"
  elif [[ $qf_DriveSelect == "3" ]]; then TargetDrive="$SharedDrive" ; TargetName="Shared Drive"; TargetDevice="/dev/nbd3"
  elif [[ $qf_DriveSelect == "h" ]]; then ShowHelp=1
  elif [[ $qf_DriveSelect == "H" ]]; then nohup &> /dev/null  "$TextEditor"  "$0"
  elif [[ $qf_DriveSelect == "q" ]]; then exit directly
  else 
    check_sudo_nbd_active
    check_if_target_is_connected
    printColor "\n\n  [enter] to continue  [m] mount / un-mount  [r] to reselect or return"
    printf "\n\n"
    read -rp "  >  " qf_DriveSelect
      
    printf "\n\n"

    if [[ $qf_DriveSelect != "r" ]]; then 

      printf "\n\n  qemu-nbd connecting / disconnecting ... "  ; sleep 2

      if [[ $TargetConnected ]]; then sudo qemu-nbd -d "$TargetDevice"
      else sudo qemu-nbd -c "$TargetDevice"  -f qcow2 "$TargetDrive"
      fi

    fi

    # nohup &> /dev/null  "$FileManager"  "$VM_Conf_Dir/$VM_InstanceName" 

  fi

done


