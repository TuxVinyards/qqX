#!/usr/bin/env bash

##  qqX component to be located in folder 'qqX.main'

##  Copyright (c)  Alex Genovese   https://github.com/TuxVinyards
#   SMALL CODE SNIPPETS eg the function printColor MAY BE USED  
#   PERMISSIVELY in projects as MIT or similar, providing CLEAR ATTRIBUTIONS are shown.
# 	Otherwise:  
#   Licence  GPL3   https://www.gnu.org/licenses 
##  qqX - quickemu quickget X terminal project   

## ShellCheck global disables:
# https://www.shellcheck.net/wiki/SC2242 as it clashes with use of exit traps used to keep mouse click scripts open
# And SC1090,SC1091,SC2024, SC2154 for necessity of dynamic file sourcing

#  shellcheck disable=SC2242,SC1090,SC1091,SC2034,SC2154,SC2009 

# Find the right version for the standard 'quickget' call 
# which is only used in simple API wrapping mode, for now ...

function quickget {

  # To be run after rerouting functions for quickemu & quickget are in place & code has been sourced.
  # And if rerunning after a settings change, to be run after 'find_quickemu_source_functions_and_vars' 
  # has been, so that the right QE & QG versions have been established and loaded.
  # See function 'refresh_and_load_quickemu_sources'
  
  eval command '"$QG_SourcePath"' " $*"
  
}

QGW_OS_Array=()

load_QGW_OS_Array () {
  QGW_OS_ListRaw="$(quickget "qq-grep" | tail -n +3 )"
  QGW_OS_ListString="$(tr '\n' ' ' <<< "$QGW_OS_ListRaw")"
  QGW_OS_ListString="$(tr -cd "[:print:]" <<< "$QGW_OS_ListString")"
  read -ra QGW_OS_Array <<< "$QGW_OS_ListString"
}


print_quickget_and_folder_choices () {

  # listing function, originally for use inside 'function_quick_get_wrap'  
  # adapted with $2 EITHER as number per line OR for alpha zooming filter
  # and for use for listing target folder selections for installing or moving VM's

  declare -n  QGW_List_ArrName="$1"

  #printf "\n * %s" "${QGW_List_ArrName[@]}" 

  QGW_List_Arr_ItemLength=15

  if [[ "$2" == [1-9] ]]; then QGW_List_NewLinePoint="$2"; else QGW_List_NewLinePoint="7"; fi
  # default QGW_List_NewLinePoint = 7  but some functions may reduce this to as low as 2 or 3

  if [[ $Force_GetList_NewLinePoint ]] && [[ $Force_GetList_NewLinePoint -lt "$QGW_List_NewLinePoint" || $Force_GetList_NewLinePoint -gt "7" ]] ; then 
    QGW_List_NewLinePoint="$Force_GetList_NewLinePoint"
  fi

  # set flags and transfer arrays
  QGW_TxArr=()
  if [[ $2 == "UbuntuOthers" ]]; then QGW_List_UbuntuOthers=1;  else QGW_List_UbuntuOthers=; fi
  if [[ "$2" == [a-z] ]]; then QGW_List_AlphaFilter="$2";  else QGW_List_AlphaFilter=; fi

  # set vars:
  QGW_List_ArrNum=0
  QGW_List_ArrNum_Last="${#QGW_List_ArrName[@]}"
  QGW_List_DisplayNum=1
  QGW_List_NewLineCounter=1

  # adjust display spacing, if needed
  i=0
  while [[ $i -le "$QGW_List_ArrNum_Last" ]] ; do
    for QGW_List_Arr_Item in "${QGW_List_ArrName[@]}" ; do    
      if [[ "${#QGW_List_Arr_Item}" -gt "$QGW_List_Arr_ItemLength" ]]; then 
        ((QGW_List_NewLinePoint-=1)); ((QGW_List_Arr_ItemLength+=5)) ; break
      fi
      ((i+=1))
    done
  done

  for QGW_List_Arr_Item in "${QGW_List_ArrName[@]}" ; do

    local TxVar=
    if [[ $QGW_List_UbuntuOthers ]] && [[ ${QGW_List_Arr_Item:2} ==  *'buntu' ]]; then
      printf -v TxVar "  %2d)  %-${QGW_List_Arr_ItemLength}s  "  "$QGW_List_DisplayNum"  "$QGW_List_Arr_Item"
      QGW_TxArr+=("$TxVar")

    elif [[ ${QGW_List_Arr_Item:0:1} == "$QGW_List_AlphaFilter" ]] ; then
      printf -v TxVar "  %2d)  %-${QGW_List_Arr_ItemLength}s  "  "$QGW_List_DisplayNum"  "$QGW_List_Arr_Item"
      QGW_TxArr+=("$TxVar")

    elif [[ ! $QGW_List_UbuntuOthers ]] && [[ ! $QGW_List_AlphaFilter || ${QGW_List_Arr_Item:0:1} == "$QGW_List_AlphaFilter" ]] ; then
      printf "  %2d)  %-${QGW_List_Arr_ItemLength}s  "  "$QGW_List_DisplayNum"  "$QGW_List_Arr_Item"; ((QGW_List_NewLineCounter+=1))
    fi

    ((QGW_List_ArrNum+=1));  ((QGW_List_DisplayNum+=1))

    if [[ ! $QGW_List_UbuntuOthers ]] && [[ ! $QGW_List_AlphaFilter ]] && [[ $QGW_List_NewLineCounter -ge "$QGW_List_NewLinePoint" ]];  then
      QGW_List_NewLineCounter=1   # reset counter
      [[ $QGW_List_ArrNum -lt "$QGW_List_ArrNum_Last" ]] &&  printf "\n\n"
    fi

  done

  QGW_Tx_ArrNum=0
  QGW_Tx_ArrNum_Last="${#QGW_TxArr[@]}"
  QGW_List_NewLineCounter=1

  for QGW_List_Arr_Item in "${QGW_TxArr[@]}"; do

    [[ $QGW_Tx_ArrNum == "0" ]] && printf "\n"
    printf "%s" "$QGW_List_Arr_Item"
    ((QGW_Tx_ArrNum+=1));  ((QGW_List_NewLineCounter+=1))

    if [[ $QGW_List_NewLineCounter -ge "$QGW_List_NewLinePoint" ]];  then
      QGW_List_NewLineCounter=1   # reset counter
      [[ $QGW_Tx_ArrNum -lt "$QGW_Tx_ArrNum_Last" ]] &&  printf "\n\n"
    fi

  done

}

function show_distro_homepage_check_results {
  # runs during start of function_quick_get_wrap and gets included at end of 'function_test_iso_url' too
  if [[ $(cat "/tmp/qmod-dl-homepage-report.txt" 2>/dev/null) ]]; then
    cat "/tmp/qmod-dl-homepage-report.txt"
  fi
}

function_test_iso_url () {

  [[ $GT_Exit ]] && return

  if ! grep -q -e '--url' "$QG_SourcePath"  && ! grep -q -e '--show-iso-url' "$QG_SourcePath" ; then

    printColor "\n\n  Link cannot be checked ... "; QGW_Download_BadLink=

  else

    printf "\n\n  Checking download link .... \n\n"
    DL_Url=
    DL_FileName=
    DL_PotentialSize=
    DL_PotentialOkay=
    DL_PotentialHtml=
    SECONDS=0
    printf "" > "/tmp/qmod-dl-url"
    # quickget --show-iso-url  is version 4.9.1  &  quickget --url from  4.9.3  onwards
    # running checks in the background (&) means that we can stop the process if it hangs
    if grep -q -e '--url' "$QG_SourcePath" ; then quickget " --url $QGW_DownloadSelection" > "/tmp/qmod-dl-url" &
    elif grep -q -e '--show-iso-url' "$QG_SourcePath" ; then quickget " --show-iso-url $QGW_DownloadSelection" > "/tmp/qmod-dl-url" &
    fi
    sleep 1
    [[ $ShowQGetLists ]] && { echo "Check URL"; (ps -ef | grep bash | grep quickget); echo; }
    DataPID="$(pgrep -af bash | grep quickget | head -n 1 | cut -d' ' -f1 2>/dev/null)"
    if [[ $DataPID ]]; then
      # only if quickget has url checking ...
      [[ $ShowQGetLists ]] && { echo; echo "DataPID: '${DataPID}'"; echo; }
      while true; do
        [[ $(cat "/tmp/qmod-dl-url") ]] && { sleep 1; break; }
        [[ "$SECONDS" -ge 12 ]] && { kill "$DataPID" &>/dev/null ; break; }
        sleep 1
      done
    fi

    DL_Url="$(awk '/http/{print $2 $3}' < "/tmp/qmod-dl-url")"
    [[ $ShowQGetLists ]] && { echo ; echo "DL_Url: $DL_Url"; echo; }
    printf "" > "/tmp/qmod-dl-size"

    if [[ ! $DL_Url ]]; then  
      printColor "\n\n  QuickGet has been timed-out providing a link, or is unable to provide one ..."; QGW_Download_BadLink=1
      iso_get_message
    else  
      DL_FileName="$(basename "$DL_Url")"
      printf "  Checking download size .... \n\n"
      [[ $ShowQGetLists ]] && { echo ; echo "DL_FileName: $DL_FileName"; echo; }
      curl --silent --location --head --output "/tmp/qmod-dl-size"  --fail --max-time 4 "$DL_Url" || echo > "/tmp/qmod-dl-size"
      if [[ ! $(cat "/tmp/qmod-dl-size" 2>/dev/null) ]]; then 
        printf "  twice ........ \n\n"
        curl --silent --location --head --output "/tmp/qmod-dl-size"  --fail --max-time 6 "$DL_Url" || echo > "/tmp/qmod-dl-size"
      fi
      if [[ $(cat "/tmp/qmod-dl-size" 2>/dev/null) ]]; then 
        DL_PotentialOkay="$(grep -s -i 'content-type' "/tmp/qmod-dl-size" | grep -i application )"
        [[ ! $DL_PotentialOkay ]] && DL_PotentialOkay="$(grep -s -i 'Vary:' "/tmp/qmod-dl-size" | grep -i 'Accept-Encoding' )"
        DL_PotentialHtml="$(grep -s -i 'content-type' "/tmp/qmod-dl-size" | grep -i html )"
        DL_PotentialSize="$(grep -s -i 'content-length' "/tmp/qmod-dl-size" | tr -cd '[:digit:]')"
      fi
      if [[ $DL_PotentialOkay ]]; then
        printColor "  Appears to be Okay "; QGW_Download_BadLink=
      else
        printf "  May not be working correctly.  Try anyway? \n\n"; QGW_Download_BadLink=
      fi
      if [[ $DL_PotentialSize ]]; then 
        DL_HumanSize="$(numfmt --to=iec "$DL_PotentialSize")"
        printf "  reported size: %s " "$DL_HumanSize"
      elif [[ $QGW_Download_BadLink ]]; then
        printf "  and reported size not available either ...."
        [[ $DL_PotentialHtml ]] && printf "\n\n  Check website or switch release/edition"
        printf "\n\n"
        iso_get_message ; show_distro_homepage_check_results
      else
        if [[ $DL_PotentialOkay ]]; then printf "  but reported size not available ?? " ; else printf "  Reported size not available ..." ; fi 
        [[ $DL_PotentialHtml ]] && printf "\n\n  Check website or switch release/edition"
        printf "\n\n"
        iso_get_message ; show_distro_homepage_check_results
      fi

    fi

  fi
}


function show_current_group_folder_list {
  i=0
  Current_VM_Folder_Recognised=
  if [[ $QWG_Conf_Dir ]]; then Current_VM_Folder="$QWG_Conf_Dir"
  elif [[ ! $Current_VM_Folder ]]; then  Current_VM_Folder="$(pwd)"
  fi
  while [[ ${VM_Folder_List[i]} ]]; do
    if [[ $Current_VM_Folder == "$Default_VM_Folder" ]]; then
      if [[ $i -eq 0 ]]; then printColor "\n  [0]  %s (current/default)"  "${VM_Folder_List[i]}"
      else printf "\n\n  [%s]  %s "  "$i" "${VM_Folder_List[i]}"
      fi
    else
      if [[ $i -eq 0 ]]; then printf "\n  [0]  %s (default)"  "${VM_Folder_List[i]}"
      elif [[ $Current_VM_Folder ==  "${VM_Folder_List[i]}" ]]; then  printColor "\n\n  [%s]  %s "  "$i" "${VM_Folder_List[i]}"
      else printf "\n\n  [%s]  %s "  "$i" "${VM_Folder_List[i]}"
      fi
    fi
    [[ ${VM_Folder_List[i]} == "$Current_VM_Folder" ]] && Current_VM_Folder_Recognised=1
    ((i +=1))
  done
}

function check_new_vm_folder_name {

  SimilarVMs=
  SimilarVM_Arr=()
  SimilarVM_Arr_Display=()

  if [[ -d "$QWG_Conf_Dir/$QWG_NewVM_Name" ]]; then

    if [[ $(ls -h "$QWG_Conf_Dir/$QWG_NewVM_Name" 2>/dev/null) ]]; then
      [[ ! $QGW_OverWriteAllow ]] && QGW_OverWriteAlert=1
    else rm -d "$QWG_Conf_Dir/$QWG_NewVM_Name" 
    fi
    
  else

    # main naming component match
    SimilarVMs+="$(ls "$QWG_Conf_Dir/${QGW_OS_Arr_NameSelected}"*.conf 2>/dev/null )"

    # first dash separated section match
    if [[ "$QGW_OS_Arr_NameSelected" == *'-'* ]]; then 
      SimilarVM_ShorterCheck="$(echo "$QGW_OS_Arr_NameSelected" | cut -d '-' -f1)"
      SimilarVMs+=" $(ls "$QWG_Conf_Dir/${SimilarVM_ShorterCheck}"*.conf 2>/dev/null )"
    fi

    # first chars in new name match to somewhere in something existing
    SimilarVM_ShorterCheck="${QGW_OS_Arr_NameSelected:0:5}"
    SimilarVMs+=" $(ls "$QWG_Conf_Dir/"*"${SimilarVM_ShorterCheck}"*.conf 2>/dev/null )"
    if [[ $SimilarVMs ]]; then
      SimilarVMs="$(tr ' ' '\n' <<< "$SimilarVMs" )"
      SimilarVMs="$(sort -u <<< "$SimilarVMs" | uniq )"
      mapfile -t  SimilarVM_Arr  <<< "$SimilarVMs"
      for Item in "${SimilarVM_Arr[@]}" ; do  
        TrimmedItem="$(basename "$Item" .conf)"
        [[ $TrimmedItem ]] && SimilarVM_Arr_Display+=("$TrimmedItem")
      done
    fi
    if [[ ${SimilarVM_Arr[*]} ]]; then  
      for DailyCheckVM in "${SimilarVM_Arr[@]}" ; do [[ "$DailyCheckVM" == *'daily'* ]] && DailyVMsPresent=1; done
      [[ $DailyVMsPresent ]] && [[ ! $QGW_OverWriteAllow ]] && QGW_OverWriteAlert=   # REVIEW 
      printColor "\n\n  CHECK TARGET > similar name match(es) found in THIS target folder: \n\n"
      print_quickget_and_folder_choices  "SimilarVM_Arr_Display" 6
      printf "\n"
    fi

  fi
}

## MAIN WRAPPING (QWG Quick Wrap Get)

function show_QWG_header {
  printf "\033c"
  qqX_logo_printf_title "$qqX_Version"
  printColor "  wrapping QUICKGET version %s '%s'  " "$QG_VerNumber"  "$QE_SourceVersion"  
  printf "(needs internet, including for some menu items & for tests) \n\n" 
}

function show_hot_swap_line {
    printColor "               Using %s:  [FS] FreeSpirit  [FB] FreeBird  [HB]  [Ech]  [Sys]  [Cust]  [Dev]" "$QE_SourceVersion"
    printf "  [H] help on different versions\n"
  if [[ $CodingHotSwap && $CodingHotSwapShow ]] || [[ $DevStart ]]; then 
    printf "\n               Code Source: %s " "$QE_SourcePath" 
    [[ $CodingHotSwap ]] && CodingHotSwapShow=
  elif [[ $QE_SourceVersion != "FreeSpirit" ]]; then
    printf "\n               FreeSpirit usually has the latest fixes and additions ...." 
  fi
  printf "\n\n"
}

function refresh_QWG_selector {
  SettingsFileAdjusted=1 ; refresh_sources_and_load_VM_arrays 
  clear_main_gt_start_vars
  show_QWG_header ; show_hot_swap_line 
  print_quickget_and_folder_choices  "QGW_OS_Array" 
  QGW_List_NumSelected= 
}

InternetUp=

function clear_main_gt_start_vars {

  # Main vars, other clearances will need less, 
  # Zsync needs special treatment, as does QGW_List_NumSelected_Next
  QGW_List_NumSelected=
  QGW_VerifiedList_NumSelected=
  QGW_OS_Arr_NumSelected=
  QGW_OS_Arr_NameSelected=
  QGW_Release_Arr_NumSelected=
  QGW_Release_Arr_NameSelected=
  QGW_Edition_Arr_NumSelected=
  QGW_Edition_Arr_NameSelected=
  QGW_DownloadStart=
  QGW_DownloadSelection=
  QGW_Download_BadLink=
  QWG_Conf_Dir="$Default_VM_Folder" 
  cd "$QWG_Conf_Dir" || { printColor "  ERROR changing to the General VM Location"; sleep 3; }
  Current_VM_Folder="$QWG_Conf_Dir" 
}

function_quick_get_wrap ()  {

  show_QWG_header
  QGW_List_NumSelected= 
  GT_Exit=
  dev_loop_check ; [[ $GeneralLoopCheck ]] && echo

  clear_main_gt_start_vars

  while [[ ! $InternetUp ]]; do  

    Test_Internet=
    tput sc
    printf  "               Checking connections ... \n\n" 

    if   curl -L -I -s -o /dev/null --max-time 4 --fail  "1.1.1.1"  2> /dev/null ; then InternetUp=1
    elif curl -L -I -s -o /dev/null --max-time 4 --fail  "cloudflare.com"  2> /dev/null ; then InternetUp=1
    elif curl -L -I -s -o /dev/null --max-time 4 --fail  "google.com"  2> /dev/null ; then InternetUp=1

    elif wget -q -T2  -t2 --spider 1.1.1.1  2> /dev/null ; then InternetUp=1
    elif wget -q -T2 -t2 --spider google.com 2> /dev/null ; then InternetUp=1
    
    # Note that 'ping' doesn't work inside a Qemu VM, so prefer wget
    # No changes to '--spider' in wget2  https://gitlab.com/gnuwget/wget2/-/wikis/home

    fi

    if [[ $InternetUp ]]; then
      printf "\e[2A" ; printf "\eK"
      printf "               Connection Looks GOOD       \n\n" 
      sleep 0.7
    else 
      printColor "\n\n  INTERNET CONNECTION NOT FOUND. Check settings and equipment "
      printf "\n\n  [enter] to re-test,  [i] ignore, continue anyway  [b] back to main menu \n\n"
      read -rp "   >  "   Test_Internet
      echo
      [[ $Test_Internet == "b" ]] &&  QGW_List_NumSelected="B"  && break   
      [[ $Test_Internet == "i" ]] && break   
    fi

    show_QWG_header

  done

  if [[ $MainMenuZsync ]] && [[ $Zsync_Updatable_ISO && $Zsync_OS_Name && $Zsync_Release_Name ]] ; then  

    QGW_OS_Arr_NameSelected="$Zsync_OS_Name"
    QGW_Release_Arr_NameSelected="$Zsync_Release_Name"
    declare -ga QGW_Releases_Array=()
    QGW_Releases_Array[0]="$QGW_Release_Arr_NameSelected"
    declare -ga QGW_Editions_Array=()

  else

    VM_Conf_File=
    VM_Conf_Dir=
    VM_InstanceName=
    MainDrive=
    IsoImg=

    show_hot_swap_line
    load_QGW_OS_Array ; print_quickget_and_folder_choices  "QGW_OS_Array"

    while true ; do

      printColor "\n\n  [a-z] to zoom or switch zoom, or OS [item number] for download or browsing OS website  [H] help  [R] REFRESH  [E] exit quickget "
      printf "\n\n" 

      [[ $QGW_List_NumSelected_Next ]] && QGW_List_NumSelected="$QGW_List_NumSelected_Next"
      QGW_VerifiedList_NumSelected=

      [[ ! $QGW_List_NumSelected ]] && read -rp "  >  "  QGW_List_NumSelected

      if [[ $QGW_List_NumSelected == "H" ]]; then  QGW_List_NumSelected= ; show_qqX_general_help ; GT_Help=1

      elif [[ $QGW_List_NumSelected == "E" ]]; then  printf "\n\n" ; GT_Exit=1 ; break 

      elif [[ $QGW_List_NumSelected == "FS"   ]] ; then  
        CodingHotSwap="FreeSpirit" ; SettingsFileAdjusted=1 ; CodingHotSwapShow=1 ; refresh_sources_and_load_VM_arrays 
      elif [[ $QGW_List_NumSelected == "FB"   ]] ; then  
        CodingHotSwap="FreeBird" ; SettingsFileAdjusted=1 ; CodingHotSwapShow=1 ; refresh_sources_and_load_VM_arrays 
      elif [[ $QGW_List_NumSelected == "HB"   ]] ; then  
        CodingHotSwap="HomeBird" ; SettingsFileAdjusted=1 ; CodingHotSwapShow=1 ; refresh_sources_and_load_VM_arrays 
      elif [[ $QGW_List_NumSelected == "Ech" || $QGW_List_NumSelected == "ECH" || $QGW_List_NumSelected == "ech" ]] ; then  
        CodingHotSwap="Echo" ; SettingsFileAdjusted=1 ; CodingHotSwapShow=1 ; refresh_sources_and_load_VM_arrays  
      elif [[ $QGW_List_NumSelected == "Sys" || $QGW_List_NumSelected == "SYS" || $QGW_List_NumSelected == "sys" ]] ; then  
        CodingHotSwap="System" ; SettingsFileAdjusted=1 ; CodingHotSwapShow=1 ; refresh_sources_and_load_VM_arrays  
      elif [[ $QGW_List_NumSelected == "Cust" || $QGW_List_NumSelected == "CUST" || $QGW_List_NumSelected == "cust" ]] ; then  
        CodingHotSwap="Custom" ; SettingsFileAdjusted=1 ; CodingHotSwapShow=1 ; refresh_sources_and_load_VM_arrays  
      elif [[ $QGW_List_NumSelected == "Dev" || $QGW_List_NumSelected == "DEV" || $QGW_List_NumSelected == "dev" ]] ; then  
        CodingHotSwap="Dev" ; SettingsFileAdjusted=1 ; CodingHotSwapShow=1 ; refresh_sources_and_load_VM_arrays  

      elif [[ $QGW_List_NumSelected == "R"  ]] ; then  refresh_QWG_selector

      elif [[ "$QGW_List_NumSelected" == [a-z] ]]; then 

        print_quickget_and_folder_choices  "QGW_OS_Array" "$QGW_List_NumSelected"

        if [[ $QGW_List_NumSelected == "u" ]]; then
          printf "  and ... \n\n"
          print_quickget_and_folder_choices  "QGW_OS_Array" "UbuntuOthers"
        fi

        if [[ $QGW_List_NumSelected == "m" ]]; then
          printf "\n\n  and ...%-${QGW_List_Arr_ItemLength}s" " "
          i=1 ; M=
          for M in "${QGW_OS_Array[@]}" ; do
            if [[ "$M" == *"linuxmint"* ]]; then printf "  %s)  %-${QGW_List_Arr_ItemLength}s" "$i" "$M" ; fi
            if [[ "$M" == *"lmde"* ]]; then printf "    %s)  linuxmint debian" "$i" ; fi
            ((i++))
          done
        fi
        i= ; M=

        if [[ $QGW_List_NumSelected == "s" ]]; then
          printf "\n\n  and ...%-${QGW_List_Arr_ItemLength}s" " "
          i=1 ; S=
          for S in "${QGW_OS_Array[@]}" ; do
            if [[ "$S" == *"opensuse"* ]]; then printf "  %s)  %-${QGW_List_Arr_ItemLength}s" "$i" "$S" ; fi
            ((i++))
          done
        fi
        i= ; S=
        
      else

        # clean up and zero any unrecognised values eg. XYZ ... should only be integers left at this point
        QGW_List_NumSelected="$(tr -cd "[:digit:]" <<< "$QGW_List_NumSelected")"

        if [[ ! $QGW_List_NumSelected ]] || [[ $QGW_List_NumSelected -gt "${#QGW_OS_Array[@]}" ]]; then 

          printColor "\n\n  Request Not Recognised \n\n"
          sleep 1.5
          refresh_QWG_selector

        else

          QGW_VerifiedList_NumSelected="$QGW_List_NumSelected"
          QGW_OS_Arr_NumSelected=$((QGW_List_NumSelected-1))
          QGW_OS_Arr_NameSelected="${QGW_OS_Array[QGW_OS_Arr_NumSelected]}"

          if [[ $QGW_OS_Arr_NameSelected == "freedos" ]]; then
            QGW_OS_Arr_NameDisplay="free dos"
          elif [[ ${QGW_OS_Arr_NameSelected: -3} == "-os" ]]; then
            QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameSelected%???}"
            QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameDisplay} os"
          elif [[ ${QGW_OS_Arr_NameSelected: -2} == "os" ]]; then
            QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameSelected%??}"
            QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameDisplay} os"
          elif [[ ${QGW_OS_Arr_NameSelected:0:4} == "open" ]]; then
            # all openxxx, at 07/2024, don't have any spaces
            QGW_OS_Arr_NameDisplay="$QGW_OS_Arr_NameSelected"
          elif [[ ${QGW_OS_Arr_NameSelected: -3} == "bsd" ]]; then
            QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameSelected%???}"
            QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameDisplay} bsd"
          elif [[ ${QGW_OS_Arr_NameSelected: -5} == "linux" ]]; then
            QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameSelected%?????}"
            QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameDisplay} linux"
          elif [[ ${QGW_OS_Arr_NameSelected:0:5} == "linux" ]]; then
            QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameSelected#?????}"
            QGW_OS_Arr_NameDisplay="linux ${QGW_OS_Arr_NameDisplay}"
          elif [[ ${QGW_OS_Arr_NameSelected:0:3} == "kde" ]]; then
            QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameSelected#???}"
            QGW_OS_Arr_NameDisplay="kde ${QGW_OS_Arr_NameDisplay}"
          else 
            QGW_OS_Arr_NameDisplay="$QGW_OS_Arr_NameSelected"
          fi

          iso_get_message () {
            if [[ "$QGW_OS_Arr_NameSelected" != "windows"* && $QGW_OS_Arr_NameSelected != "macos" ]]; then
              printColor "\n\n  qqX can also install Linux ISO's if downloaded directly from the distro's Web Pages"
              printf "\n\n  Not all distro sites can be scanned for the 'latest' releases \n\n  Right click on the downloaded ISO, then open-with > "
              printf "  HomePage = %s"  "$QGW_OS_HomePage"
            fi
          }

          iso_get_message ; printf "\n\n"

          QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameDisplay^^}"
          [[ "$QGW_OS_Arr_NameDisplay" == 'TRUENAS'* ]] && QGW_OS_Arr_NameDisplay="${QGW_OS_Arr_NameDisplay/TRUE/True}"

          printColor  "\n  %s  "  "$QGW_OS_Arr_NameDisplay"

          # Quickemu OS HOME PAGE coding format keeps changing. Varied checks are needed, eg:
          # Check for quickemu 4.9.1 empty folder error  https://github.com/quickemu-project/quickemu/pull/854
          # 4.9.2 (still numbered 4.9.1) only has 'echo 38 39' for fedora releases ...

          printColor "INFO:"

          QGW_OS_HomePage=
          QGW_OS_InfoText=

          if grep -q -s '4=Homepage' "$QG_SourcePath" ; then
            # @ 08/2024 this one is now deprecated, can't seem to be found ??
            QGW_OS_HomePage="$("$QG_SourcePath" -4 "$QGW_OS_Arr_NameSelected")"
            QGW_OS_HomePage="$(tr -cd "[:print:]" <<< "$QGW_OS_HomePage")"

          elif  grep -q -s 'os_homepage' "$QG_SourcePath" &&  ! grep -q -s -e 'echo 33 34 35 36' "$QG_SourcePath" ; then 
            # 4.9.2 onwards seems to be okay  REVIEW  
            if [[ $QGW_OS_Arr_NameSelected == "ubuntu" ]]; then  QGW_OS_HomePage="https://ubuntu.com/"
            else
              # first listing, some may have two
              QGW_OS_Info="$(grep "$QGW_OS_Arr_NameSelected)" "$QG_SourcePath" | grep -m 1 'INFO=' | cut -d '=' -f 2)"
              QGW_OS_Info="${QGW_OS_Info//';;'/}"
              QGW_OS_Info="${QGW_OS_Info//'"'/}"

              QGW_OS_Info="$(tr '|' '\n' <<< "$QGW_OS_Info")"
              mapfile -t QGW_OS_Info_ARR <<< "$QGW_OS_Info"

              QGW_OS_HomePage="${QGW_OS_Info_ARR[2]}"
              QGW_OS_InfoText="${QGW_OS_Info_ARR[3]}"
            fi
          fi

          if [[ $QGW_OS_InfoText ]]; then printf "\n\n" ; fmt -u -w "$(tput cols)" <<< "  $QGW_OS_InfoText"
          else printf "\n\n  Not available, see webpage for more details \n\n"
          fi

          if [[ $QGW_OS_HomePage ]]; then 
            printf "\n  Checking Distro Home Page ....\n\n"
            printf "" > "/tmp/qmod-dl-homepage-report.txt"
            {
              printf "  HomePage = %s"  "$QGW_OS_HomePage"
              if curl --location --silent --head --output /dev/null --max-time 4 --fail "$QGW_OS_HomePage" ; then  printf " (working)"
              elif curl --location --silent --head --output /dev/null --max-time 8 --fail "$QGW_OS_HomePage" ; then  printf " (working, slowly ...)"
              else 
                [[ "$QGW_OS_Arr_NameSelected" == "windows"* ]] && printf "\n\n  Microsoft download limiter: access appears blocked to this IP address. Try later or try router reboot ... ?"
                printf "\n\n  Downloads might work but HOME PAGE LINK APPEARS BROKEN OR SITE IS DOWN ... " 
              fi
            } >> "/tmp/qmod-dl-homepage-report.txt"
          fi
          show_distro_homepage_check_results
          break
      
        fi

      fi

      [[ $GeneralLoopCheck ]] && printf "\n\n End of Quickget first loop, stage 1:" &&  dev_loop_check


      if [[ $CodingHotSwapShow || $GT_Help ]]; then
        show_QWG_header ; show_hot_swap_line
        # different versions have different distro selections
        load_QGW_OS_Array ; print_quickget_and_folder_choices  "QGW_OS_Array" 
        GT_Help= 
      fi

      # End point of main OS selection loop
      QGW_List_NumSelected=

      [[ $GeneralLoopCheck ]] && printf "\n\n End of Quickget first loop, stage 2:" &&  dev_loop_check
      
    done


    if [[ $GT_Exit ]]; then 
      Zsync_OS_Name=
      Zsync_Release_Name=
      QGW_List_NumSelected_Next=
      clear_main_gt_start_vars
      return 
    fi

    printf "\n\n  Checking releases ... \n\n\n"

    declare -ga QGW_Releases_Array=()
    declare -ga QGW_Editions_Array=()
    declare -ga QGW_FullEditions_Array=()
    QGW_ReleasesEditions_ListRaw=
    QGW_Releases_ListRaw=
    QGW_Releases_List=
    QGW_Editions_FullList=
    QGW_Editions_FullListRaw=
    QGW_Editions_FullListString=
    QGW_Editions_FullListTotal="0"

    # running checks in the background (&) means that we can stop the process if it hangs
    printf "" > "/tmp/quickget-rels-data.txt"
    quickget "$QGW_OS_Arr_NameSelected" > "/tmp/quickget-rels-data.txt" &
    sleep 0.5
    [[ $ShowQGetLists ]] && { echo "Check 1"; (pgrep -af bash | grep quickget &); echo; }
    DataPID="$(pgrep -af bash | grep quickget | head -n 1 | cut -d' ' -f1 2>/dev/null)"
    [[ $ShowQGetLists ]] && { echo; echo "DataPID: '${DataPID}'"; echo; }
    DataCount="0"
    QGW_ChkLoop=
    while true; do
      if grep -qs 'ERROR! You must specify' "/tmp/quickget-rels-data.txt"; then
        QGW_ReleasesEditions_ListRaw="$(grep -A 10 Releases "/tmp/quickget-rels-data.txt" | grep -B 10 ERROR | grep -v ERROR )"
        break
      fi
      [[ $ShowQGetLists ]] && { echo "Check loop"; (ps -ef | grep bash | grep quickget); echo; }
      read -rt 0.5  QGW_ChkLoop
      ((DataCount+=1))
      [[ "$DataCount" == '6' ]] && printf "  Checking the Distro Servers ...\n\n"
      [[ "$DataCount" == '12' ]] && printf "  Servers are busy or you have been throttled ...\n\n"
      [[ "$DataCount" == '20' ]] && printf "  [c] cancel and retry later ? \n\n"
      [[ "$DataCount" == '50' && $DataPID ]] && { kill "$DataPID" &>/dev/null ; break; }
      # use full '-n' test here or switching focus back from a dev side-terminal will trigger the read function
      [[ -n $QGW_ChkLoop && $DataPID ]] && { kill "$DataPID" &>/dev/null ; break; }
      [[ -n $QGW_ChkLoop ]] && break
    done

    [[ $ShowQGetLists ]] && { echo "Raw RE "; echo "$QGW_ReleasesEditions_ListRaw"; echo; }

    if [[ "$QGW_ReleasesEditions_ListRaw" == *'Editions'* ]]; then 
      QGW_Releases_ListRaw="$(grep -B 10  Editions  <<< "$QGW_ReleasesEditions_ListRaw" | grep -v Editions)"
      # also get editions full list for later > some releases have different editions available
      QGW_Editions_FullListRaw="$(grep -A 10  Editions  <<< "$QGW_ReleasesEditions_ListRaw")"
      QGW_Editions_FullList="$(cut -f2- <<< "$QGW_Editions_FullListRaw"| tr ' ' '\n')"
      # try to make sure the list is not just empty space 
      QGW_Editions_FullList="$(grep -E ^'[[:graph:]]' <<< "$QGW_Editions_FullList" )"
      mapfile -t QGW_FullEditions_Array <<< "$QGW_Editions_FullList"
      QGW_Editions_FullListString="${QGW_FullEditions_Array[*]}"
      QGW_Editions_FullListTotal="${#QGW_FullEditions_Array[@]}"
      [[ $ShowQGetLists ]] && { echo "List E Full "; echo "$QGW_Editions_FullListString"; echo; }
      [[ $ShowQGetLists ]] && { echo; declare -p QGW_FullEditions_Array; echo; }
    else
      QGW_Releases_ListRaw="$QGW_ReleasesEditions_ListRaw"
    fi
    
    [[ $ShowQGetLists ]] && { echo "Raw R "; echo "$QGW_Releases_ListRaw"; echo; }
    [[ $ShowQGetLists ]] && { echo "Raw E "; echo "$QGW_Editions_FullListRaw"; echo; }
    [[ $ShowQGetLists ]] && { echo "List E "; echo "$QGW_Editions_FullList"; echo; }

    # quickget outputs with a tab separator which is cut -d default
    QGW_Releases_ListRaw="$(cut -f2- <<< "$QGW_Releases_ListRaw" | tr ' ' '\n' )"
    [[ $ShowQGetLists ]] && { echo "List R raw"; echo "$QGW_Releases_ListRaw"; echo; }

    # try to make sure the list is not just empty space 
    QGW_Releases_List="$(grep -E ^'[[:graph:]]' <<< "$QGW_Releases_ListRaw" )"
    [[ $ShowQGetLists ]] && { echo "List R "; echo "$QGW_Releases_List"; echo; }

    mapfile -t QGW_Releases_Array <<< "$QGW_Releases_List"
    [[ $ShowQGetLists ]] && { echo; declare -p QGW_Releases_Array; echo; }

  fi

  function choose_QGW_release {

    [[ $GT_Exit ]] && return
    [[ $MainMenuZsync ]] && return

    while true ; do

      if [[ ! ${QGW_Releases_Array[*]} ]] ; then

        printColor "  QuickGet or internet ERROR, no releases found "
        printf "\n\n  Linux ISO's: Try downloading directly from the distro's Web Pages .... \n"
    
      elif [[ ${#QGW_Releases_Array[@]} -eq 1 ]] ; then  

        printf "  One Release only:  %s " "${QGW_Releases_Array[0]}"
        printf "\n\n  Editions choice may be be possible." 
        printColor "\n\n  [enter] to continue"

      else

        print_quickget_and_folder_choices  "QGW_Releases_Array"
        printColor "\n\n\n  Give LIST number of Release"   

      fi  

      [[ $QGW_VerifiedList_NumSelected ]] && QGW_List_NumSelected="$QGW_VerifiedList_NumSelected"

      if [[ $QGW_List_NumSelected -lt "${#QGW_OS_Array[@]}" ]]; then
        QGW_List_NumSelected_Next="$QGW_List_NumSelected" ; (( QGW_List_NumSelected_Next+=1 ))
      else QGW_List_NumSelected_Next="1"
      fi

      if [[ $QGW_List_NumSelected -gt 1 ]]; then
        QGW_List_NumSelected_Previous="$QGW_List_NumSelected" ; (( QGW_List_NumSelected_Previous-=1 ))
      else QGW_List_NumSelected_Previous="${#QGW_OS_Array[@]}"
      fi

      printf "\n\n  [s] scroll to next listing  [p] to previous"  

      if [[ $WebBrowser ]] && [[ $QGW_OS_HomePage ]]; then  printf "    [w] to open listed page with web browser" 
      fi

      printf "    [b] back to main menu \n\n"   
      read -rp "  >  "  QGW_List_NumSelected  
      printf "\n\n"
    
      if [[ $QGW_List_NumSelected == "s" || $QGW_List_NumSelected == "p" || $QGW_List_NumSelected == "b" ]]; then 
        
        [[ $QGW_List_NumSelected == "p" ]] && QGW_List_NumSelected_Next="$QGW_List_NumSelected_Previous"
        [[ $QGW_List_NumSelected == "b" ]] && QGW_List_NumSelected_Next=
        QGW_List_NumSelected= 
        QGW_OS_Arr_NumSelected=
        QGW_OS_Arr_NameSelected=
        function_quick_get_wrap
        return

      elif [[ $QGW_List_NumSelected == "w" ]]; then 

        nohup &> /dev/null  "$WebBrowser"  "$QGW_OS_HomePage"  & 
        QGW_List_NumSelected_Next="$QGW_VerifiedList_NumSelected"
        QGW_List_NumSelected="$QGW_VerifiedList_NumSelected"
        QGW_Release_Arr_NumSelected=$((QGW_List_NumSelected-1))
        QGW_Release_Arr_NameSelected="${QGW_Releases_Array[QGW_Release_Arr_NumSelected]}"


      elif [[ $QGW_List_NumSelected ]]; then 

        [[ $QGW_List_NumSelected -gt "${#QGW_Releases_Array[@]}" ]] && QGW_List_NumSelected="${#QGW_Releases_Array[@]}"
        QGW_Release_Arr_NumSelected=$((QGW_List_NumSelected-1))
        QGW_Release_Arr_NameSelected="${QGW_Releases_Array[QGW_Release_Arr_NumSelected]}"
        break

      else 

        QGW_Release_Arr_NameSelected="${QGW_Releases_Array[0]}"
        break

      fi

    done
  }

  function choose_QGW_edition {

    [[ $GT_Exit ]] && return
    [[ $MainMenuZsync ]] && return

    if [[ "$QGW_OS_Arr_NameSelected"  == "windows"* ]]; then

      printColor  "\n\n  Selected = %s  %s "  "$QGW_OS_Arr_NameSelected" "$QGW_Release_Arr_NameSelected"

      if [[ $QGW_OS_Arr_NameSelected  == "windows" ]]; then
        QGW_WinLangs_Array=("Arabic" "Brazilian Portuguese" "Bulgarian" "Chinese (Simplified)" "Chinese (Traditional)" "Croatian" "Czech" "Danish" "Dutch" \
        "English (United States)" "English International" "Estonian" "Finnish" "French" "French Canadian" "German" "Greek" "Hebrew" "Hungarian" \
        "Italian" "Japanese" "Korean" "Latvian" "Lithuanian" "Norwegian" "Polish" "Portuguese" "Romanian" "Russian" "Serbian Latin" "Slovak" \
        "Slovenian" "Spanish" "Spanish (Mexico)" "Swedish" "Thai" "Turkish" "Ukrainian")
      else
        # windows-server
        QGW_WinLangs_Array=("English (United States)" "Chinese (Simplified)" "French" "German" "Italian" "Japanese" "Russian" "Spanish")
      fi

      #  See https://github.com/quickemu-project/quickemu/issues/1113

      printf "\n\n"
      if [[ $QGW_Release_Arr_NameSelected == "8"  ||  $QGW_Release_Arr_NameSelected == "10-ltsc" ]]; then
        printf "\n\n  WARNING:  Outdated code. This release can no longer be downloaded"
        printColor "\n\n  [b] to go back \n\n"  
      else
        print_quickget_and_folder_choices  "QGW_WinLangs_Array"
        printColor "\n\n  Give LIST number of Language   [b] to go back \n\n"  
      fi
      read -rp "  >  "  QGW_List_NumSelected 

      printf "\n"  

      if [[ $QGW_List_NumSelected == "b" ]]; then  
        QGW_List_NumSelected=
        QGW_OS_Arr_NameSelected=
        QGW_Release_Arr_NameSelected=
        QGW_Edition_Arr_NameSelected=
        function_quick_get_wrap
        return
      else
        [[ $QGW_List_NumSelected -gt "${#QGW_WinLangs_Array[@]}" ]] && QGW_List_NumSelected="${#QGW_WinLangs_Array[@]}"
        # Uses Lang as edition
        QGW_Edition_Arr_NumSelected=$((QGW_List_NumSelected-1))
        QGW_Edition_Arr_NameSelected="${QGW_WinLangs_Array[QGW_Edition_Arr_NumSelected]}"
      fi

    else

      while true; do 

        printColor  "  OS / Release   =   %s  %s "  "$QGW_OS_Arr_NameSelected" "$QGW_Release_Arr_NameSelected"
        printf "\n\n  Checking editions .... \n\n\n"

        QGW_List_NumSelected=
        QGW_Edition_Arr_NumSelected=
        QGW_Edition_Arr_NameSelected=
        QGW_Editions_List=
        QGW_Editions_ListRaw=
        QGW_Editions_Array=()

        if grep -qs "editions_$QGW_OS_Arr_NameSelected" "$QG_SourcePath" ; then
          # if NO editions function is present in the code for that distro, then no editions are available
          # quickget will auto-start as no editions are available, so only check for data if a named function is present
          QGW_EditionsFunction=1
          # Check the editions list specific to the selected release     
          # running checks in the background (&) means that we can stop the process if it hangs (as with releases check)
          printf "" > "/tmp/quickget-editions-data.txt"
          quickget "$QGW_OS_Arr_NameSelected" "$QGW_Release_Arr_NameSelected" > "/tmp/quickget-editions-data.txt" &
          sleep 0.5
          [[ $ShowQGetLists ]] && { echo "Check 1"; (pgrep -af bash | grep quickget &); echo; }
          DataPID="$(pgrep -af bash | grep quickget | head -n 1 | cut -d' ' -f1 2>/dev/null)"
          [[ $ShowQGetLists ]] && { echo; echo "DataPID: '${DataPID}'"; echo; }
          DataCount="0"
          QGW_ChkLoop=
          while true; do
            if grep -qs 'ERROR! You must specify' "/tmp/quickget-editions-data.txt"; then
              QGW_Editions_ListRaw="$(grep -A 10 Editions "/tmp/quickget-editions-data.txt" | grep -B 10 ERROR | grep -v ERROR | cut -f2- )"
              break
            fi
            [[ $ShowQGetLists ]] && { echo "Check loop"; (ps -ef | grep bash | grep quickget); echo; }
            read -rt 0.5  QGW_ChkLoop
            ((DataCount+=1))
            [[ "$DataCount" == '6' ]] && printf "  Checking the Distro Servers ...\n\n"
            [[ "$DataCount" == '12' ]] && printf "  Servers are busy or you have been throttled ...\n\n"
            [[ "$DataCount" == '20' ]] && printf "  [c] cancel and retry later ? \n\n"
            [[ "$DataCount" == '50' && $DataPID ]] && { kill "$DataPID" &>/dev/null ; break; }
            # use full '-n' test here or switching focus back from a dev side-terminal will trigger the read function
            [[ -n $QGW_ChkLoop && $DataPID ]] && { kill "$DataPID" &>/dev/null ; break; }
            [[ -n $QGW_ChkLoop ]] && break
          done
          [[ $ShowQGetLists ]] && { echo "Raw E"; echo "$QGW_Editions_ListRaw"; echo; }
          QGW_Editions_List="$(tr ' ' '\n' <<< "$QGW_Editions_ListRaw" )"
          # try to make sure that the list is not just empty space
          QGW_Editions_List="$(grep -E ^'[[:graph:]]' <<< "$QGW_Editions_List" )"
          [[ $ShowQGetLists ]] && { echo "List E"; echo "$QGW_Editions_List"; echo; }

        else QGW_EditionsFunction=

        fi

        if [[ $QGW_Editions_List ]]; then
            mapfile -t QGW_Editions_Array <<< "$QGW_Editions_List"
        fi

        if [[ ! ${QGW_Editions_Array[*]} ]]; then
          if [[ $QGW_EditionsFunction && "${QGW_FullEditions_Array[*]}" && "${#QGW_Releases_Array[@]}" -gt 1 ]]; then 
            printf "  Further selection not available in this release"
            printf "\n\n  Full list (%s), all Releases: \n  %s" "$QGW_Editions_FullListTotal" "$QGW_Editions_FullListString"
            printColor "\n\n  [enter] to continue   [r] choose a different release or return to view web page   [b] back to main menu \n\n" 
          elif [[ ! "${QGW_FullEditions_Array[*]}" && "${#QGW_Releases_Array[@]}" -gt 1 ]]; then 
            printf "  No editions to select in any of the releases ..."
            printColor "\n\n  [enter] to continue   "
            printf "[r] choose a different release anyway ... or return to view web page  [b] back to main menu \n\n" 
          elif [[ ! "${QGW_FullEditions_Array[*]}" && "${#QGW_Releases_Array[@]}" -eq 1 ]]; then 
            printf "  This distro is single release option only .... "
            printColor "\n\n  [enter] to continue   [r] return to view web page   [b] back to main menu \n\n" 
          fi
          read -rp "  >  "  QGW_List_NumSelected 

        elif [[ ${#QGW_Editions_Array[@]} -eq 1 ]] ; then
          printf "  One edition found: %s \n\n" "${QGW_Editions_Array[0]}"
          QGW_Edition_Arr_NameSelected="${QGW_Editions_Array[0]}"
          if [[ "${QGW_FullEditions_Array[*]}" && "${#QGW_Releases_Array[@]}" -gt 1 ]]; then 
            printf "  Full list (%s), all Releases: \n  %s" "$QGW_Editions_FullListTotal" "$QGW_Editions_FullListString"
            printColor "\n\n  [enter] to continue   [r] choose a different release or return to view web page   [b] back to main menu \n\n" 
          else
            printColor "  [enter] to continue   [b] to go back \n\n" 
          fi
          read -rp "  >  "  QGW_List_NumSelected   

        else
          print_quickget_and_folder_choices  "QGW_Editions_Array"
          if [[ "${#QGW_Releases_Array[@]}" -gt 1 ]]; then 
            printf "\n\n  Full list (%s), all Releases: \n  %s" "$QGW_Editions_FullListTotal" "$QGW_Editions_FullListString"
            printColor "\n\n  Give LIST number of Edition   [r] choose a different release or return to view web page   [b] back to main menu \n\n" 
          else  
            printColor "\n\n  Give LIST number of Edition   [r] return to releases menu to view web page    [b] back to main menu \n\n" 
          fi
          read -rp "  >  "  QGW_List_NumSelected   

        fi 

        printf "\n\n"

        if [[ $QGW_List_NumSelected == "r" ]]; then  
          QGW_List_NumSelected=
          QGW_Release_Arr_NumSelected=
          QGW_Release_Arr_NameSelected=
          printf "  Reselecting Release: \n\n\n"
          choose_QGW_release

        elif [[ $QGW_List_NumSelected == "b" ]]; then  
          QGW_List_NumSelected=
          QGW_List_NumSelected_Next=
          QGW_OS_Arr_NameSelected=
          QGW_Release_Arr_NumSelected=
          QGW_Release_Arr_NameSelected=
          QGW_Edition_Arr_NumSelected=
          QGW_Edition_Arr_NameSelected=
          function_quick_get_wrap
          return
        
        elif [[ ${#QGW_Editions_Array[@]} -le 1 ]] ; then  break

        elif [[ "$QGW_List_NumSelected" == [0-9] || "$QGW_List_NumSelected" == [0-9][0-9] ]]; then
          [[ $QGW_List_NumSelected -gt "${#QGW_Editions_Array[@]}" ]] && QGW_List_NumSelected="${#QGW_Editions_Array[@]}"
          QGW_Edition_Arr_NumSelected=$((QGW_List_NumSelected-1))
          QGW_Edition_Arr_NameSelected="${QGW_Editions_Array[QGW_Edition_Arr_NumSelected]}"
          break

        else  QGW_List_NumSelected=

        fi

      done

    fi

  }

  function finalize_QGW_targets {

    [[ $GT_Exit ]] && return

    QGW_DownloadSelection="$QGW_OS_Arr_NameSelected  $QGW_Release_Arr_NameSelected  ""'""$QGW_Edition_Arr_NameSelected""'"

    if [[ $QGW_Edition_Arr_NameSelected ]]; then
      QWG_NewVM_Name="${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}-${QGW_Edition_Arr_NameSelected}"
    elif [[ $QGW_Release_Arr_NameSelected ]]; then
      QWG_NewVM_Name="${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}"
    else
      QWG_NewVM_Name="${QGW_OS_Arr_NameSelected}"
    fi 

    printColor "  Selected:  %s "  "$QWG_NewVM_Name"

    # TEST DOWNLOAD URL is correct and is good to go  (except Windows, where you get blocked if there too many calls)

    if [[ "$QGW_OS_Arr_NameSelected"  == "windows"* ]]; then 
      printf "\n\n  Microsoft servers may not report accurately, may block repeat attempts or may need manual download ... \n\n"
      show_distro_homepage_check_results
    elif [[ "$QGW_OS_Arr_NameSelected"  == "macos"* ]]; then 
      printf "\n\n  Apples servers may not report back accurately, but the download may still work ... \n\n"
      show_distro_homepage_check_results
    else
      function_test_iso_url
    fi

    if [[ $MainMenuZsync ]] && [[ $Zsync_Updatable_ISO ]]; then

      if [[ ! $Zsync_OS_Name || ! $Zsync_Release_Name  ]]; then

        printColor "\n\n  ERROR  Variables for OS Name &/or Release NOT found \n\n"

      else

        printf "\n\n  Updating the live boot development iso with any changes"
        printColor "\n\n  May take a while to compare & synchronize"
        if [[ $LastZsync -gt 200000 ]]; then 
          printColor " - last updated over %d days ago"  "$((LastZsync/86400))"
          printf "\n\n  Deletion and re-download can sometimes be quicker ...."
        fi
        ZsyncDownload=1

        # REVIEW Deletion and re-download may be the way to go.  Zsync has a lot of code to keep maintained ...

      fi

    elif [[ "$QGW_DownloadSelection" == *'ubuntu'* ]] && [[ "$QGW_DownloadSelection" == *'daily'* ]]; then 
    
      printColor "  ** may download with some kind of NAMING variance ** "
      ZsyncDownload=1

    else  ZsyncDownload=

    fi

    if [[ $MainMenuZsync ]] && [[ $Zsync_Updatable_ISO && $Zsync_OS_Name ]]; then 
        QWG_Conf_Dir="$VM_Conf_Dir"
        ZsyncDownload=1
    else
      QWG_Conf_Dir="$Default_VM_Folder"
    fi

    printf "\n\n"

  
    # GET READY to start download 

    # clear any accidental double pressing of the enter key to avoid any auto-starts

    read -r -t 0.2	
    read -r -t 0.1	
    read -r -t 0.1	
    read -r -t 0.1	
    read -r -t 0.1

    QGW_OverWriteAllow=
    QGW_DownloadStart=

    while true ; do

      dev_loop_check

      if [[ $MainMenuZsync ]]; then  
        QGW_OverWriteAlert=1
      elif [[ ! $QGW_Download_BadLink ]]; then
        show_current_group_folder_list
        printf "\n\n\n"
        printColor "  Installation target folder:  %s / %s "   "$QWG_Conf_Dir"  "$QWG_NewVM_Name"
      fi

      # If not sync updating, list other copies of similar VM's in the target folder
      if [[ ! $ZsyncDownload ]]; then
        SimilarVMs=
        SimilarVM_ShorterCheck=
        QGW_OverWriteAlert=
        DailyVMsPresent=
        check_new_vm_folder_name
      fi

      if [[ "${#QGW_Releases_Array[@]}" -gt 1 ]] || [[ "${#QGW_Editions_Array[@]}" -gt 1 ]]; then  
        printf "\n\n"
        [[ "${#QGW_Releases_Array[@]}" -gt 1 ]] && printf "  [r] reselect release, view distro web pages   or "
        [[ "${#QGW_Editions_Array[@]}" -gt 1 ]] && printf "  [e] reselect edition, release or view distro web pages,   or "
      fi

      if [[ $QGW_Download_BadLink ]]; then

        printColor "\n\n  [enter]  re-test the download link "
        [[ $WebBrowser ]] && [[ $QGW_OS_HomePage ]] && printf "  [w] try opening the listed page with web browser "  

      else

        if [[ $QGW_OverWriteAlert ]];then  

          printf "\n\n  Files are present. Resume download or overwrite? \n\n"
          ls -oh "$QWG_Conf_Dir/$QWG_NewVM_Name"  2> /dev/null

          DL_SizeAlready=
          DL_PercentageDone=

          if [[ $DL_PotentialSize && $DL_FileName ]]; then
            DL_SizeAlready="$(du -b "$QWG_Conf_Dir/$QWG_NewVM_Name/$DL_FileName" 2>/dev/null | awk '{print $1}' | tr -cd '[:digit:]')"
            if [[ $DL_PotentialSize -ge 1 && $DL_SizeAlready -ge 1 ]]; then 
              DL_PercentageDone="$(bc <<< "scale=2; (($DL_SizeAlready/$DL_PotentialSize)*100)/1")"
            else 
              printf "\n\n  Detection of sizes not fully possible: \n\n  Potential size  %s  \n  Already present %s \n" "$DL_PotentialSize" "$DL_SizeAlready"
              DL_PercentageDone="0"
            fi
          fi
          if [[ $DL_PercentageDone ]]; then printf "\n  %s Percent appears to be downloaded"  "$DL_PercentageDone"
          else printf "\n  Percent downloaded not known"
          fi

          printf  "\n\n  [enter] Start the download  "
          printColor " ?? BACKUP ??  " 

        else  

          if [[ $QE_SourceVersion == "System" || $QE_SourceVersion == "Echo" ]]; then
            printColor "\n\n  WARNING Source Version '%s' :  Stopping and Restarting of partly completed downloads requires the Freebird/FreeSpirit builtins." "$QE_SourceVersion"
          fi

          if [[ "${#VM_Folder_List[*]}" -gt 1 ]]; then  printf  "\n\n  [enter] Start the download  "
          else printColor  "\n\n  [enter] Start the download  " 
          fi

        fi

        if [[ $ZsyncDownload ]]; then
          [[ ! $(type -p zsync) ]] && printf "\n\n  WARNING 'zsync' not found.  Screen output may vary. Quickget should hopefully revert to using wget ...\n\n "
        elif [[ "${#VM_Folder_List[*]}" -gt 1 ]]; then
          if [[ $QGW_OverWriteAllow ]]; then printColor "[number] select a DIFFERENT FOLDER  "
          else printf "[number] select a different (preset or current) folder  "
          fi
        fi

      fi
      
      printf " [h] help  [b] back to main menu \n\n\n"
      read -rp "  >  " QGW_DownloadStart
      printf "\n\n"

      case "$QGW_DownloadStart" in

        b)
          clear_main_gt_start_vars
          QGW_List_NumSelected_Next=
          if [[ $MainMenuZsync ]]; then 
            MainMenuZsync= 
          else 
            Zsync_OS_Name=
            Zsync_Release_Name=
            function_quick_get_wrap
          fi
          return
        ;;

        e)
          QGW_Edition_Arr_NumSelected=
          QGW_Edition_Arr_NameSelected=
          Zsync_OS_Name=
          Zsync_Release_Name=
          QGW_DownloadStart=
          QGW_DownloadSelection=
          QGW_Download_BadLink=
          printf "  Reselecting Edition: \n\n"
          choose_QGW_edition
          finalize_QGW_targets
          break
        ;;

        r)
          QGW_List_NumSelected=
          QGW_Release_Arr_NumSelected=
          QGW_Release_Arr_NameSelected=
          QGW_Edition_Arr_NumSelected=
          QGW_Edition_Arr_NameSelected=
          Zsync_OS_Name=
          Zsync_Release_Name=
          QGW_DownloadStart=
          QGW_DownloadSelection=
          QGW_Download_BadLink=
          printf "  Reselecting Release: \n\n\n"
          choose_QGW_release
          printf "  Reselecting Edition: \n\n"
          choose_QGW_edition
          finalize_QGW_targets
          break
        ;;

        [0-9]|[0-9][0-9]) 
          QWG_Conf_Dir="${VM_Folder_List[QGW_DownloadStart]}"
        ;;

        h)  
          printf     "  Once the download and initial setup up has finished, "
          printf "\n\n  the new folder and .conf file may be easily moved and/or edited before running.\n" 

          printf "\n\n  For new preset folders, edit the main settings.\n" 

          printf "\n\n  Part downloads can usually be re-started, if stopped."
          printf "\n\n  Zsync Iso Updates may leave residual rcksum files, if stopped, and may need removing."
          printf "\n\n  But, if an iso.part file has been started, a restart is possible, after doing a re-sync."
          printf "\n\n  If re-syncing, the rcksum files will be auto-removed.\n"

          show_current_group_folder_list

          printf "\n\n"
        ;;

        w)  
          nohup &> /dev/null  "$WebBrowser"  "$QGW_OS_HomePage"  & 
        ;;

        *)
          if [[ $QGW_Download_BadLink ]]; then  
            QGW_BadLink_ReTest=1 ; function_test_iso_url
          else
            if [[ $QGW_OverWriteAlert ]]; then 
              printf "  RECONFIRMATION is required  >>  %s"  "$QWG_NewVM_Name"
              printf "\n\n  [enter] to go back" ; printColor "   [yes] to confirm \n\n"
              read -rp "  >  "  ISO_OvWr
              printf "\n\n"
              if [[ $ISO_OvWr ]]; then QGW_OverWriteAllow=1 ; QGW_DownloadStart="start" ; break ; fi  
            else 
              #printf "\n\n"
              QGW_DownloadStart="start" ; break
            fi
          fi
        ;;

      esac

      if [[ ! $QWG_Conf_Dir ]] || [[ ! -d "$QWG_Conf_Dir" ]]; then
        QWG_Conf_Dir="$Default_VM_Folder" 
        printf "\n  Using %s for now.  \n\n  Selected Download Folder not found.  Reselect or Move Later ... \n\n"  "$Default_VM_Folder" 
        QWG_Conf_Dir="$Default_VM_Folder" 
      fi
      
      cd "$QWG_Conf_Dir" || printColor "  ERROR changing to New VM Location"
      Current_VM_Folder="$QWG_Conf_Dir" 

    done

  }

  [[ $GT_Exit ]] && return
  choose_QGW_release

  [[ $GT_Exit ]] && return
  choose_QGW_edition

  [[ $GT_Exit ]] && return
  finalize_QGW_targets

  dev_loop_check

  [[ $GT_Exit ]] && return
  
  if [[ $QGW_DownloadStart == "start" ]]; then

    QGW_DownloadStart=
    QGW_DownloadStopped=
    QGW_List_NumSelected_Next=
    QGW_List_NumSelected_Previous=
   
    if [[ $ZsyncDownload ]]; then
      printf "  If stopped, Zsync Iso Updates may leave residual rcksum files that qqX will remove."  
      printf "\n\n  To resume stopped downloads, any \".iso.part\" files should be retained."
      # https://bugs.launchpad.net/ubuntu/+source/zsync/+bug/477551

      function remove_old_rcksum_files {
        if [[ $(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null) ]]; then
          mapfile -t RckSumArray <<< "$(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null)"
          for RckItem in "${RckSumArray[@]}"; do rm "$RckItem"; done
        fi
      }

      remove_old_rcksum_files

    else

      printf "  Once a download and initial setup up has finished, the new folder and .conf file may be easily moved"
      printf "\n\n  and/or edited before running. Part downloads can usually be re-started, if stopped >> "

    fi
    
    if [[ $ZsyncDownload ]]; then  printf "\n\n" ; else printColor "  %s \n\n" "$QWG_NewVM_Name"
    fi

    function show_rcksum_progress {

      RckFile="$(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null)"
      LastZsync="0" 
      [[ -d "$VM_InstanceName" ]] && date +%s > "$VM_InstanceName/zsync.date.txt"
      while [[ -e "$RckFile" ]]; do
        RckDone="$(du -a "$RckFile" 2> /dev/null)"
        RckDone="${RckDone/"$RckFile"/}"
        # gives some kind of rough indication that work is in progress  (percentages don't seem to be possible)
        printf "  Comparing images >    %s "  "$RckDone" 
        sleep 2
        printf "\e[2K\r"
      done
    }

    # clear any accidental initial double pressing of the enter key
		read -r -t 0.2  
		read -r -t 0.2  
		read -r -t 0.2 		

    printColor   "\n  Press [enter] at quickget finish,  at  \"start your .. virtual machine ... etc\" "
    printColor "\n\n  OR  [enter] to STOP ALL current downloads & zsync, either to cancel or to resume later"
    printf     "\n\n  Note that downloads can sometimes pause if servers are overloaded but they should auto-resume if given time."
    [[ "$QGW_DownloadSelection" == *'windows'* ]] && printf "\n\n  Microsoft downloads may sometimes hang when finished but the terminal may be safely closed, if this happens."

    printf   "\n\n\n  Quickemu & downloader output: "
    # stop flashing cursor
    tput civis

    #  Although quickget will run as a background process, quickget will then go on to run aria2 etc 
    #  but as even further into the background. The download programs will grab the cursor in order to report progress
    #  and as this will compete with read & keyboard input we are limited to using [enter] ....

    #  quickget will also run a python3 command for macrecovery for MacOS 
    #  eg 26102 pts/1    S+     0:11 python3 /usr/bin/macrecovery --board-id Mac-00BE6ED71E35EB86 --mlb 00000000000000000 --os-type default --basename Recover
   
    # QUICKGET RUNS FIRST, in the background, THEN quickget starts a separate downloader  eg curl, 
    # so processes can be difficult to track at this point. 

    # qqX ver 1.11 adds an output file into the freespirit code to see if an output folder has been produced
    # as the Quickget final name output can vary from expected. 
    printf "" > "/tmp/qe_new_vm_name.txt"

    quickget "$QGW_DownloadSelection" &  
  
    printf "\n\n\n\n\n"
    printf "\e[3A\r"

    #  make line spaces then move the cursor up from the bottom     
    # See https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797   "\e[1A\r"  "\e[2K\r"  etc 

    #  WAIT for background things to start happening
    sleep 3   
    while true ; do 
      mapfile -t  Jobs_Arr <<< "$(jobs -p)"; sleep 0.5 ; [[ ${Jobs_Arr[*]} ]] && break
    done

    # THEN wait for an enter key press

    while true ; do    

      # zsync:
      if [[ $(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null) ]]; then  show_rcksum_progress &
      elif [[ $ZsyncDownload ]]; then 
        if [[ $(pgrep zsync 2>/dev/null) ]] ; then 
          printf "\n  Comparing images .... \n\n" 
          LastZsync="0" 
          [[ -d "$VM_InstanceName" ]] && date +%s > "$VM_InstanceName/zsync.date.txt"
        else  printf "\n  [enter] to close updater  >  zsync has stopped.\n\n" 
        fi
      fi

      ##  WAIT HERE for an [enter] to finish, or stop  ##
      read -r 

      # return cursor to normal
      tput cnorm 

      for Jobs_PID in "${Jobs_Arr[@]}" ; do 
        #[[ $Jobs_PID ]] && QGW_DownloadStopped=1
        kill "$Jobs_PID" 2> /dev/null 
      done

      # removing the old rcksum files not only tidies up but also stops the background monitor process
      [[ $(ls "$VM_Conf_Dir/"rcksum* 2> /dev/null) ]] && remove_old_rcksum_files
      
      # check macOS particularities ...
      # '/usr/bin/macrecovery' now deprecated and has been replaced with chunkcheck  REVIEW  
      P3_Arr=()
      mapfile -t  P3_Arr <<< "$(pgrep python3)"
      for P3_PID in "${P3_Arr[@]}" ; do
        P3_MacOS_Cmd="$(ps --no-headers -o cmd "$P3_PID" 2> /dev/null)" 
        if [[ "$P3_MacOS_Cmd" == *'macrecovery'* || "$P3_MacOS_Cmd" == *'chunkcheck'* ]]; then 
          kill "$P3_PID" 2> /dev/null
          printColor "\n\nStopped \n\n" 
          QGW_DownloadStopped=1
          break
        fi
      done   

      if [[ $(pgrep aria2) || $(pgrep curl) || $(pgrep wget) || $(pgrep zsync) ]]; then
        while true; do 
          pkill aria2  2> /dev/null
          pkill curl   2> /dev/null
          pkill wget   2> /dev/null
          pkill zsync  2> /dev/null
          sleep 1
          if [[ ! $(pgrep aria2) ]] && [[ ! $(pgrep curl) ]] && [[ ! $(pgrep wget) ]] && [[ ! $(pgrep zsync) ]]; then
            QGW_DownloadStopped=1
            sleep 1 ; break
          fi
        done
      fi
      break

    done

  fi

  [[ $GT_Exit ]] && return

  # clear any accidental double pressing of the enter key if instance was slow to close
  # also gives pause needed to give different processes time to output their summaries & finish up
  read -r -t 0.2  
  read -r -t 0.2  
  read -r -t 0.2  
  read -r -t 0.2  
  read -r -t 0.2  
  read -r -t 0.1	
  read -r -t 0.1	
  read -r -t 0.1	
  read -r -t 0.1	
  read -r -t 0.1	
  read -r -t 0.1	

  New_VM_InstanceName=
  New_VM_Conf_File=
  QGW_FolderDelete=

  # do pre-process if standard download

  if [[ ! $ZsyncDownload ]]; then
    # folder check the theoretical name ... 
    if [[ -d "${QWG_Conf_Dir}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}-${QGW_Edition_Arr_NameSelected}" ]]; then 
      New_VM_InstanceName="${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}-${QGW_Edition_Arr_NameSelected}"
    elif [[ -d "${QWG_Conf_Dir}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}" ]]; then 
      New_VM_InstanceName="${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}"
    elif [[ -d "${QWG_Conf_Dir}/${QGW_OS_Arr_NameSelected}" ]]; then 
      New_VM_InstanceName="${QGW_OS_Arr_NameSelected}"
    fi
    #  file check  .conf 
    if [[ -f "${QWG_Conf_Dir}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}.conf" ]]; then 
      New_VM_Conf_File="${QWG_Conf_Dir}/${QGW_OS_Arr_NameSelected}-${QGW_Release_Arr_NameSelected}.conf"
    elif [[ -f "${QWG_Conf_Dir}/${QGW_OS_Arr_NameSelected}.conf" ]]; then 
      New_VM_Conf_File="${QGW_OS_Arr_NameSelected}.conf"
    elif [[ -f "${QWG_Conf_Dir}/${New_VM_InstanceName}.conf" ]]; then 
      New_VM_Conf_File="${New_VM_InstanceName}.conf"
    fi
  fi

  if [[ ! -d "$New_VM_InstanceName" ]]; then
    # Quickget final name output can vary from expected. qqX ver 1.11 adds an output into the freespirit code
    if grep -sq 'New_VM_InstanceName' "/tmp/qe_new_vm_name.txt" ; then 
      source "/tmp/qe_new_vm_name.txt"
      New_VM_Conf_File="${New_VM_InstanceName}.conf"
    else
      QGW_DownloadStopped=1
    fi
  fi

  # Determine output cases:
  if  [[ $ZsyncDownload ]]; then

    if [[ $QGW_DownloadStopped ]]; then 
      printf "\n  Download Stopped > Residual files may be present"
      printf "\n\n  Removal of any residual files & folders has to be completed manually"
      if [[ $Zsync_Updatable_ISO ]]; then
        printf "\n\n  Part downloads can usually be re-started if the .iso.part file is retained."
      else
        printf "\n\n  Part downloads can usually be re-started if the folder is retained."
        printf "\n\n  Dev downloads usually undergo some kind of NAMING variance"
      fi
    else  
      if [[ ! $Zsync_Updatable_ISO ]]; then 
        printf   "\n  End of Quickget processes ..." 
        printf "\n\n  as Dev downloads usually undergo some kind of NAMING variance" 
        printf "\n\n  checking of files & folders should to be completed manually"
      fi
    fi
        
    # Note (@2023/07) that quickget includes code to remove 'zs.old' files, which may or may not have been needed,
    # but Zsync can now give these files root protection so this removal may not work ...   
    # REVIEW Deletion and re-download may be the simpler way to go.  Zsync has a lot of code to keep maintained ...
      ZsyncDownload=

  elif [[ -d "$New_VM_InstanceName" ]]; then
  
    printColor "  Folder:  %s "  "$New_VM_InstanceName"
    [[ -e "$New_VM_Conf_File" ]] && printColor "\n .conf file created:  %s "  "$(basename "$New_VM_Conf_File")"

    if [[ ! $New_VM_Conf_File ]] || [[ $QGW_DownloadStopped ]]; then

      if [[ $QGW_DownloadStopped ]]; then
        printf "\n\n  Download Stopped > Residual files are present"
        printf "\n\n  Linux part downloads can usually be re-started if the folder is retained."
      fi
      [[ ! $New_VM_Conf_File ]] && printf "\n\n  As there is no .conf file, there may have been an ERROR >" 

      New_VM_Folder_Contents="$(ls "$New_VM_InstanceName" 2>/dev/null)"
      printColor "\n\n  Folder contents:"
      if [[ $New_VM_Folder_Contents ]]; then  printf "\n\n%s " "$New_VM_Folder_Contents"
      else  printf "  None found"
      fi
      printColor "\n\n  [d] delete the folder" 
      [[ $New_VM_Conf_File ]] && printColor " and .conf" 
      printf "  [enter] to retain & continue "
      printf "\n\n\n"
      read -rp "  >  "    QGW_FolderDelete

      if [[ $QGW_FolderDelete == "d" ]]; then
        printf "\n\n  Folder/file being deleted ... \n\n"
        [[ -d "$New_VM_InstanceName" ]] && rm -f -r "$New_VM_InstanceName"
        [[ -e "$New_VM_Conf_File" ]] && rm -f "$New_VM_Conf_File"
      else  
        printf  "\n\n Folder/file retained \n\n"
      fi
      sleep 1.4
      cd "$Default_VM_Folder" || DefaultFolderError=1
      Current_VM_Folder="$Default_VM_Folder" 
      New_VM_InstanceName= ; VM_Conf_Dir= ; VM_Conf_File= 
      refresh_sources_and_load_VM_arrays
      return
    fi

  elif [[ ! -d "$New_VM_InstanceName" ]]; then
  
    printf "  NO Folder/Download found ... %s "  "$New_VM_InstanceName"
    if [[ -e "$New_VM_Conf_File" ]]; then printf "\n .conf file created:  %s "  "$(basename "$New_VM_Conf_File")"
    else printf "\n .conf file NOT created or found %s "  "$(basename "$New_VM_Conf_File")"
    fi
    if [[ $QGW_DownloadStopped ]]; then
      printf "\n\n  Download Stopped > there may have been an ERROR "
      printColor "\n\n  [enter] to cancel & return \n\n"
      read -rp "  >  "  
      sleep 0.5
      cd "$Default_VM_Folder" || DefaultFolderError=1
      Current_VM_Folder="$Default_VM_Folder" 
      New_VM_InstanceName= ; VM_Conf_Dir= ; VM_Conf_File= 
      refresh_sources_and_load_VM_arrays
      return
    fi

  fi

  if [[ $New_VM_Conf_File ]] && [[ ! $QGW_DownloadStopped ]]; then

    # clear any accidental initial double pressing of the enter key occuring while experiencing any error or pause
    read -r -t 0.1  
    read -r -t 0.1  
    read -r -t 0.1  
    read -r -t 0.1	
    read -r -t 0.1  
    read -r -t 0.1 

    VM_InstanceName="$New_VM_InstanceName"   
    VM_Conf_Dir="$QWG_Conf_Dir"
    VM_Conf_File="$(basename "$New_VM_Conf_File")"

    refresh_sources_and_load_VM_arrays

    NewFileTuneUp=1
    function_config_tune_up  "$VM_Conf_Dir/$VM_Conf_File"  

    # make sure values have been read, and at the least basic in case the tune up utility gets skipped
    refresh_conf_vars_and_values
    NewFileTuneUp=
    NewFileTuneUp_JustDone=1

  elif [[ $QGW_FolderDelete == "d" ]]; then  sleep 1

  else  
  
    [[ $Zsync_Updatable_ISO ]] && printf "\e[3A\r"

    printColor "\n\n  [enter] to continue or return \n\n" ; read -rp "  > " 
    printf "\n\n"
    return
    
  fi

  if [[ $VM_Conf_Dir ]]; then cd "$VM_Conf_Dir"  || function_conf_error  "Working Directory NOT FOUND ," ; fi
  Current_VM_Folder="$VM_Conf_Dir" 

  clear_main_gt_start_vars
  SettingsFileAdjusted=1
  ByPass_VM_Array_Selector=1
  GT_Exit=1

}

